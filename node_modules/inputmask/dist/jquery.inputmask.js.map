{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./bundle.jquery.js","webpack:///./bundle.js","webpack:///./lib/extensions/inputmask.extensions.js","webpack:///./lib/inputmask.js","webpack:///./lib/dependencyLibs/inputmask.dependencyLib.jquery.js","webpack:///external {\"commonjs\":\"jquery\",\"commonjs2\":\"jquery\",\"amd\":\"jquery\",\"root\":\"jQuery\"}","webpack:///./lib/global/window.js","webpack:///./lib/maskset.js","webpack:///./lib/maskScope.js","webpack:///./lib/extensions/inputmask.date.extensions.js","webpack:///./lib/extensions/inputmask.numeric.extensions.js","webpack:///./lib/jquery.inputmask.js","webpack:///webpack/bootstrap"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__5__","im","jQuery","dependencyLib","Inputmask","ipValidator","chrs","maskset","pos","strict","opts","buffer","RegExp","test","extendDefinitions","validator","casing","extendAliases","regex","autoUnmask","mask","definitions","onUnMask","maskedValue","unmaskedValue","inputmode","greedy","onBeforePaste","pastedValue","toLowerCase","replace","clearIncomplete","$","document","generateMaskSet","analyseMask","maskScope","alias","options","internal","this","el","undefined","events","refreshValue","isPlainObject","extend","defaults","noMasksCache","userOptions","resolveAlias","isRTL","numericInput","aliasStr","aliasDefinition","prototype","aliases","importAttributeOptions","npt","dataAttribute","importOption","option","optionData","getAttribute","indexOf","importDataAttributes","attrOptions","dataoptions","p","JSON","parse","dir","rightAlign","style","textAlign","removeAttribute","Object","keys","length","placeholder","optionalmarker","quantifiermarker","groupmarker","alternatormarker","escapeChar","oncomplete","noop","onincomplete","oncleared","repeat","removeMaskOnSubmit","clearMaskOnLostFocus","insertMode","onKeyDown","onBeforeMask","isFunction","call","onBeforeWrite","showMaskOnFocus","showMaskOnHover","onKeyValidation","skipOptionalPartCharacter","undoOnEscape","radixPoint","_radixDance","groupSeparator","keepStatic","positionCaretOnTab","tabThrough","supportsInputType","ignorables","isComplete","preValidation","postValidation","staticDefinitionSymbol","jitMasking","nullable","inputEventOnly","noValuePatching","positionCaretOnClick","shiftPositions","definitionSymbol","masksCache","elems","that","getElementById","querySelectorAll","nodeName","each","ndx","scopedOpts","inputmask","remove","data","noremask","unmaskedvalue","value","getemptymask","hasMaskedValue","getmetadata","isValid","format","metadata","setValue","trigger","extendDefaults","definition","unmask","escapeRegex","str","specials","join","keyCode","BACKSPACE","BACKSPACE_SAFARI","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","SPACE","TAB","UP","X","CONTROL","jquery","eval","nocache","ms","generateMask","regexMask","masksetDefinition","maskdefKey","repeatStart","split","reverse","isArray","charAt","altMask","msk","pop","tokenizer","regexTokenizer","escaped","currentToken","MaskToken","match","m","openenings","maskTokens","openingToken","currentOpeningToken","alternator","lastMatch","closeRegexGroup","isGroup","isOptional","isQuantifier","isAlternator","matches","openGroup","alternatorGroup","quantifier","min","max","insertTestDefinition","mtoken","element","position","prevMatch","splice","fn","static","optionality","newBlockMarker","def","nativeDef","lmnt","maskdef","verifyGroupMarker","maskToken","token","nextToken","defaultCase","mndx","push","reverseTokens","reverseStatic","st","hasOwnProperty","intMatch","parseInt","qt","groupify","groupToken","closeGroup","groupQuantifier","exec","altRegexGroup","mqj","mq","mq0","isNaN","mq1","jit","tmpMatch","subToken","ua","navigator","userAgent","ie","mobile","iemobile","iphone","actionObj","undoValue","$el","skipKeyPressEvent","skipInputEvent","validationEvent","ignorable","maxLength","mouseEnter","originalPlaceholder","getMaskTemplate","baseOnInput","minimalPos","includeMode","noJit","clearOptionalTail","maskTemplate","ndxIntlzr","testPos","validPositions","generatedInput","input","determineTestTemplate","getTests","locator","slice","getPlaceholder","getTestTemplate","isFinite","maskLength","resetMaskSet","soft","getLastValidPosition","closestTo","before","after","valids","posNdx","psNdx","getDecisionTaker","tst","decisionTaker","alternation","toString","getLocator","align","mloc","tests","altTest","getTest","targetLocator","tstLocator","closest","bestMatch","distance","Math","abs","optionalQuantifier","tstPs","positionCanMatchDefinition","testDefinition","valid","defProp","tndx","jitOffset","ndxInitializer","insertStop","latestMatch","cacheDependency","resolveTestFromToken","loopNdx","quantifierRecurse","handleMatch","isFirstMatch","tokenGroup","firstMatch","inArray","resolveNdxInitializer","alternateNdx","targetAlternation","indexPos","ndxPos","bestMatchAltIndex","isSubsetOf","source","target","expand","pattern","expanded","start","end","l","charCodeAt","String","fromCharCode","staticCanMatchDefinition","setMergeLocators","targetMatch","altMatch","locNdx","optionalToken","mtchsNdx","mtch","alternateToken","malternateMatches","maltMatches","currentMatches","loopNdxCnt","altIndex","shift","currentPos","ndxInitializerClone","altIndexArr","amndx","excludes","altIndexArrClone","unMatchedAlternation","concat","ndx1","dropMatch","ndx2","altMatch2","qndx","mergeLocators","previousPos","cd","mtndx","getBufferTemplate","_buffer","getBuffer","noCache","refreshFromBuffer","valResult","negationSymbol","front","caret","elem","toUpperCase","posBefore","args","Array","arguments","apply","checkAlternationMatch","altArr1","altArr2","na","altArrC","isMatch","naArr","naNdx","alndx","alternate","maskPos","c","fromIsValid","rAltPos","selection","validPsClone","tstClone","lastAlt","isValidRslt","returnRslt","altPos","prevAltPos","validPos","decisionPos","lAltPos","nextPos","begin","validInputs","resultPos","fromAlternate","validateOnly","isSelection","posObj","processCommandObject","commandObj","sort","b","revalidateMask","insert","refresh","rewritePosition","_isValid","rslt","validatedPos","result","positionsClone","currentPosValid","seekNext","skip","isMask","nPos","snPos","trackbackPositions","postResult","endResult","originalPos","newPos","fillOnly","ps","vp","np","cvpInput","validTest","IsEnclosedStatic","posMatch","nextMatch","offset","lvp","j","t","fuzzy","newBlock","seekPrevious","writeBuffer","caretPos","event","triggerEvents","_valueSet","type","$input","nptVal","_valueGet","setTimeout","returnPL","staticAlternations","prevTest","HandleNativePlaceholder","nptValue","determineNewCaretPosition","selectedCaret","tabbed","doRadixFocus","clickPos","digits","vps","radixPos","clickPosition","lvclickPosition","lastPosition","tt","EventRuler","on","eventName","eventHandler","ev","e","imOpts","off","disabled","readOnly","ctrlKey","originalEvent","inputType","preventDefault","blur","focus","returnVal","stopPropagation","form","evArr","EventHandlers","keydownEvent","fromInputFallback","k","kdResult","handleRemove","shiftKey","altKey","checkVal","translatePosition","keypressEvent","checkval","writeOut","which","charCode","metaKey","forwardPosition","writeOutBuffer","pasteEvent","inputValue","tempValue","valueBeforeCaret","substr","valueAfterCaret","clipboardData","getData","pasteValue","inputFallBackEvent","radixPointHandler","ieMobileHandler","inputChar","iv","frontPart","backPart","frontBufferPart","backBufferPart","entries","isEntry","fpl","activeElement","entry","keypress","Event","keydown","compositionendEvent","setValueEvent","detail","applyInputValue","focusEvent","clickEvent","invalidEvent","mouseleaveEvent","newCaretPosition","cutEvent","clipData","setData","execCommand","blurEvent","mouseenterEvent","submitEvent","resetEvent","valueBuffer","nptvl","initiatingEvent","charCodes","initialNdx","isTemplateMatch","targetTemplate","charCodeNdx","staticMatches","prevCaretPos","sndx","nextValid","nextSndx","umValue","pndx","bufferValue","notranslate","range","selectionStart","selectionEnd","getSelection","getRangeAt","commonAncestorContainer","parentNode","startOffset","endOffset","createRange","duplicate","moveStart","text","scrollCalc","ownerDocument","defaultView","getComputedStyle","currentStyle","fontSize","scrollLeft","scrollWidth","setSelectionRange","firstChild","textNode","createTextNode","appendChild","setStart","setEnd","collapse","sel","removeAllRanges","addRange","createTextRange","moveEnd","select","determineLastRequiredPosition","returnDefinition","bl","positions","lvTest","lvTestAlt","template","complete","lrp","aml","pend","isElementTypeSupported","patchValueProperty","valueGet","valueSet","patchValhook","valHooks","inputmaskpatch","valhookGet","get","valhookSet","set","getter","setter","installNativeValueSetFallback","__valueGet","getOwnPropertyDescriptor","getPrototypeOf","__proto__","object","constructor","valueProperty","defineProperty","configurable","tagName","textContent","__lookupGetter__","__lookupSetter__","__defineGetter__","__defineSetter__","__valueSet","overruleRTL","elementType","isSupported","isContentEditable","createElement","setAttribute","autocomplete","action","rl","lmib","cv","maskTarget","mtdt","formatCode","d","Date","setDate","getDate","dd","pad","ddd","dddd","setMonth","getMonth","mm","mmm","mmmm","yy","setFullYear","getFullYear","yyyy","h","setHours","getHours","hh","hhh","H","HH","HHH","M","setMinutes","getMinutes","MM","s","setSeconds","getSeconds","ss","setMilliseconds","getMilliseconds","L","T","TT","Z","o","S","formatAlias","isoDate","isoTime","isoDateTime","isoUtcDateTime","getTokenizer","tokens","isValidDate","dateParts","currentResult","rawday","day","rawyear","date","rawmonth","month","isDateInRange","rawYear","minYear","year","getTime","dateObjValue","raw","lastIndex","getFn","val","len","maskString","dateObj","targetProp","dateOperation","extendProperty","correctedValue","i18n","ordinalSuffix","inputFormat","displayFormat","outputFormat","dayNames","monthNames","calcPos","part","index","today","getYear","autoEscape","txt","escapedTxt","alignDigits","digitsOptional","radixPosition","findValidator","symbol","tstNdx","ndxl","findValid","ret","parseMinMaxOptions","parseFloat","NaN","Number","MIN_VALUE","MAX_VALUE","genMask","decimalDef","__financeInput","prefix","_mask","dq","suffix","hanndleRadixDance","back","decimalValidator","checkForLeadingZeroes","numberMatches","number","leadingzeroes","enforceDigitsOnBlur","allowMinus","step","unmaskAsNumber","isNegative","unmasked","processValue","initialValue","valueParts","integerPart","decimalPart","digitsFactor","pow","round","substring","numberValue","stripBuffer","stripRadix","buf","caretNdx","newCaretPos","nmbrMtchs","bffr","nptmask","installedModules","__webpack_require__","modules","name","enumerable","r","Symbol","toStringTag","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","property","moduleId"],"mappings":"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","file":"dist/jquery.inputmask.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"jquery\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"jquery\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"jquery\")) : factory(root[\"jQuery\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__5__) {\nreturn ","var im = require(\"./bundle\");\r\nvar jQuery = require(\"jquery\");\r\nif (im.dependencyLib === jQuery) {\r\n\trequire(\"./lib/jquery.inputmask\");\r\n}\r\n\r\nmodule.exports = im;\r\n\r\n","require(\"./lib/extensions/inputmask.extensions\");\r\nrequire(\"./lib/extensions/inputmask.date.extensions\");\r\nrequire(\"./lib/extensions/inputmask.numeric.extensions\");\r\nmodule.exports = require(\"./lib/inputmask.js\");\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\");\r\n//extra definitions\r\nInputmask.extendDefinitions({\r\n\t\"A\": {\r\n\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\" //auto uppercasing\r\n\t},\r\n\t\"&\": { //alfanumeric uppercasing\r\n\t\tvalidator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\"\r\n\t},\r\n\t\"#\": { //hexadecimal\r\n\t\tvalidator: \"[0-9A-Fa-f]\",\r\n\t\tcasing: \"upper\"\r\n\t}\r\n});\r\n\r\n\r\nfunction ipValidator(chrs, maskset, pos, strict, opts) {\r\n\tif (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\r\n\t\tchrs = maskset.buffer[pos - 1] + chrs;\r\n\t\tif (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\r\n\t\t\tchrs = maskset.buffer[pos - 2] + chrs;\r\n\t\t} else chrs = \"0\" + chrs;\r\n\t} else chrs = \"00\" + chrs;\r\n\treturn new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n}\r\n\r\n\r\nInputmask.extendAliases({\r\n\t\"cssunit\": {\r\n\t\tregex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\r\n\t},\r\n\t\"url\": { //needs update => https://en.wikipedia.org/wiki/URL\r\n\t\tregex: \"(https?|ftp)//.*\",\r\n\t\tautoUnmask: false\r\n\t},\r\n\t\"ip\": { //ip-address mask\r\n\t\tmask: \"i[i[i]].j[j[j]].k[k[k]].l[l[l]]\",\r\n\t\tdefinitions: {\r\n\t\t\t\"i\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"j\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"k\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"l\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"numeric\",\r\n\t},\r\n\t\"email\": {\r\n\t\t//https://en.wikipedia.org/wiki/Domain_name#Domain_name_space\r\n\t\t//https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\r\n\t\t//should be extended with the toplevel domains at the end\r\n\t\tmask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n\t\tgreedy: false,\r\n\t\tcasing: \"lower\",\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\tpastedValue = pastedValue.toLowerCase();\r\n\t\t\treturn pastedValue.replace(\"mailto:\", \"\");\r\n\t\t},\r\n\t\tdefinitions: {\r\n\t\t\t\"*\": {\r\n\t\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5!#$%&'*+/=?^_`{|}~-]\"\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: \"[0-9A-Za-z-]\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"email\"\r\n\t},\r\n\t\"mac\": {\r\n\t\tmask: \"##:##:##:##:##:##\"\r\n\t},\r\n\t//https://en.wikipedia.org/wiki/Vehicle_identification_number\r\n\t// see issue #1199\r\n\t\"vin\": {\r\n\t\tmask: \"V{13}9{4}\",\r\n\t\tdefinitions: {\r\n\t\t\t\"V\": {\r\n\t\t\t\tvalidator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n\t\t\t\tcasing: \"upper\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearIncomplete: true,\r\n\t\tautoUnmask: true\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask Core\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tgenerateMaskSet = require(\"./maskset\").generateMaskSet,\r\n\tanalyseMask = require(\"./maskset\").analyseMask,\r\n\tmaskScope = require(\"./maskScope\");\r\n\r\n\r\nfunction Inputmask(alias, options, internal) {\r\n\t//allow instanciating without new\r\n\tif (!(this instanceof Inputmask)) {\r\n\t\treturn new Inputmask(alias, options, internal);\r\n\t}\r\n\r\n\tthis.el = undefined;\r\n\tthis.events = {};\r\n\tthis.maskset = undefined;\r\n\tthis.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)\r\n\r\n\tif (internal !== true) {\r\n\t\t//init options\r\n\t\tif ($.isPlainObject(alias)) {\r\n\t\t\toptions = alias;\r\n\t\t} else {\r\n\t\t\toptions = options || {};\r\n\t\t\tif (alias) options.alias = alias;\r\n\t\t}\r\n\t\tthis.opts = $.extend(true, {}, this.defaults, options);\r\n\t\tthis.noMasksCache = options && options.definitions !== undefined;\r\n\t\tthis.userOptions = options || {}; //user passed options\r\n\t\tresolveAlias(this.opts.alias, options, this.opts);\r\n\t\tthis.isRTL = this.opts.numericInput;\r\n\t}\r\n}\r\n\r\nInputmask.prototype = {\r\n\tdataAttribute: \"data-inputmask\", //data attribute prefix used for attribute binding\r\n\t//options default\r\n\tdefaults: {\r\n\t\tplaceholder: \"_\",\r\n\t\toptionalmarker: [\"[\", \"]\"],\r\n\t\tquantifiermarker: [\"{\", \"}\"],\r\n\t\tgroupmarker: [\"(\", \")\"],\r\n\t\talternatormarker: \"|\",\r\n\t\tescapeChar: \"\\\\\",\r\n\t\tmask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value\r\n\t\tregex: null, //regular expression as a mask\r\n\t\toncomplete: $.noop, //executes when the mask is complete\r\n\t\tonincomplete: $.noop, //executes when the mask is incomplete and focus is lost\r\n\t\toncleared: $.noop, //executes when the mask is cleared\r\n\t\trepeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\r\n\t\tgreedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\r\n\t\tautoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\r\n\t\tremoveMaskOnSubmit: false, //remove the mask before submitting the form.\r\n\t\tclearMaskOnLostFocus: true,\r\n\t\tinsertMode: true, //insert the input or overwrite the input\r\n\t\tclearIncomplete: false, //clear the incomplete input on blur\r\n\t\talias: null,\r\n\t\tonKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts\r\n\t\tonBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.\targs => initialValue, opts => return processedValue\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\treturn $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\r\n\t\t}, //executes before masking the pasted value to allow preprocessing of the pasted value.\targs => pastedValue, opts => return processedValue\r\n\t\tonBeforeWrite: null, //executes before writing to the masked element. args => event, opts\r\n\t\tonUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.\targs => maskedValue, unmaskedValue, opts\r\n\t\tshowMaskOnFocus: true, //show the mask-placeholder when the input has focus\r\n\t\tshowMaskOnHover: true, //show the mask-placeholder when hovering the empty input\r\n\t\tonKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts\r\n\t\tskipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\r\n\t\tnumericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\r\n\t\trightAlign: false, //align to the right\r\n\t\tundoOnEscape: true, //pressing escape reverts the value to the value before focus\r\n\t\t//numeric basic properties\r\n\t\tradixPoint: \"\", //\".\", // | \",\"\r\n\t\t_radixDance: false, //dance around the radixPoint\r\n\t\tgroupSeparator: \"\", //\",\", // | \".\"\r\n\t\t//numeric basic properties\r\n\t\tkeepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks\r\n\t\tpositionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB\r\n\t\ttabThrough: false, //allows for tabbing through the different parts of the masked field\r\n\t\tsupportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], //list with the supported input types\r\n\t\t//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\r\n\t\tignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\r\n\t\tisComplete: null, //override for isComplete - args => buffer, opts - return true || false\r\n\t\tpreValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.\targs => buffer, pos, char, isSelection, opts, maskset, caretPos => return true/false/command object\r\n\t\tpostValidation: null, //hook to postValidate the result from isValid.\tUsefull for validating the entry as a whole.\targs => buffer, pos, currentResult, opts => return true/false/json\r\n\t\tstaticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators\r\n\t\tjitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false\r\n\t\tnullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.\r\n\t\tinputEventOnly: false, //dev option - testing inputfallback behavior\r\n\t\tnoValuePatching: false, //disable value property patching\r\n\t\tpositionCaretOnClick: \"lvp\", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)\r\n\t\tcasing: null, //mask-level casing. Options: null, \"upper\", \"lower\" or \"title\" or callback args => elem, test, pos, validPositions return charValue\r\n\t\tinputmode: \"verbatim\", //specify the inputmode  - already in place for when browsers will support it\r\n\t\timportDataAttributes: true, //import data-inputmask attributes\r\n\t\tshiftPositions: true //shift position of the mask entries on entry and deletion.\r\n\t},\r\n\tdefinitions: {\r\n\t\t\"9\": { //\\uFF11-\\uFF19 #1606\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"a\": { //\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5 #76\r\n\t\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"*\": {\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\"\r\n\t\t}\r\n\t},\r\n\taliases: {}, //aliases definitions\r\n\tmasksCache: {},\r\n\tmask: function (elems) {\r\n\t\tvar that = this;\r\n\t\tif (typeof elems === \"string\") {\r\n\t\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t\t}\r\n\t\telems = elems.nodeName ? [elems] : elems;\r\n\t\t$.each(elems, function (ndx, el) {\r\n\t\t\tvar scopedOpts = $.extend(true, {}, that.opts);\r\n\t\t\tif (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\r\n\t\t\t\tvar maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n\t\t\t\tif (maskset !== undefined) {\r\n\t\t\t\t\tif (el.inputmask !== undefined) {\r\n\t\t\t\t\t\tel.inputmask.opts.autoUnmask = true; //force autounmasking when remasking\r\n\t\t\t\t\t\tel.inputmask.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//store inputmask instance on the input with element reference\r\n\t\t\t\t\tel.inputmask = new Inputmask(undefined, undefined, true);\r\n\t\t\t\t\tel.inputmask.opts = scopedOpts;\r\n\t\t\t\t\tel.inputmask.noMasksCache = that.noMasksCache;\r\n\t\t\t\t\tel.inputmask.userOptions = $.extend(true, {}, that.userOptions);\r\n\t\t\t\t\tel.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\r\n\t\t\t\t\tel.inputmask.el = el;\r\n\t\t\t\t\tel.inputmask.maskset = maskset;\r\n\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", scopedOpts);\r\n\r\n\t\t\t\t\tmaskScope.call(el.inputmask, {\r\n\t\t\t\t\t\t\"action\": \"mask\"\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn elems && elems[0] ? (elems[0].inputmask || this) : this;\r\n\t},\r\n\toption: function (options, noremask) { //set extra options || retrieve value of a current option\r\n\t\tif (typeof options === \"string\") {\r\n\t\t\treturn this.opts[options];\r\n\t\t} else if (typeof options === \"object\") {\r\n\t\t\t$.extend(this.userOptions, options); //user passed options\r\n\t\t\t//remask\r\n\t\t\tif (this.el && noremask !== true) {\r\n\t\t\t\tthis.mask(this.el);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t},\r\n\tunmaskedvalue: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"unmaskedvalue\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tremove: function () {\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"remove\"\r\n\t\t});\r\n\t},\r\n\tgetemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getemptymask\"\r\n\t\t});\r\n\t},\r\n\thasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\treturn !this.opts.autoUnmask;\r\n\t},\r\n\tisComplete: function () {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isComplete\"\r\n\t\t});\r\n\t},\r\n\tgetmetadata: function () { //return mask metadata if exists\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getmetadata\"\r\n\t\t});\r\n\t},\r\n\tisValid: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isValid\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tformat: function (value, metadata) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"format\",\r\n\t\t\t\"value\": value,\r\n\t\t\t\"metadata\": metadata //true/false getmetadata\r\n\t\t});\r\n\t},\r\n\tsetValue: function (value) {\r\n\t\tif (this.el) {\r\n\t\t\t$(this.el).trigger(\"setvalue\", [value]);\r\n\t\t}\r\n\t},\r\n\tanalyseMask: analyseMask\r\n};\r\n\r\nfunction resolveAlias(aliasStr, options, opts) {\r\n\tvar aliasDefinition = Inputmask.prototype.aliases[aliasStr];\r\n\tif (aliasDefinition) {\r\n\t\tif (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\r\n\t\t$.extend(true, opts, aliasDefinition); //merge alias definition in the options\r\n\t\t$.extend(true, opts, options); //reapply extra given options\r\n\t\treturn true;\r\n\t} else //alias not found - try as mask\r\n\tif (opts.mask === null) {\r\n\t\topts.mask = aliasStr;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfunction importAttributeOptions(npt, opts, userOptions, dataAttribute) {\r\n\tfunction importOption(option, optionData) {\r\n\t\toptionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\r\n\t\tif (optionData !== null) {\r\n\t\t\tif (typeof optionData === \"string\") {\r\n\t\t\t\tif (option.indexOf(\"on\") === 0) {\r\n\t\t\t\t\toptionData = window[optionData];\r\n\t\t\t\t}//get function definition\r\n\t\t\t\telse if (optionData === \"false\") {\r\n\t\t\t\t\toptionData = false;\r\n\t\t\t\t} else if (optionData === \"true\") optionData = true;\r\n\t\t\t}\r\n\t\t\tuserOptions[option] = optionData;\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.importDataAttributes === true) {\r\n\t\tvar attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\r\n\r\n\t\tif (attrOptions && attrOptions !== \"\") {\r\n\t\t\tattrOptions = attrOptions.replace(/'/g, \"\\\"\");\r\n\t\t\tdataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\r\n\t\t}\r\n\r\n\t\t//resolve aliases\r\n\t\tif (dataoptions) { //pickup alias from dataAttribute\r\n\t\t\toptionData = undefined;\r\n\t\t\tfor (p in dataoptions) {\r\n\t\t\t\tif (p.toLowerCase() === \"alias\") {\r\n\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\timportOption(\"alias\", optionData); //pickup alias from dataAttribute-alias\r\n\t\tif (userOptions.alias) {\r\n\t\t\tresolveAlias(userOptions.alias, userOptions, opts);\r\n\t\t}\r\n\r\n\t\tfor (option in opts) {\r\n\t\t\tif (dataoptions) {\r\n\t\t\t\toptionData = undefined;\r\n\t\t\t\tfor (p in dataoptions) {\r\n\t\t\t\t\tif (p.toLowerCase() === option.toLowerCase()) {\r\n\t\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\timportOption(option, optionData);\r\n\t\t}\r\n\t}\r\n\t$.extend(true, opts, userOptions);\r\n\r\n\t//handle dir=rtl\r\n\tif (npt.dir === \"rtl\" || opts.rightAlign) {\r\n\t\tnpt.style.textAlign = \"right\";\r\n\t}\r\n\r\n\tif (npt.dir === \"rtl\" || opts.numericInput) {\r\n\t\tnpt.dir = \"ltr\";\r\n\t\tnpt.removeAttribute(\"dir\");\r\n\t\topts.isRTL = true;\r\n\t}\r\n\r\n\treturn Object.keys(userOptions).length;\r\n}\r\n\r\n//apply defaults, definitions, aliases\r\nInputmask.extendDefaults = function (options) {\r\n\t$.extend(true, Inputmask.prototype.defaults, options);\r\n};\r\nInputmask.extendDefinitions = function (definition) {\r\n\t$.extend(true, Inputmask.prototype.definitions, definition);\r\n};\r\nInputmask.extendAliases = function (alias) {\r\n\t$.extend(true, Inputmask.prototype.aliases, alias);\r\n};\r\n//static fn on inputmask\r\nInputmask.format = function (value, options, metadata) {\r\n\treturn Inputmask(options).format(value, metadata);\r\n};\r\nInputmask.unmask = function (value, options) {\r\n\treturn Inputmask(options).unmaskedvalue(value);\r\n};\r\nInputmask.isValid = function (value, options) {\r\n\treturn Inputmask(options).isValid(value);\r\n};\r\nInputmask.remove = function (elems) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.remove();\r\n\t});\r\n};\r\nInputmask.setValue = function (elems, value) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [value]);\r\n\t});\r\n};\r\nInputmask.escapeRegex = function (str) {\r\n\tvar specials = [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"];\r\n\treturn str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n};\r\nInputmask.keyCode = {\r\n\tBACKSPACE: 8,\r\n\tBACKSPACE_SAFARI: 127,\r\n\tDELETE: 46,\r\n\tDOWN: 40,\r\n\tEND: 35,\r\n\tENTER: 13,\r\n\tESCAPE: 27,\r\n\tHOME: 36,\r\n\tINSERT: 45,\r\n\tLEFT: 37,\r\n\tPAGE_DOWN: 34,\r\n\tPAGE_UP: 33,\r\n\tRIGHT: 39,\r\n\tSPACE: 32,\r\n\tTAB: 9,\r\n\tUP: 38,\r\n\tX: 88,\r\n\tCONTROL: 17\r\n};\r\nInputmask.dependencyLib = $;\r\n\r\n//make inputmask available\r\nwindow.Inputmask = Inputmask;\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin dependencyLib\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\n\r\nvar jquery = require(\"jquery\");\r\nif(jquery === undefined) {\r\n\tthrow \"jQuery not loaded!\";\r\n}\r\nmodule.exports = jquery;","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","if (typeof define === \"function\" && define.amd)\r\n\tdefine(function () {\r\n\t\treturn typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\t});\r\nelse if (typeof exports === \"object\")\r\n\tmodule.exports = typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\r\n","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\");\r\n\r\nfunction generateMaskSet(opts, nocache) {\r\n\tvar ms;\r\n\r\n\tfunction generateMask(mask, metadata, opts) {\r\n\t\tvar regexMask = false;\r\n\t\tif (mask === null || mask === \"\") {\r\n\t\t\tregexMask = opts.regex !== null;\r\n\t\t\tif (regexMask) {\r\n\t\t\t\tmask = opts.regex;\r\n\t\t\t\tmask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\");\r\n\t\t\t} else {\r\n\t\t\t\tregexMask = true;\r\n\t\t\t\tmask = \".*\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\r\n\t\t\topts.placeholder = \"\";\r\n\t\t} //hide placeholder with single non-greedy mask\r\n\t\tif (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\r\n\t\t\tvar repeatStart = opts.repeat === \"*\" ? 0 : (opts.repeat === \"+\" ? 1 : opts.repeat);\r\n\t\t\tmask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\r\n\t\t}\r\n\r\n\t\t// console.log(mask);\r\n\t\tvar masksetDefinition, maskdefKey;\r\n\t\tmaskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\r\n\t\tif (opts.keepStatic !== false) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache\r\n\t\t\tmaskdefKey = \"ks_\" + maskdefKey;\r\n\t\t}\r\n\r\n\t\tif (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\r\n\t\t\tmasksetDefinition = {\r\n\t\t\t\t\"mask\": mask,\r\n\t\t\t\t\"maskToken\": Inputmask.prototype.analyseMask(mask, regexMask, opts),\r\n\t\t\t\t\"validPositions\": {},\r\n\t\t\t\t\"_buffer\": undefined,\r\n\t\t\t\t\"buffer\": undefined,\r\n\t\t\t\t\"tests\": {},\r\n\t\t\t\t\"excludes\": {}, //excluded alternations\r\n\t\t\t\t\"metadata\": metadata,\r\n\t\t\t\t\"maskLength\": undefined,\r\n\t\t\t\t\"jitOffset\": {}\r\n\t\t\t};\r\n\t\t\tif (nocache !== true) {\r\n\t\t\t\tInputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\r\n\t\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t}\r\n\r\n\t\treturn masksetDefinition;\r\n\t}\r\n\r\n\tif ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\r\n\t\topts.mask = opts.mask(opts);\r\n\t}\r\n\tif ($.isArray(opts.mask)) {\r\n\t\tif (opts.mask.length > 1) {\r\n\t\t\tif (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified\r\n\t\t\t\topts.keepStatic = \"auto\";\r\n\t\t\t\tfor (var i = 0; i < opts.mask.length; i++) {\r\n\t\t\t\t\tif (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\r\n\t\t\t\t\t\topts.keepStatic = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar altMask = opts.groupmarker[0];\r\n\t\t\t$.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\r\n\t\t\t\tif (altMask.length > 1) {\r\n\t\t\t\t\taltMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (msk.mask !== undefined && !$.isFunction(msk.mask)) {\r\n\t\t\t\t\taltMask += msk.mask;\r\n\t\t\t\t} else {\r\n\t\t\t\t\taltMask += msk;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\taltMask += opts.groupmarker[1];\r\n\t\t\t// console.log(altMask);\r\n\t\t\treturn generateMask(altMask, opts.mask, opts);\r\n\t\t} else {\r\n\t\t\topts.mask = opts.mask.pop();\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.keepStatic === null) opts.keepStatic = false;\r\n\tif (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\r\n\t\tms = generateMask(opts.mask.mask, opts.mask, opts);\r\n\t} else {\r\n\t\tms = generateMask(opts.mask, opts.mask, opts);\r\n\t}\r\n\r\n\treturn ms;\r\n}\r\n\r\nfunction analyseMask(mask, regexMask, opts) {\r\n\tvar tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\r\n\t\t//Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex\r\n\t\tregexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\r\n\t\tescaped = false,\r\n\t\tcurrentToken = new MaskToken(),\r\n\t\tmatch,\r\n\t\tm,\r\n\t\topenenings = [],\r\n\t\tmaskTokens = [],\r\n\t\topeningToken,\r\n\t\tcurrentOpeningToken,\r\n\t\talternator,\r\n\t\tlastMatch,\r\n\t\tcloseRegexGroup = false;\r\n\r\n\tfunction MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n\t\tthis.matches = [];\r\n\t\tthis.openGroup = isGroup || false;\r\n\t\tthis.alternatorGroup = false;\r\n\t\tthis.isGroup = isGroup || false;\r\n\t\tthis.isOptional = isOptional || false;\r\n\t\tthis.isQuantifier = isQuantifier || false;\r\n\t\tthis.isAlternator = isAlternator || false;\r\n\t\tthis.quantifier = {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 1\r\n\t\t};\r\n\t}\r\n\r\n\t//test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}\r\n\tfunction insertTestDefinition(mtoken, element, position) {\r\n\t\tposition = position !== undefined ? position : mtoken.matches.length;\r\n\t\tvar prevMatch = mtoken.matches[position - 1];\r\n\t\tif (regexMask) {\r\n\t\t\tif (element.indexOf(\"[\") === 0 || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || element === \".\") {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: new RegExp(element, opts.casing ? \"i\" : \"\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: element,\r\n\t\t\t\t\tplaceholder: undefined,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (escaped) element = element[element.length - 1];\r\n\t\t\t\t$.each(element.split(\"\"), function (ndx, lmnt) {\r\n\t\t\t\t\tprevMatch = mtoken.matches[position - 1];\r\n\t\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\t\tstatic: true,\r\n\t\t\t\t\t\toptionality: false,\r\n\t\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== lmnt && prevMatch.static !== true),\r\n\t\t\t\t\t\tcasing: null,\r\n\t\t\t\t\t\tdef: opts.staticDefinitionSymbol || lmnt,\r\n\t\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\r\n\t\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + lmnt\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tescaped = false;\r\n\t\t} else {\r\n\t\t\tvar maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\r\n\t\t\tif (maskdef && !escaped) {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\r\n\t\t\t\t\t\tthis.test = maskdef.validator;\r\n\t\t\t\t\t} : new RegExp(\".\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\r\n\t\t\t\t\tcasing: maskdef.casing,\r\n\t\t\t\t\tdef: maskdef.definitionSymbol || element,\r\n\t\t\t\t\tplaceholder: maskdef.placeholder,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== element && prevMatch.static !== true),\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: opts.staticDefinitionSymbol || element,\r\n\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\r\n\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + element\r\n\t\t\t\t});\r\n\t\t\t\tescaped = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction verifyGroupMarker(maskToken) {\r\n\t\tif (maskToken && maskToken.matches) {\r\n\t\t\t$.each(maskToken.matches, function (ndx, token) {\r\n\t\t\t\tvar nextToken = maskToken.matches[ndx + 1];\r\n\t\t\t\tif ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert\r\n\t\t\t\t\ttoken.isGroup = false;\r\n\t\t\t\t\tif (!regexMask) {\r\n\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[0], 0);\r\n\t\t\t\t\t\tif (token.openGroup !== true) {\r\n\t\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tverifyGroupMarker(token);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultCase() {\r\n\t\tif (openenings.length > 0) {\r\n\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\tinsertTestDefinition(currentOpeningToken, m);\r\n\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator a | b case\r\n\t\t\t\talternator = openenings.pop();\r\n\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\tif (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t}\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinsertTestDefinition(currentToken, m);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reverseTokens(maskToken) {\r\n\t\tfunction reverseStatic(st) {\r\n\t\t\tif (st === opts.optionalmarker[0]) {\r\n\t\t\t\tst = opts.optionalmarker[1];\r\n\t\t\t} else if (st === opts.optionalmarker[1]) {\r\n\t\t\t\tst = opts.optionalmarker[0];\r\n\t\t\t} else if (st === opts.groupmarker[0]) {\r\n\t\t\t\tst = opts.groupmarker[1];\r\n\t\t\t} else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\r\n\r\n\t\t\treturn st;\r\n\t\t}\r\n\r\n\t\tmaskToken.matches = maskToken.matches.reverse();\r\n\t\tfor (var match in maskToken.matches) {\r\n\t\t\tif (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {\r\n\t\t\t\tvar intMatch = parseInt(match);\r\n\t\t\t\tif (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier\r\n\t\t\t\t\tvar qt = maskToken.matches[match];\r\n\t\t\t\t\tmaskToken.matches.splice(match, 1);\r\n\t\t\t\t\tmaskToken.matches.splice(intMatch + 1, 0, qt);\r\n\t\t\t\t}\r\n\t\t\t\tif (maskToken.matches[match].matches !== undefined) {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseTokens(maskToken.matches[match]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseStatic(maskToken.matches[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maskToken;\r\n\t}\r\n\r\n\tfunction groupify(matches) {\r\n\t\tvar groupToken = new MaskToken(true);\r\n\t\tgroupToken.openGroup = false;\r\n\t\tgroupToken.matches = matches;\r\n\t\treturn groupToken;\r\n\t}\r\n\r\n\tfunction closeGroup() {\r\n\t\t// Group closing\r\n\t\topeningToken = openenings.pop();\r\n\t\topeningToken.openGroup = false; //mark group as complete\r\n\t\tif (openingToken !== undefined) {\r\n\t\t\tif (openenings.length > 0) {\r\n\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\tcurrentOpeningToken.matches.push(openingToken);\r\n\t\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case\r\n\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\t\talternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t\t\talternator.matches[mndx].alternatorGroup = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentToken.matches.push(openingToken);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction groupQuantifier(matches) {\r\n\t\tvar lastMatch = matches.pop();\r\n\t\tif (lastMatch.isQuantifier) {\r\n\t\t\tlastMatch = groupify([matches.pop(), lastMatch]);\r\n\t\t}\r\n\t\treturn lastMatch;\r\n\t}\r\n\r\n\tif (regexMask) {\r\n\t\topts.optionalmarker[0] = undefined;\r\n\t\topts.optionalmarker[1] = undefined;\r\n\t}\r\n\twhile ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {\r\n\t\tm = match[0];\r\n\r\n\t\tif (regexMask) {\r\n\t\t\tswitch (m.charAt(0)) {\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tcase \"?\":\r\n\t\t\t\t\tm = \"{0,1}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"+\":\r\n\t\t\t\tcase \"*\":\r\n\t\t\t\t\tm = \"{\" + m + \"}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\t\t//regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])\r\n\t\t\t\t\tif (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])\r\n\t\t\t\t\t\tvar altRegexGroup = groupify(currentToken.matches);\r\n\t\t\t\t\t\taltRegexGroup.openGroup = true;\r\n\t\t\t\t\t\topenenings.push(altRegexGroup);\r\n\t\t\t\t\t\tcurrentToken.matches = [];\r\n\t\t\t\t\t\tcloseRegexGroup = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (escaped) {\r\n\t\t\tdefaultCase();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (m.charAt(0)) {\r\n\t\t\tcase \"(?=\": //lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?!\": //negative lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<=\": //lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<!\": //negative lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.escapeChar:\r\n\t\t\t\tescaped = true;\r\n\t\t\t\tif (regexMask) {\r\n\t\t\t\t\tdefaultCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t// optional closing\r\n\t\t\tcase opts.optionalmarker[1]:\r\n\t\t\tcase opts.groupmarker[1]:\r\n\t\t\t\tcloseGroup();\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.optionalmarker[0]:\r\n\t\t\t\t// optional opening\r\n\t\t\t\topenenings.push(new MaskToken(false, true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.groupmarker[0]:\r\n\t\t\t\t// Group opening\r\n\t\t\t\topenenings.push(new MaskToken(true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.quantifiermarker[0]:\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tvar quantifier = new MaskToken(false, false, true);\r\n\r\n\t\t\t\tm = m.replace(/[{}]/g, \"\");\r\n\t\t\t\tvar mqj = m.split(\"|\"),\r\n\t\t\t\t\tmq = mqj[0].split(\",\"),\r\n\t\t\t\t\tmq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\r\n\t\t\t\t\tmq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\r\n\t\t\t\tif (mq0 === \"*\" || mq0 === \"+\") {\r\n\t\t\t\t\tmq0 = mq1 === \"*\" ? 0 : 1;\r\n\t\t\t\t}\r\n\t\t\t\tquantifier.quantifier = {\r\n\t\t\t\t\tmin: mq0,\r\n\t\t\t\t\tmax: mq1,\r\n\t\t\t\t\tjit: mqj[1]\r\n\t\t\t\t};\r\n\t\t\t\tvar matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\r\n\t\t\t\tmatch = matches.pop();\r\n\t\t\t\tif (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}\r\n\t\t\t\t\tmatches.push(match); //push back alternator\r\n\t\t\t\t\tmatches = match.matches; //remap target matches\r\n\t\t\t\t\tvar groupToken = new MaskToken(true);\r\n\t\t\t\t\tvar tmpMatch = matches.pop();\r\n\t\t\t\t\tmatches.push(groupToken); //push the group\r\n\t\t\t\t\tmatches = groupToken.matches;\r\n\t\t\t\t\tmatch = tmpMatch;\r\n\t\t\t\t}\r\n\t\t\t\tif (!match.isGroup) {\r\n\t\t\t\t\t// if (regexMask && match.fn === null) { //why is this needed???\r\n\t\t\t\t\t//     if (match.def === \".\") match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\");\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tmatch = groupify([match]);\r\n\t\t\t\t}\r\n\t\t\t\tmatches.push(match);\r\n\t\t\t\tmatches.push(quantifier);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.alternatormarker:\r\n\r\n\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tvar subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\r\n\t\t\t\t\tif (currentOpeningToken.openGroup && //regexp alt syntax\r\n\t\t\t\t\t\t(subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group\r\n\t\t\t\t\t\tlastMatch = openenings.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastMatch = groupQuantifier(currentOpeningToken.matches);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = groupQuantifier(currentToken.matches);\r\n\t\t\t\t}\r\n\t\t\t\tif (lastMatch.isAlternator) {\r\n\t\t\t\t\topenenings.push(lastMatch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.alternatorGroup) {\r\n\t\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\t\tlastMatch.alternatorGroup = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\talternator = new MaskToken(false, false, false, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\talternator.matches.push(lastMatch);\r\n\t\t\t\t\topenenings.push(alternator);\r\n\t\t\t\t\tif (lastMatch.openGroup) { //regexp alt syntax\r\n\t\t\t\t\t\tlastMatch.openGroup = false;\r\n\t\t\t\t\t\tvar alternatorGroup = new MaskToken(true);\r\n\t\t\t\t\t\talternatorGroup.alternatorGroup = true;\r\n\t\t\t\t\t\topenenings.push(alternatorGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tif (closeRegexGroup) closeGroup();\r\n\r\n\twhile (openenings.length > 0) {\r\n\t\topeningToken = openenings.pop();\r\n\t\tcurrentToken.matches.push(openingToken);\r\n\t}\r\n\tif (currentToken.matches.length > 0) {\r\n\t\tverifyGroupMarker(currentToken);\r\n\t\tmaskTokens.push(currentToken);\r\n\t}\r\n\r\n\tif (opts.numericInput || opts.isRTL) {\r\n\t\treverseTokens(maskTokens[0]);\r\n\t}\r\n\t// console.log(JSON.stringify(maskTokens));\r\n\treturn maskTokens;\r\n}\r\n\r\nmodule.exports = {\r\n\tgenerateMaskSet: generateMaskSet,\r\n\tanalyseMask: analyseMask\r\n};","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tua = (window.navigator && window.navigator.userAgent) || \"\",\r\n\tie = (ua.indexOf(\"MSIE \") > 0) || (ua.indexOf(\"Trident/\") > 0),\r\n\tmobile = \"ontouchstart\" in window, //not entirely correct but will currently do\r\n\tiemobile = /iemobile/i.test(ua),\r\n\tiphone = /iphone/i.test(ua) && !iemobile;\r\n\r\n//masking scope\r\n//actionObj definition see below\r\nmodule.exports = function maskScope(actionObj, maskset, opts) {\r\n\tmaskset = maskset || this.maskset;\r\n\topts = opts || this.opts;\r\n\r\n\tvar inputmask = this,\r\n\t\tel = this.el,\r\n\t\tisRTL = this.isRTL || (this.isRTL = opts.numericInput),\r\n\t\tundoValue,\r\n\t\t$el,\r\n\t\tskipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\tskipInputEvent = false, //skip when triggered from within inputmask\r\n\t\tvalidationEvent = false,\r\n\t\tignorable = false,\r\n\t\tmaxLength,\r\n\t\tmouseEnter = false,\r\n\t\toriginalPlaceholder = undefined; //needed for FF\r\n\r\n\t//maskset helperfunctions\r\n\tfunction getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\r\n\t\t//includeMode true => input, undefined => placeholder, false => mask\r\n\r\n\t\tvar greedy = opts.greedy;\r\n\t\tif (clearOptionalTail) opts.greedy = false;\r\n\t\tminimalPos = minimalPos || 0;\r\n\t\tvar maskTemplate = [],\r\n\t\t\tndxIntlzr, pos = 0,\r\n\t\t\ttest, testPos;\r\n\t\tdo {\r\n\t\t\tif (baseOnInput === true && maskset.validPositions[pos]) {\r\n\t\t\t\ttestPos = (clearOptionalTail && maskset.validPositions[pos].match.optionality === true\r\n\t\t\t\t\t&& maskset.validPositions[pos + 1] === undefined\r\n\t\t\t\t\t&& (maskset.validPositions[pos].generatedInput === true || (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))\r\n\t\t\t\t\t? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\r\n\t\t\t\t\t: maskset.validPositions[pos];\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tmaskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t} else {\r\n\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tvar jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);\r\n\t\t\t\tif (jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos)) {\r\n\t\t\t\t\tmaskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.keepStatic === \"auto\") {\r\n\t\t\t\tif (test.newBlockMarker && test.static !== true) {\r\n\t\t\t\t\topts.keepStatic = pos - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpos++;\r\n\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || minimalPos > pos);\r\n\t\tif (maskTemplate[maskTemplate.length - 1] === \"\") {\r\n\t\t\tmaskTemplate.pop(); //drop the last one which is empty\r\n\t\t}\r\n\t\tif (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition\r\n\t\t\tmaskset.maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)\r\n\t\t{\r\n\t\t\tmaskset.maskLength = pos - 1;\r\n\t\t}\r\n\r\n\t\topts.greedy = greedy;\r\n\t\treturn maskTemplate;\r\n\t}\r\n\r\n\tfunction resetMaskSet(soft) {\r\n\t\tmaskset.buffer = undefined;\r\n\t\tif (soft !== true) {\r\n\t\t\tmaskset.validPositions = {};\r\n\t\t\tmaskset.p = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getLastValidPosition(closestTo, strict, validPositions) {\r\n\t\tvar before = -1,\r\n\t\t\tafter = -1,\r\n\t\t\tvalids = validPositions || maskset.validPositions; //for use in valhook ~ context switch\r\n\t\tif (closestTo === undefined) closestTo = -1;\r\n\t\tfor (var posNdx in valids) {\r\n\t\t\tvar psNdx = parseInt(posNdx);\r\n\t\t\tif (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\r\n\t\t\t\tif (psNdx <= closestTo) before = psNdx;\r\n\t\t\t\tif (psNdx >= closestTo) after = psNdx;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;\r\n\t}\r\n\r\n\tfunction getDecisionTaker(tst) {\r\n\t\tvar decisionTaker = tst.locator[tst.alternation];\r\n\t\tif (typeof decisionTaker == \"string\" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider\r\n\t\t\tdecisionTaker = decisionTaker.split(\",\")[0];\r\n\t\t}\r\n\t\treturn decisionTaker !== undefined ? decisionTaker.toString() : \"\";\r\n\t}\r\n\r\n\tfunction getLocator(tst, align) { //need to align the locators to be correct\r\n\t\tvar locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\r\n\t\tif (locator !== \"\") while (locator.length < align) locator += \"0\";\r\n\t\treturn locator;\r\n\t}\r\n\r\n\tfunction determineTestTemplate(pos, tests) {\r\n\t\tpos = pos > 0 ? pos - 1 : 0;\r\n\t\tvar altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\r\n\t\tfor (var ndx = 0; ndx < tests.length; ndx++) { //find best matching\r\n\t\t\tvar tst = tests[ndx];\r\n\t\t\ttstLocator = getLocator(tst, targetLocator.length);\r\n\t\t\tvar distance = Math.abs(tstLocator - targetLocator);\r\n\t\t\tif (closest === undefined\r\n\t\t\t\t|| (tstLocator !== \"\" && distance < closest)\r\n\t\t\t\t|| (bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker))\r\n\t\t\t\t|| (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {\r\n\t\t\t\tclosest = distance;\r\n\t\t\t\tbestMatch = tst;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bestMatch;\r\n\t}\r\n\r\n\r\n\tfunction getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n\t\treturn maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n\t}\r\n\r\n\tfunction getTest(pos, tests) {\r\n\t\tif (maskset.validPositions[pos]) {\r\n\t\t\treturn maskset.validPositions[pos];\r\n\t\t}\r\n\t\treturn (tests || getTests(pos))[0];\r\n\t}\r\n\r\n\tfunction positionCanMatchDefinition(pos, testDefinition, opts) {\r\n\t\tvar valid = false,\r\n\t\t\ttests = getTests(pos),\r\n\t\t\tdefProp = opts.shiftPositions ? \"def\" : \"nativeDef\";\r\n\t\tfor (var tndx = 0; tndx < tests.length; tndx++) {\r\n\t\t\tif (tests[tndx].match && tests[tndx].match[defProp] === testDefinition.match[defProp]) {\r\n\t\t\t\tvalid = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (valid === false) {\r\n\t\t\tif (maskset.jitOffset[pos] !== undefined) {\r\n\t\t\t\tvalid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn valid;\r\n\t}\r\n\r\n\r\n\tfunction getTests(pos, ndxIntlzr, tstPs) {\r\n\t\tvar maskTokens = maskset.maskToken,\r\n\t\t\ttestPos = ndxIntlzr ? tstPs : 0,\r\n\t\t\tndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\r\n\t\t\tmatches = [],\r\n\t\t\tinsertStop = false,\r\n\t\t\tlatestMatch,\r\n\t\t\tcacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n\r\n\t\tfunction resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens\r\n\t\t\tfunction handleMatch(match, loopNdx, quantifierRecurse) {\r\n\t\t\t\tfunction isFirstMatch(latestMatch, tokenGroup) {\r\n\t\t\t\t\tvar firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\r\n\t\t\t\t\tif (!firstMatch) {\r\n\t\t\t\t\t\t$.each(tokenGroup.matches, function (ndx, match) {\r\n\t\t\t\t\t\t\tif (match.isQuantifier === true) {\r\n\t\t\t\t\t\t\t\tfirstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);\r\n\t\t\t\t\t\t\t} else if (Object.prototype.hasOwnProperty.call(match, \"matches\")) firstMatch = isFirstMatch(latestMatch, match);\r\n\t\t\t\t\t\t\tif (firstMatch) return false;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn firstMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\r\n\t\t\t\t\tvar bestMatch, indexPos;\r\n\r\n\t\t\t\t\tif (maskset.tests[pos] || maskset.validPositions[pos]) {\r\n\t\t\t\t\t\t$.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {\r\n\t\t\t\t\t\t\tif (lmnt.mloc[alternateNdx]) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\treturn false; //break\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,\r\n\t\t\t\t\t\t\t\tndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\r\n\t\t\t\t\t\t\tif ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\tindexPos = ndxPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (bestMatch) {\r\n\t\t\t\t\t\tvar bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\r\n\t\t\t\t\t\tvar locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\r\n\t\t\t\t\t\treturn locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSubsetOf(source, target) {\r\n\t\t\t\t\tfunction expand(pattern) {\r\n\t\t\t\t\t\tvar expanded = [], start = -1, end;\r\n\t\t\t\t\t\tfor (var i = 0, l = pattern.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (pattern.charAt(i) === \"-\") {\r\n\t\t\t\t\t\t\t\tend = pattern.charCodeAt(i + 1);\r\n\t\t\t\t\t\t\t\twhile (++start < end) expanded.push(String.fromCharCode(start));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstart = pattern.charCodeAt(i);\r\n\t\t\t\t\t\t\t\texpanded.push(pattern.charAt(i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn expanded.join(\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (source.match.def === target.match.nativeDef) return true;\r\n\t\t\t\t\tif ((opts.regex || (source.match.fn instanceof RegExp && target.match.fn instanceof RegExp)) && source.match.static !== true && target.match.static !== true) { //is regex a subset\r\n\t\t\t\t\t\treturn expand(target.match.fn.toString().replace(/[[\\]/]/g, \"\")).indexOf(expand(source.match.fn.toString().replace(/[[\\]/]/g, \"\"))) !== -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction staticCanMatchDefinition(source, target) {\r\n\t\t\t\t\treturn source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, maskset, pos, false, opts, false) : false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//mergelocators for retrieving the correct locator match when merging\r\n\t\t\t\tfunction setMergeLocators(targetMatch, altMatch) {\r\n\t\t\t\t\tif (altMatch === undefined || (targetMatch.alternation === altMatch.alternation &&\r\n\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1)) {\r\n\t\t\t\t\t\ttargetMatch.mloc = targetMatch.mloc || {};\r\n\t\t\t\t\t\tvar locNdx = targetMatch.locator[targetMatch.alternation];\r\n\t\t\t\t\t\tif (locNdx === undefined) {\r\n\t\t\t\t\t\t\ttargetMatch.alternation = undefined;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\r\n\t\t\t\t\t\t\tif (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\r\n\t\t\t\t\t\t\tif (altMatch !== undefined) {\r\n\t\t\t\t\t\t\t\tfor (var ndx in altMatch.mloc) {\r\n\t\t\t\t\t\t\t\t\tif (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\r\n\t\t\t\t\t\t\t\t\tif (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (testPos > 500 && quantifierRecurse !== undefined) {\r\n\t\t\t\t\tthrow \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask;\r\n\t\t\t\t}\r\n\t\t\t\tif (testPos === pos && match.matches === undefined) {\r\n\t\t\t\t\tmatches.push({\r\n\t\t\t\t\t\t\"match\": match,\r\n\t\t\t\t\t\t\"locator\": loopNdx.reverse(),\r\n\t\t\t\t\t\t\"cd\": cacheDependency,\r\n\t\t\t\t\t\t\"mloc\": {}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (match.matches !== undefined) {\r\n\t\t\t\t\tif (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier\r\n\t\t\t\t\t\tmatch = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isOptional) {\r\n\t\t\t\t\t\tvar optionalToken = match, mtchsNdx = matches.length;\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t//mark optionality in matches\r\n\t\t\t\t\t\t\t$.each(matches, function (ndx, mtch) {\r\n\t\t\t\t\t\t\t\tif (ndx >= mtchsNdx) {\r\n\t\t\t\t\t\t\t\t\tmtch.match.optionality = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\tif (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698\r\n\t\t\t\t\t\t\t\tinsertStop = true; //insert a stop\r\n\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (match.isAlternator) {\r\n\t\t\t\t\t\tvar alternateToken = match,\r\n\t\t\t\t\t\t\tmalternateMatches = [],\r\n\t\t\t\t\t\t\tmaltMatches,\r\n\t\t\t\t\t\t\tcurrentMatches = matches.slice(),\r\n\t\t\t\t\t\t\tloopNdxCnt = loopNdx.length;\r\n\t\t\t\t\t\tvar altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n\t\t\t\t\t\tif (altIndex === -1 || typeof altIndex === \"string\") {\r\n\t\t\t\t\t\t\tvar currentPos = testPos,\r\n\t\t\t\t\t\t\t\tndxInitializerClone = ndxInitializer.slice(),\r\n\t\t\t\t\t\t\t\taltIndexArr = [],\r\n\t\t\t\t\t\t\t\tamndx;\r\n\t\t\t\t\t\t\tif (typeof altIndex == \"string\") {\r\n\t\t\t\t\t\t\t\taltIndexArr = altIndex.split(\",\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.push(amndx.toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (maskset.excludes[pos] !== undefined) {\r\n\t\t\t\t\t\t\t\tvar altIndexArrClone = altIndexArr.slice();\r\n\t\t\t\t\t\t\t\tfor (var i = 0, el = maskset.excludes[pos].length; i < el; i++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.splice(altIndexArr.indexOf(maskset.excludes[pos][i].toString()), 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (altIndexArr.length === 0) { //fully alternated => reset\r\n\t\t\t\t\t\t\t\t\tdelete maskset.excludes[pos];\r\n\t\t\t\t\t\t\t\t\taltIndexArr = altIndexArrClone;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);\r\n\t\t\t\t\t\t\tvar unMatchedAlternation = false;\r\n\t\t\t\t\t\t\tfor (var ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n\t\t\t\t\t\t\t\tamndx = parseInt(altIndexArr[ndx]);\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\t\t\t\t\t\t\t\t//set the correct ndxInitializer\r\n\t\t\t\t\t\t\t\tndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\r\n\t\t\t\t\t\t\t\tif (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)) {\r\n\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t} else if (ndx === 0) {\r\n\t\t\t\t\t\t\t\t\tunMatchedAlternation = true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tmaltMatches = matches.slice();\r\n\t\t\t\t\t\t\t\ttestPos = currentPos;\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\r\n\t\t\t\t\t\t\t\t//fuzzy merge matches\r\n\t\t\t\t\t\t\t\tfor (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n\t\t\t\t\t\t\t\t\tvar altMatch = maltMatches[ndx1],\r\n\t\t\t\t\t\t\t\t\t\tdropMatch = false;\r\n\t\t\t\t\t\t\t\t\taltMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: \"(a|aa)\"\r\n\t\t\t\t\t\t\t\t\taltMatch.alternation = altMatch.alternation || loopNdxCnt;\r\n\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch);\r\n\t\t\t\t\t\t\t\t\tfor (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n\t\t\t\t\t\t\t\t\t\tvar altMatch2 = malternateMatches[ndx2];\r\n\t\t\t\t\t\t\t\t\t\tif (typeof altIndex !== \"string\" || (altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch2, altMatch)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (staticCanMatchDefinition(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//insert match above general match\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!dropMatch) {\r\n\t\t\t\t\t\t\t\t\t\tmalternateMatches.push(altMatch);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmatches = currentMatches.concat(malternateMatches);\r\n\t\t\t\t\t\t\ttestPos = pos;\r\n\t\t\t\t\t\t\tinsertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option\r\n\t\t\t\t\t\t\tmatch = malternateMatches.length > 0; //set correct match state\r\n\r\n\t\t\t\t\t\t\t//cloneback\r\n\t\t\t\t\t\t\tndxInitializer = ndxInitializerClone.slice();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmatch = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\r\n\t\t\t\t\t\tvar qt = match;\r\n\t\t\t\t\t\tfor (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\r\n\t\t\t\t\t\t\tvar tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n\t\t\t\t\t\t\tmatch = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker\r\n\t\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t\t//get latest match\r\n\t\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\t\t//mark optionality\r\n\t\t\t\t\t\t\t\t//TODO FIX RECURSIVE QUANTIFIERS\r\n\t\t\t\t\t\t\t\tlatestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\r\n\t\t\t\t\t\t\t\t// console.log(pos + \" \" + qt.quantifier.min + \" \" + latestMatch.optionalQuantifier);\r\n\t\t\t\t\t\t\t\tlatestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\r\n\t\t\t\t\t\t\t\tif (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\r\n\t\t\t\t\t\t\t\t\tinsertStop = true;\r\n\t\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t\t\tbreak; //stop quantifierloop && search for next possible match\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {\r\n\t\t\t\t\t\t\t\t\t//always set jitOffset, isvalid checks when to apply\r\n\t\t\t\t\t\t\t\t\tmaskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttestPos++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//the offset is set in the quantifierloop when git masking is used\r\n\t\t\tfor (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {\r\n\t\t\t\tif (maskToken.matches[tndx].isQuantifier !== true) {\r\n\t\t\t\t\tvar match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\tif (match && testPos === pos) {\r\n\t\t\t\t\t\treturn match;\r\n\t\t\t\t\t} else if (testPos > pos) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction mergeLocators(pos, tests) {\r\n\t\t\tvar locator = [];\r\n\t\t\tif (!$.isArray(tests)) tests = [tests];\r\n\t\t\tif (tests.length > 0) {\r\n\t\t\t\tif (tests[0].alternation === undefined || opts.keepStatic === true) {\r\n\t\t\t\t\tlocator = determineTestTemplate(pos, tests.slice()).locator.slice();\r\n\t\t\t\t\tif (locator.length === 0) locator = tests[0].locator.slice();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.each(tests, function (ndx, tst) {\r\n\t\t\t\t\t\tif (tst.def !== \"\") {\r\n\t\t\t\t\t\t\tif (locator.length === 0) {\r\n\t\t\t\t\t\t\t\tlocator = tst.locator.slice();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (var i = 0; i < locator.length; i++) {\r\n\t\t\t\t\t\t\t\t\tif (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\r\n\t\t\t\t\t\t\t\t\t\tlocator[i] += \",\" + tst.locator[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn locator;\r\n\t\t}\r\n\r\n\t\tif (pos > -1 && (maxLength === undefined || pos < maxLength)) {\r\n\t\t\tif (ndxIntlzr === undefined) { //determine index initializer\r\n\t\t\t\tvar previousPos = pos - 1,\r\n\t\t\t\t\ttest;\r\n\t\t\t\twhile ((test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) === undefined && previousPos > -1) {\r\n\t\t\t\t\tpreviousPos--;\r\n\t\t\t\t}\r\n\t\t\t\tif (test !== undefined && previousPos > -1) {\r\n\t\t\t\t\tndxInitializer = mergeLocators(previousPos, test);\r\n\t\t\t\t\tcacheDependency = ndxInitializer.join(\"\");\r\n\t\t\t\t\ttestPos = previousPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first\r\n\t\t\t\treturn maskset.tests[pos];\r\n\t\t\t}\r\n\t\t\tfor (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n\t\t\t\tvar match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\r\n\t\t\t\tif ((match && testPos === pos) || testPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (matches.length === 0 || insertStop) {\r\n\t\t\tmatches.push({\r\n\t\t\t\tmatch: {\r\n\t\t\t\t\tfn: null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: \"\",\r\n\t\t\t\t\tplaceholder: \"\"\r\n\t\t\t\t},\r\n\t\t\t\tlocator: [],\r\n\t\t\t\tmloc: {},\r\n\t\t\t\tcd: cacheDependency\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (ndxIntlzr !== undefined && maskset.tests[pos]) { //prioritize full tests for caching\r\n\t\t\treturn $.extend(true, [], matches);\r\n\t\t}\r\n\t\tmaskset.tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props\r\n\t\t// console.log(pos + \" - \" + JSON.stringify(matches));\r\n\t\treturn maskset.tests[pos];\r\n\t}\r\n\r\n\tfunction getBufferTemplate() {\r\n\t\tif (maskset._buffer === undefined) {\r\n\t\t\t//generate template\r\n\t\t\tmaskset._buffer = getMaskTemplate(false, 1);\r\n\t\t\tif (maskset.buffer === undefined) maskset.buffer = maskset._buffer.slice();\r\n\t\t}\r\n\t\treturn maskset._buffer;\r\n\t}\r\n\r\n\tfunction getBuffer(noCache) {\r\n\t\tif (maskset.buffer === undefined || noCache === true) {\r\n\t\t\tmaskset.buffer = getMaskTemplate(true, getLastValidPosition(), true);\r\n\t\t\tif (maskset._buffer === undefined) maskset._buffer = maskset.buffer.slice();\r\n\t\t}\r\n\t\treturn maskset.buffer;\r\n\t}\r\n\r\n\tfunction refreshFromBuffer(start, end, buffer) {\r\n\t\tvar i, p, skipOptionalPartCharacter = opts.skipOptionalPartCharacter;\r\n\t\topts.skipOptionalPartCharacter = \"\";\r\n\t\tif (start === true) {\r\n\t\t\tresetMaskSet();\r\n\t\t\tmaskset.tests = {}; //refresh tests after possible alternating\r\n\t\t\tstart = 0;\r\n\t\t\tend = buffer.length;\r\n\t\t} else {\r\n\t\t\tfor (i = start; i < end; i++) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tp = start;\r\n\t\tfor (i = start; i < end; i++) {\r\n\t\t\tvar valResult = isValid(p, buffer[i], opts.negationSymbol ? buffer[i] !== opts.negationSymbol.front : true, opts.negationSymbol ? buffer[i] !== opts.negationSymbol.front : true);  //hackery for + validator (numeric alias)\r\n\t\t\tif (valResult !== false) {\r\n\t\t\t\tp = (valResult.caret !== undefined && valResult.caret > valResult.pos) ? valResult.caret : valResult.pos + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.skipOptionalPartCharacter = skipOptionalPartCharacter;\r\n\t}\r\n\r\n\tfunction casing(elem, test, pos) {\r\n\t\tswitch (opts.casing || test.casing) {\r\n\t\t\tcase \"upper\":\r\n\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"lower\":\r\n\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"title\":\r\n\t\t\t\tvar posBefore = maskset.validPositions[pos - 1];\r\n\t\t\t\tif (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\r\n\t\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tif ($.isFunction(opts.casing)) {\r\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\t\targs.push(maskset.validPositions);\r\n\t\t\t\t\telem = opts.casing.apply(this, args);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tfunction checkAlternationMatch(altArr1, altArr2, na) {\r\n\t\tvar altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\r\n\t\t\tisMatch = false,\r\n\t\t\tnaArr = na !== undefined ? na.split(\",\") : [],\r\n\t\t\tnaNdx;\r\n\r\n\t\t//remove no alternate indexes from alternation array\r\n\t\tfor (var i = 0; i < naArr.length; i++) {\r\n\t\t\tif ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\r\n\t\t\t\taltArr1.splice(naNdx, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var alndx = 0; alndx < altArr1.length; alndx++) {\r\n\t\t\tif ($.inArray(altArr1[alndx], altArrC) !== -1) {\r\n\t\t\t\tisMatch = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isMatch;\r\n\t}\r\n\r\n\tfunction alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) { //pos == true => generalize\r\n\t\tvar validPsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\ttstClone = $.extend(true, {}, maskset.tests),\r\n\t\t\tlastAlt,\r\n\t\t\talternation,\r\n\t\t\tisValidRslt = false, returnRslt = false,\r\n\t\t\taltPos, prevAltPos, i, validPos,\r\n\t\t\tdecisionPos,\r\n\t\t\tlAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition(), nextPos, input, begin, end;\r\n\r\n\t\tif (selection) {\r\n\t\t\tbegin = selection.begin;\r\n\t\t\tend = selection.end;\r\n\t\t\tif (selection.begin > selection.end) {\r\n\t\t\t\tbegin = selection.end;\r\n\t\t\t\tend = selection.begin;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning\r\n\t\t\tlastAlt = 0;\r\n\t\t\tprevAltPos = getTest(lastAlt);\r\n\t\t\talternation = prevAltPos.alternation;\r\n\t\t} else {\r\n\t\t\t//find last modified alternation\r\n\t\t\tfor (; lAltPos >= 0; lAltPos--) {\r\n\t\t\t\taltPos = maskset.validPositions[lAltPos];\r\n\t\t\t\tif (altPos && altPos.alternation !== undefined) {\r\n\t\t\t\t\tif (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastAlt = lAltPos;\r\n\t\t\t\t\talternation = maskset.validPositions[lastAlt].alternation;\r\n\t\t\t\t\tprevAltPos = altPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (alternation !== undefined) {\r\n\t\t\tdecisionPos = parseInt(lastAlt);\r\n\t\t\tmaskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [];\r\n\t\t\tif (maskPos !== true) { //generalize\r\n\t\t\t\tmaskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos));\r\n\t\t\t}\r\n\r\n\t\t\tvar validInputs = [], resultPos = -1;\r\n\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\r\n\t\t\t\tif (resultPos === -1 && maskPos <= i && c !== undefined) {\r\n\t\t\t\t\tvalidInputs.push(c);\r\n\t\t\t\t\tresultPos = validInputs.length - 1;\r\n\t\t\t\t}\r\n\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\tif (validPos && validPos.generatedInput !== true && (selection === undefined || (i < begin || i >= end))) {\r\n\t\t\t\t\tvalidInputs.push(validPos.input);\r\n\t\t\t\t}\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t\tif (resultPos === -1 && c !== undefined) {\r\n\t\t\t\tvalidInputs.push(c);\r\n\t\t\t\tresultPos = validInputs.length - 1;\r\n\t\t\t}\r\n\r\n\t\t\twhile (maskset.excludes[decisionPos] !== undefined && maskset.excludes[decisionPos].length < 10) {\r\n\t\t\t\tmaskset.tests[decisionPos] = undefined; //clear decisionPos\r\n\t\t\t\tresetMaskSet(true); //clear getbuffer\r\n\t\t\t\tisValidRslt = true;\r\n\t\t\t\tfor (i = 0; i < validInputs.length; i++) {\r\n\t\t\t\t\tnextPos = isValidRslt.caret || (getLastValidPosition(undefined, true) + 1);\r\n\t\t\t\t\tinput = validInputs[i];\r\n\t\t\t\t\tif (!(isValidRslt = isValid(nextPos, input, false, fromIsValid, true))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i === resultPos) {\r\n\t\t\t\t\t\treturnRslt = isValidRslt;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!isValidRslt) {\r\n\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\tprevAltPos = getTest(decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation\r\n\t\t\t\t\t//reset & revert\r\n\t\t\t\t\tmaskset.validPositions = $.extend(true, {}, validPsClone);\r\n\t\t\t\t\tmaskset.tests = $.extend(true, {}, tstClone); //refresh tests after possible alternating\r\n\t\t\t\t\tif (maskset.excludes[decisionPos]) {\r\n\t\t\t\t\t\tvar decisionTaker = getDecisionTaker(prevAltPos);\r\n\t\t\t\t\t\tif (maskset.excludes[decisionPos].indexOf(decisionTaker) !== -1) {\r\n\t\t\t\t\t\t\treturnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmaskset.excludes[decisionPos].push(decisionTaker);\r\n\t\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete maskset.validPositions[i];\r\n\t\t\t\t\t} else { //latest alternation\r\n\t\t\t\t\t\treturnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//reset alternation excludes\r\n\t\tdelete maskset.excludes[decisionPos];\r\n\t\treturn returnRslt;\r\n\t}\r\n\r\n\tfunction isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill\r\n\t\tfunction isSelection(posObj) {\r\n\t\t\treturn isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :\r\n\t\t\t\t(posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);\r\n\t\t}\r\n\r\n\t\tstrict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions\r\n\r\n\t\tvar maskPos = pos;\r\n\t\tif (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection\r\n\t\t\tmaskPos = isRTL ? pos.end : pos.begin;\r\n\t\t}\r\n\r\n\t\tfunction processCommandObject(commandObj) {\r\n\t\t\tif (commandObj !== undefined) {\r\n\t\t\t\tif (commandObj.remove !== undefined) { //remove position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];\r\n\t\t\t\t\t$.each(commandObj.remove.sort(function (a, b) {\r\n\t\t\t\t\t\treturn b.pos - a.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\trevalidateMask({begin: lmnt, end: lmnt + 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.remove = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (commandObj.insert !== undefined) { //insert position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];\r\n\t\t\t\t\t$.each(commandObj.insert.sort(function (a, b) {\r\n\t\t\t\t\t\treturn a.pos - b.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\tif (lmnt.c !== \"\") {\r\n\t\t\t\t\t\t\tisValid(lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.insert = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.refreshFromBuffer && commandObj.buffer) {\r\n\t\t\t\t\tvar refresh = commandObj.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);\r\n\t\t\t\t\tcommandObj.refreshFromBuffer = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.rewritePosition !== undefined) {\r\n\t\t\t\t\tmaskPos = commandObj.rewritePosition;\r\n\t\t\t\t\t// commandObj.rewritePosition = undefined;\r\n\t\t\t\t\tcommandObj = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn commandObj;\r\n\t\t}\r\n\r\n\t\tfunction _isValid(position, c, strict) {\r\n\t\t\tvar rslt = false;\r\n\r\n\t\t\t$.each(getTests(position), function (ndx, tst) {\r\n\t\t\t\tvar test = tst.match;\r\n\t\t\t\t//make sure the buffer is set and correct\r\n\t\t\t\tgetBuffer(true);\r\n\t\t\t\t//return is false or a json object => { pos: ??, c: ??} or true\r\n\t\t\t\trslt = test.fn != null ?\r\n\t\t\t\t\ttest.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? //non mask\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc: getPlaceholder(position, test, true) || test.def,\r\n\t\t\t\t\t\t\tpos: position\r\n\t\t\t\t\t\t} : false;\r\n\r\n\t\t\t\tif (rslt !== false) {\r\n\t\t\t\t\tvar elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\r\n\t\t\t\t\telem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?\r\n\t\t\t\t\t\t(getPlaceholder(position, test, true) || test.def) : elem;\r\n\r\n\t\t\t\t\trslt = processCommandObject(rslt);\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset\r\n\t\t\t\t\t\tvalidatedPos = rslt.pos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\r\n\t\t\t\t\t\treturn false; //breakout if nothing to insert\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (revalidateMask(pos, $.extend({}, tst, {\r\n\t\t\t\t\t\t\"input\": casing(elem, test, validatedPos)\r\n\t\t\t\t\t}), fromIsValid, validatedPos) === false) {\r\n\t\t\t\t\t\trslt = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false; //break from $.each\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn rslt;\r\n\t\t}\r\n\r\n\t\tvar result = true,\r\n\t\t\tpositionsClone = $.extend(true, {}, maskset.validPositions); //clone the currentPositions\r\n\r\n\t\tif ($.isFunction(opts.preValidation) && !strict && fromIsValid !== true && validateOnly !== true && fromAlternate !== true) {\r\n\t\t\tresult = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, maskset, pos);\r\n\t\t\tresult = processCommandObject(result);\r\n\t\t}\r\n\t\tif (result === true) { //preValidation result\r\n\t\t\tif (maxLength === undefined || maskPos < maxLength) {\r\n\t\t\t\tresult = _isValid(maskPos, c, strict);\r\n\t\t\t\tif ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {\r\n\t\t\t\t\tvar currentPosValid = maskset.validPositions[maskPos];\r\n\t\t\t\t\tif (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\r\n\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\"caret\": seekNext(maskPos)\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.insertMode || maskset.validPositions[seekNext(maskPos)] === undefined || pos.end > maskPos) { //does the input match on a further position?\r\n\t\t\t\t\t\t\tvar skip = false;\r\n\t\t\t\t\t\t\tif (maskset.jitOffset[maskPos] && maskset.validPositions[seekNext(maskPos)] === undefined) {\r\n\t\t\t\t\t\t\t\tresult = isValid(maskPos + maskset.jitOffset[maskPos], c, true);\r\n\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\tif (fromAlternate !== true) result.caret = maskPos;\r\n\t\t\t\t\t\t\t\t\tskip = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (pos.end > maskPos) {\r\n\t\t\t\t\t\t\t\tmaskset.validPositions[maskPos] = undefined;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!skip && !isMask(maskPos, true)) {\r\n\t\t\t\t\t\t\t\tfor (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\r\n\t\t\t\t\t\t\t\t\t// if (!isMask(nPos, true)) {\r\n\t\t\t\t\t\t\t\t\t// \tcontinue;\r\n\t\t\t\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t\t\t\tresult = _isValid(nPos, c, strict);\r\n\t\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\t\tresult = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\r\n\t\t\t\t\t\t\t\t\t\tmaskPos = nPos;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t\tif (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) { //try fuzzy alternator logic\r\n\t\t\t\tresult = alternate(maskPos, c, strict, fromIsValid, undefined, pos);\r\n\t\t\t}\r\n\t\t\tif (result === true) {\r\n\t\t\t\tresult = {\r\n\t\t\t\t\t\"pos\": maskPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($.isFunction(opts.postValidation) && result !== false && !strict && fromIsValid !== true && validateOnly !== true) {\r\n\t\t\tvar postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? (isRTL ? pos.end : pos.begin) : pos, result, opts, maskset);\r\n\t\t\tif (postResult !== undefined) {\r\n\t\t\t\tresult = postResult === true ? result : postResult;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result && result.pos === undefined) {\r\n\t\t\tresult.pos = maskPos;\r\n\t\t}\r\n\r\n\t\tif (result === false || validateOnly === true) {\r\n\t\t\tresetMaskSet(true);\r\n\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone); //revert validation changes\r\n\t\t} else {\r\n\t\t\ttrackbackPositions(undefined, maskPos, true);\r\n\t\t}\r\n\r\n\t\tvar endResult = processCommandObject(result);\r\n\t\t// console.log(\"returned result \" + JSON.stringify(endResult));\r\n\t\treturn endResult;\r\n\t}\r\n\r\n\t//fill in best positions according the current input\r\n\tfunction trackbackPositions(originalPos, newPos, fillOnly) {\r\n\t\t// console.log(\"trackbackPositions \" + originalPos + \" \" + newPos);\r\n\t\tif (originalPos === undefined) {\r\n\t\t\t//find previous valid\r\n\t\t\tfor (originalPos = newPos - 1; originalPos > 0; originalPos--) {\r\n\t\t\t\tif (maskset.validPositions[originalPos]) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var ps = originalPos; ps < newPos; ps++) {\r\n\t\t\tif (maskset.validPositions[ps] === undefined && !isMask(ps, true)) {\r\n\t\t\t\tvar vp = ps == 0 ? getTest(ps) : maskset.validPositions[ps - 1];\r\n\t\t\t\tif (vp) {\r\n\t\t\t\t\tvar tests = getTests(ps).slice();\r\n\t\t\t\t\tif (tests[tests.length - 1].match.def === \"\") tests.pop();\r\n\t\t\t\t\tvar bestMatch = determineTestTemplate(ps, tests), np;\r\n\t\t\t\t\tif (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === \"master\" && (np = maskset.validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {\r\n\t\t\t\t\t\tbestMatch = $.extend({}, bestMatch, {\r\n\t\t\t\t\t\t\t\"input\": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbestMatch.generatedInput = true;\r\n\t\t\t\t\t\trevalidateMask(ps, bestMatch, true);\r\n\r\n\t\t\t\t\t\tif (fillOnly !== true) {\r\n\t\t\t\t\t\t\t//revalidate the new position to update the locator value\r\n\t\t\t\t\t\t\tvar cvpInput = maskset.validPositions[newPos].input;\r\n\t\t\t\t\t\t\tmaskset.validPositions[newPos] = undefined;\r\n\t\t\t\t\t\t\treturn isValid(newPos, cvpInput, true, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction revalidateMask(pos, validTest, fromIsValid, validatedPos) {\r\n\t\tfunction IsEnclosedStatic(pos, valids, selection) {\r\n\t\t\tvar posMatch = valids[pos];\r\n\t\t\tif (posMatch !== undefined && posMatch.match.static === true && posMatch.match.optionality !== true && (valids[0] === undefined || valids[0].alternation === undefined)) {\r\n\t\t\t\tvar prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],\r\n\t\t\t\t\tnextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];\r\n\t\t\t\treturn prevMatch && nextMatch;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar offset = 0, begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\r\n\t\tif (pos.begin > pos.end) {\r\n\t\t\tbegin = pos.end;\r\n\t\t\tend = pos.begin;\r\n\t\t}\r\n\t\tif (validTest === undefined && opts.insertMode === false && end < maskset.maskLength) {\r\n\t\t\tif (begin !== 0 || end !== 0) {\r\n\t\t\t\tbegin += 1;\r\n\t\t\t\tend += 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvalidatedPos = validatedPos !== undefined ? validatedPos : begin;\r\n\t\tif (begin !== end || (opts.insertMode && maskset.validPositions[validatedPos] !== undefined && fromIsValid === undefined) || validTest === undefined) {\r\n\t\t\t//reposition & revalidate others\r\n\t\t\tvar positionsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\t\tlvp = (validTest === undefined && opts.insertMode === false) ? (end > 1 ? end - 1 : end) : getLastValidPosition(undefined, true),\r\n\t\t\t\ti;\r\n\t\t\tmaskset.p = begin; //needed for alternated position after overtype selection\r\n\r\n\t\t\tfor (i = lvp; i >= begin; i--) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t\tif (validTest === undefined) delete maskset.tests[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tvar valid = true, j = validatedPos,\r\n\t\t\t\tposMatch = j, t;\r\n\t\t\ti = j;\r\n\r\n\t\t\tif (validTest) {\r\n\t\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t\t\tposMatch++;\r\n\t\t\t\tj++;\r\n\t\t\t\tif (begin < end) i++; //if selection and entry move start by one\r\n\t\t\t}\r\n\t\t\tif (validTest || opts.insertMode) {\r\n\t\t\t\tfor (; i <= lvp; i++) {\r\n\t\t\t\t\tif ((t = positionsClone[i]) !== undefined && t.generatedInput !== true &&\r\n\t\t\t\t\t\t(i >= end || (i >= begin && IsEnclosedStatic(i, positionsClone, {\r\n\t\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\t\tend: end\r\n\t\t\t\t\t\t})))) {\r\n\t\t\t\t\t\twhile (getTest(posMatch).match.def !== \"\") { //loop needed to match further positions\r\n\t\t\t\t\t\t\tif (positionCanMatchDefinition(posMatch, t, opts) || t.match.def === \"+\") { //validated match //we still need some hackery for the + validator (numeric alias)\r\n\t\t\t\t\t\t\t\tif (t.match.def === \"+\") getBuffer(true);\r\n\t\t\t\t\t\t\t\tvar result = isValid(posMatch, t.input, t.match.def !== \"+\", t.match.def !== \"+\");\r\n\t\t\t\t\t\t\t\tvalid = result !== false;\r\n\t\t\t\t\t\t\t\tj = (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\t\tif (!valid) break;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (valid) {\r\n\t\t\t\t\t\t\t\tif (validTest === undefined && t.match.static && i === pos.begin) offset++;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!valid && posMatch > maskset.maskLength) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tposMatch++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (getTest(posMatch).match.def == \"\") {\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//restore position\r\n\t\t\t\t\t\tposMatch = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!valid) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!valid) {\r\n\t\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone);\r\n\t\t\t\tresetMaskSet(true);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (validTest) {\r\n\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t}\r\n\r\n\t\tresetMaskSet(true);\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tfunction isMask(pos, strict, fuzzy) {\r\n\t\tvar test = getTestTemplate(pos).match;\r\n\t\tif (test.def === \"\") test = getTest(pos).match;\r\n\r\n\t\tif (test.static !== true) {\r\n\t\t\treturn test.fn;\r\n\t\t}\r\n\t\tif (fuzzy === true && (maskset.validPositions[pos] !== undefined && maskset.validPositions[pos].generatedInput !== true)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (strict !== true && pos > -1) {\r\n\t\t\tvar tests = getTests(pos);\r\n\t\t\treturn tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction seekNext(pos, newBlock) {\r\n\t\tvar position = pos + 1;\r\n\t\twhile (getTest(position).match.def !== \"\" &&\r\n\t\t((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position, undefined, true))) ||\r\n\t\t\t(newBlock !== true && !isMask(position, undefined, true)))) {\r\n\t\t\tposition++;\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction seekPrevious(pos, newBlock) {\r\n\t\tvar position = pos,\r\n\t\t\ttests;\r\n\t\tif (position <= 0) return 0;\r\n\r\n\t\twhile (--position > 0 &&\r\n\t\t((newBlock === true && getTest(position).match.newBlockMarker !== true) ||\r\n\t\t\t(newBlock !== true && !isMask(position, undefined, true) &&\r\n\t\t\t\t// eslint-disable-next-line no-empty\r\n\t\t\t\t(tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === \"\"))))) {\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction writeBuffer(input, buffer, caretPos, event, triggerEvents) {\r\n\t\tif (event && $.isFunction(opts.onBeforeWrite)) {\r\n\t\t\t//    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer\r\n\t\t\tvar result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\r\n\t\t\tif (result) {\r\n\t\t\t\tif (result.refreshFromBuffer) {\r\n\t\t\t\t\tvar refresh = result.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\r\n\t\t\t\t\tbuffer = getBuffer(true);\r\n\t\t\t\t}\r\n\t\t\t\tif (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (input !== undefined) {\r\n\t\t\tinput.inputmask._valueSet(buffer.join(\"\"));\r\n\t\t\tif (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\r\n\t\t\t\tcaret(input, caretPos);\r\n\t\t\t}\r\n\t\t\tif (triggerEvents === true) {\r\n\t\t\t\tvar $input = $(input), nptVal = input.inputmask._valueGet();\r\n\t\t\t\tskipInputEvent = true;\r\n\t\t\t\t$input.trigger(\"input\");\r\n\t\t\t\tsetTimeout(function () { //timeout needed for IE\r\n\t\t\t\t\tif (nptVal === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t$input.trigger(\"cleared\");\r\n\t\t\t\t\t} else if (isComplete(buffer) === true) {\r\n\t\t\t\t\t\t$input.trigger(\"complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPlaceholder(pos, test, returnPL) {\r\n\t\ttest = test || getTest(pos).match;\r\n\t\tif (test.placeholder !== undefined || returnPL === true) {\r\n\t\t\treturn $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\r\n\t\t} else if (test.static === true) {\r\n\t\t\tif (pos > -1 && maskset.validPositions[pos] === undefined) {\r\n\t\t\t\tvar tests = getTests(pos),\r\n\t\t\t\t\tstaticAlternations = [],\r\n\t\t\t\t\tprevTest;\r\n\t\t\t\tif (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\r\n\t\t\t\t\tfor (var i = 0; i < tests.length; i++) {\r\n\t\t\t\t\t\tif (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&\r\n\t\t\t\t\t\t\t(tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, maskset, pos, true, opts) !== false))) {\r\n\t\t\t\t\t\t\tstaticAlternations.push(tests[i]);\r\n\t\t\t\t\t\t\tif (tests[i].match.static === true) prevTest = tests[i];\r\n\t\t\t\t\t\t\tif (staticAlternations.length > 1) {\r\n\t\t\t\t\t\t\t\tif (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\r\n\t\t\t\t\t\t\t\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn test.def;\r\n\t\t}\r\n\r\n\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t}\r\n\r\n\tfunction HandleNativePlaceholder(npt, value) {\r\n\t\tif (ie) {\r\n\t\t\tif (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === \"\")) {\r\n\t\t\t\tvar buffer = getBuffer().slice(),\r\n\t\t\t\t\tnptValue = npt.inputmask._valueGet();\r\n\t\t\t\tif (nptValue !== value) {\r\n\t\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\t\tif (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else if (lvp !== -1) { //clearout optional tail of the mask\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriteBuffer(npt, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (npt.placeholder !== value) {\r\n\t\t\tnpt.placeholder = value;\r\n\t\t\tif (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineNewCaretPosition(selectedCaret, tabbed) {\r\n\t\tfunction doRadixFocus(clickPos) {\r\n\t\t\tif (opts.radixPoint !== \"\" && opts.digits !== 0) {\r\n\t\t\t\tvar vps = maskset.validPositions;\r\n\t\t\t\tif (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {\r\n\t\t\t\t\tif (clickPos < seekNext(-1)) return true;\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n\t\t\t\t\tif (radixPos !== -1) {\r\n\t\t\t\t\t\tfor (var vp in vps) {\r\n\t\t\t\t\t\t\tif (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (tabbed) {\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tselectedCaret.end = selectedCaret.begin;\r\n\t\t\t} else {\r\n\t\t\t\tselectedCaret.begin = selectedCaret.end;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedCaret.begin === selectedCaret.end) {\r\n\t\t\tswitch (opts.positionCaretOnClick) {\r\n\t\t\t\tcase \"none\":\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\treturn {begin: 0, end: getBuffer().length};\r\n\t\t\t\tcase \"ignore\":\r\n\t\t\t\t\treturn seekNext(getLastValidPosition());\r\n\t\t\t\tcase \"radixFocus\":\r\n\t\t\t\t\tif (doRadixFocus(selectedCaret.begin)) {\r\n\t\t\t\t\t\tvar radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\r\n\t\t\t\t\t\treturn opts.numericInput ? seekNext(radixPos) : radixPos;\r\n\t\t\t\t\t} //fallback to lvp\r\n\t\t\t\t// eslint-disable-next-line no-fallthrough\r\n\t\t\t\tdefault: //lvp:\r\n\t\t\t\t\tvar clickPosition = selectedCaret.begin,\r\n\t\t\t\t\t\tlvclickPosition = getLastValidPosition(clickPosition, true),\r\n\t\t\t\t\t\tlastPosition = seekNext((lvclickPosition === -1 && !isMask(0)) ? 0 : lvclickPosition);\r\n\t\t\t\t\tif (clickPosition < lastPosition) {\r\n\t\t\t\t\t\treturn !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar lvp = maskset.validPositions[lvclickPosition],\r\n\t\t\t\t\t\t\ttt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),\r\n\t\t\t\t\t\t\tplaceholder = getPlaceholder(lastPosition, tt.match);\r\n\t\t\t\t\t\tif ((placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)) {\r\n\t\t\t\t\t\t\tvar newPos = seekNext(lastPosition);\r\n\t\t\t\t\t\t\tif (clickPosition >= newPos || clickPosition === lastPosition) {\r\n\t\t\t\t\t\t\t\tlastPosition = newPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPosition;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar EventRuler = {\r\n\t\ton: function (input, eventName, eventHandler) {\r\n\t\t\tvar ev = function (e) {\r\n\t\t\t\tvar that = this, args;\r\n\t\t\t\tif (that.inputmask === undefined && this.nodeName !== \"FORM\") { //happens when cloning an object with jquery.clone\r\n\t\t\t\t\tvar imOpts = $.data(that, \"_inputmask_opts\");\r\n\t\t\t\t\tif (imOpts) {\r\n\t\t\t\t\t\t(new Inputmask(imOpts)).mask(that);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tEventRuler.off(that);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || (that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\t\tcase \"input\":\r\n\t\t\t\t\t\t\tif (skipInputEvent === true || (e.originalEvent && e.originalEvent.inputType === \"insertCompositionText\")) {\r\n\t\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (mobile) {\r\n\t\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\t\tsetTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818\r\n\t\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t\t\tcaret(that, that.inputmask.caretPos, undefined, true);\r\n\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keydown\":\r\n\t\t\t\t\t\t\t//Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\t\t\t\t\t\tskipKeyPressEvent = false;\r\n\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\t\tif (skipKeyPressEvent === true) {\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tskipKeyPressEvent = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"click\":\r\n\t\t\t\t\t\tcase \"focus\":\r\n\t\t\t\t\t\t\tif (validationEvent) { // #841\r\n\t\t\t\t\t\t\t\tvalidationEvent = false;\r\n\t\t\t\t\t\t\t\tinput.blur();\r\n\t\t\t\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t\t\tinput.focus();\r\n\t\t\t\t\t\t\t\t}, 3000);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\tsetTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent\r\n\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar returnVal = eventHandler.apply(that, arguments);\r\n\t\t\t\t\tif (returnVal === false) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn returnVal;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t//keep instance of the event\r\n\t\t\tinput.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\r\n\t\t\tinput.inputmask.events[eventName].push(ev);\r\n\r\n\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\r\n\t\t\t\tif (input.form !== null) $(input.form).on(eventName, ev);\r\n\t\t\t} else {\r\n\t\t\t\t$(input).on(eventName, ev);\r\n\t\t\t}\r\n\t\t},\r\n\t\toff: function (input, event) {\r\n\t\t\tif (input.inputmask && input.inputmask.events) {\r\n\t\t\t\tvar events;\r\n\t\t\t\tif (event) {\r\n\t\t\t\t\tevents = [];\r\n\t\t\t\t\tevents[event] = input.inputmask.events[event];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents = input.inputmask.events;\r\n\t\t\t\t}\r\n\t\t\t\t$.each(events, function (eventName, evArr) {\r\n\t\t\t\t\twhile (evArr.length > 0) {\r\n\t\t\t\t\t\tvar ev = evArr.pop();\r\n\t\t\t\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\",]) !== -1) {\r\n\t\t\t\t\t\t\tif (input.form !== null) $(input.form).off(eventName, ev);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$(input).off(eventName, ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete input.inputmask.events[eventName];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tvar EventHandlers = {\r\n\t\tkeydownEvent: function (e, fromInputFallback) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.keyCode,\r\n\t\t\t\tpos = caret(input);\r\n\r\n\t\t\tvar kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts);\r\n\t\t\tif (kdResult !== undefined) return kdResult;\r\n\r\n\t\t\t//backspace, delete, and escape get special treatment\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !(\"oncut\" in input))) { //backspace/delete\r\n\t\t\t\te.preventDefault(); //stop default action but allow propagation\r\n\t\t\t\thandleRemove(input, k, pos);\r\n\t\t\t\twriteBuffer(input, getBuffer(true), fromInputFallback === true && opts.insertMode === false ? seekPrevious(maskset.p) : maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\r\n\t\t\t} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tvar caretPos = seekNext(getLastValidPosition());\r\n\t\t\t\tcaret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\r\n\t\t\t} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tcaret(input, 0, e.shiftKey ? pos.begin : 0, true);\r\n\t\t\t} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762\r\n\t\t\t\tcheckVal(input, true, false, undoValue.split(\"\"));\r\n\t\t\t\t$input.trigger(\"click\");\r\n\t\t\t\t// } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey) && inputmask.userOptions.insertMode === undefined) { //insert\r\n\t\t\t\t// \topts.insertMode = !opts.insertMode;\r\n\t\t\t\t// \tcaret(input, pos.begin, pos.end);\r\n\t\t\t} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\r\n\t\t\t\tif (e.shiftKey === true) {\r\n\t\t\t\t\tif (getTest(pos.begin).match.static === true) {\r\n\t\t\t\t\t\tpos.begin = seekNext(pos.begin);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos.end = seekPrevious(pos.begin, true);\r\n\t\t\t\t\tpos.begin = seekPrevious(pos.end, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos.begin = seekNext(pos.begin, true);\r\n\t\t\t\t\tpos.end = seekNext(pos.begin, true);\r\n\t\t\t\t\tif (pos.end < maskset.maskLength) pos.end--;\r\n\t\t\t\t}\r\n\t\t\t\tif (pos.begin < maskset.maskLength) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tcaret(input, pos.begin, pos.end);\r\n\t\t\t\t}\r\n\t\t\t} else if (!e.shiftKey) {\r\n\t\t\t\tif (opts.insertMode === false) {\r\n\t\t\t\t\tif (k === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\t\t\t\tcaret(input, caretPos.begin);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t} else if (k === Inputmask.keyCode.LEFT) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\tvar caretPos = {\r\n\t\t\t\t\t\t\t\tbegin: translatePosition(input.inputmask.caretPos.begin),\r\n\t\t\t\t\t\t\t\tend: translatePosition(input.inputmask.caretPos.end)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif (isRTL) {\r\n\t\t\t\t\t\t\t\tcaret(input, caretPos.begin + (caretPos.begin === maskset.maskLength ? 0 : 1));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, caretPos.begin - (caretPos.begin === 0 ? 0 : 1));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tignorable = $.inArray(k, opts.ignorables) !== -1;\r\n\t\t},\r\n\t\tkeypressEvent: function (e, checkval, writeOut, strict, ndx) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.which || e.charCode || e.keyCode;\r\n\r\n\t\t\tif (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\r\n\t\t\t\tif (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t// e.preventDefault();\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t} else if (k) {\r\n\t\t\t\t//special treat the decimal separator\r\n\t\t\t\tif (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\r\n\t\t\t\tvar pos = checkval ? {\r\n\t\t\t\t\t\tbegin: ndx,\r\n\t\t\t\t\t\tend: ndx\r\n\t\t\t\t\t} : caret(input),\r\n\t\t\t\t\tforwardPosition, c = String.fromCharCode(k);\r\n\r\n\t\t\t\tmaskset.writeOutBuffer = true;\r\n\t\t\t\tvar valResult = isValid(pos, c, strict);\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\tresetMaskSet(true);\r\n\t\t\t\t\tforwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\r\n\t\t\t\t\tmaskset.p = forwardPosition; //needed for checkval\r\n\t\t\t\t}\r\n\r\n\t\t\t\tforwardPosition = ((opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition);\r\n\t\t\t\tif (writeOut !== false) {\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\topts.onKeyValidation.call(input, k, valResult, opts);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t\tif (maskset.writeOutBuffer && valResult !== false) {\r\n\t\t\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\t\t\twriteBuffer(input, buffer, forwardPosition, e, checkval !== true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (checkval) {\r\n\t\t\t\t\tif (valResult !== false) valResult.forwardPosition = forwardPosition;\r\n\t\t\t\t\treturn valResult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpasteEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tev = e.originalEvent || e,\r\n\t\t\t\tinputValue = input.inputmask._valueGet(true),\r\n\t\t\t\tcaretPos = caret(input),\r\n\t\t\t\ttempValue;\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\ttempValue = caretPos.end;\r\n\t\t\t\tcaretPos.end = caretPos.begin;\r\n\t\t\t\tcaretPos.begin = tempValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar valueBeforeCaret = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\tvalueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n\r\n\t\t\tif (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\r\n\t\t\tif (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\r\n\r\n\t\t\tif (window.clipboardData && window.clipboardData.getData) { // IE\r\n\t\t\t\tinputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\r\n\t\t\t} else if (ev.clipboardData && ev.clipboardData.getData) {\r\n\t\t\t\tinputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t} //allow native paste event as fallback ~ masking will continue by inputfallback\r\n\r\n\t\t\tvar pasteValue = inputValue;\r\n\t\t\tif ($.isFunction(opts.onBeforePaste)) {\r\n\t\t\t\tpasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\r\n\t\t\t\tif (pasteValue === false) {\r\n\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (!pasteValue) {\r\n\t\t\t\t\tpasteValue = inputValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcheckVal(input, false, false, pasteValue.toString().split(\"\"));\r\n\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\r\n\t\t\treturn e.preventDefault();\r\n\t\t},\r\n\t\tinputFallBackEvent: function (e) { //fallback when keypress is not triggered\r\n\t\t\tfunction radixPointHandler(input, inputValue, caretPos) {\r\n\t\t\t\t//radixpoint tweak\r\n\t\t\t\tif (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\r\n\t\t\t\t\tinputValue = inputValue.split(\"\");\r\n\t\t\t\t\tinputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\r\n\t\t\t\t\tinputValue = inputValue.join(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction ieMobileHandler(input, inputValue, caretPos) {\r\n\t\t\t\tif (iemobile) { //iemobile just sets the character at the end althought the caret position is correctly set\r\n\t\t\t\t\tvar inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n\t\t\t\t\tif (inputChar.length === 1) {\r\n\t\t\t\t\t\tvar iv = inputValue.split(\"\");\r\n\t\t\t\t\t\tiv.splice(caretPos.begin, 0, inputChar);\r\n\t\t\t\t\t\tinputValue = iv.join(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar input = this,\r\n\t\t\t\tinputValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\r\n\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\tinputValue = radixPointHandler(input, inputValue, caretPos);\r\n\t\t\t\tinputValue = ieMobileHandler(input, inputValue, caretPos);\r\n\r\n\t\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\t\t\t\t\tvar buffer = getBuffer().join(\"\"),\r\n\t\t\t\t\t\toffset = (!opts.numericInput && inputValue.length > buffer.length) ? -1 : 0,\r\n\t\t\t\t\t\tfrontPart = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\t\t\tbackPart = inputValue.substr(caretPos.begin),\r\n\t\t\t\t\t\tfrontBufferPart = buffer.substr(0, caretPos.begin + offset),\r\n\t\t\t\t\t\tbackBufferPart = buffer.substr(caretPos.begin + offset);\r\n\r\n\t\t\t\t\t//check if thare was a selection\r\n\t\t\t\t\tvar selection = caretPos,\r\n\t\t\t\t\t\tentries = \"\",\r\n\t\t\t\t\t\tisEntry = false;\r\n\t\t\t\t\tif (frontPart !== frontBufferPart) {\r\n\t\t\t\t\t\tvar fpl = ((isEntry = frontPart.length >= frontBufferPart.length)) ? frontPart.length : frontBufferPart.length,\r\n\t\t\t\t\t\t\ti;\r\n\t\t\t\t\t\tfor (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\r\n\t\t\t\t\t\tif (isEntry) {\r\n\t\t\t\t\t\t\tselection.begin = i - offset;\r\n\t\t\t\t\t\t\tentries += frontPart.slice(i, selection.end);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (backPart !== backBufferPart) {\r\n\t\t\t\t\t\tif (backPart.length > backBufferPart.length) {\r\n\t\t\t\t\t\t\tentries += backPart.slice(0, 1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (backPart.length < backBufferPart.length) {\r\n\t\t\t\t\t\t\t\tselection.end += backBufferPart.length - backPart.length;\r\n\t\t\t\t\t\t\t\t//hack around numeric alias & radixpoint\r\n\t\t\t\t\t\t\t\tif (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\r\n\t\t\t\t\t\t\t\t\tselection.begin--;\r\n\t\t\t\t\t\t\t\t\tentries = opts.radixPoint;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), {\r\n\t\t\t\t\t\t\"begin\": selection.begin + offset,\r\n\t\t\t\t\t\t\"end\": selection.end + offset\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (entries.length > 0) {\r\n\t\t\t\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\t\t\t\t//set caret\r\n\t\t\t\t\t\t\tinput.focus();\r\n\t\t\t\t\t\t\tcaret(input, selection);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$.each(entries.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tvar keypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\tselection.begin = seekPrevious(selection.begin + 1);\r\n\t\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin, selection.end);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar keydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcompositionendEvent: function (e) {\r\n\t\t\t$el.trigger(\"input\");\r\n\t\t},\r\n\t\t// beforeInputEvent: function (e) {\r\n\t\t// \tif (e.cancelable) {\r\n\t\t// \t\tvar input = this, keydown, keypress;\r\n\t\t// \t\tswitch (e.inputType) {\r\n\t\t// \t\t\tcase \"insertText\":\r\n\t\t// \t\t\t\t$.each(e.data.split(\"\"), function (ndx, entry) {\r\n\t\t// \t\t\t\t\tkeypress = new $.Event(\"keypress\");\r\n\t\t// \t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t// \t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t// \t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t// \t\t\t\t});\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t\tcase \"deleteContentBackward\":\r\n\t\t// \t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t// \t\t\t\tkeydown.keyCode = Inputmask.keyCode.BACKSPACE;\r\n\t\t// \t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t\tcase \"deleteContentForward\":\r\n\t\t// \t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t// \t\t\t\tkeydown.keyCode = Inputmask.keyCode.DELETE;\r\n\t\t// \t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// },\r\n\t\tsetValueEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tvalue = (e && e.detail) ? e.detail[0] : arguments[1];\r\n\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t}\r\n\r\n\t\t\tapplyInputValue(input, value);\r\n\r\n\t\t\tif ((e.detail && e.detail[1] !== undefined) || arguments[2] !== undefined) {\r\n\t\t\t\tcaret(input, e.detail ? e.detail[1] : arguments[2]);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfocusEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tnptValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (opts.showMaskOnFocus) {\r\n\t\t\t\tif (nptValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\r\n\t\t\t\t} /*else if (mouseEnter === false) { //only executed on focus without mouseenter\r\n\t\t\t\t\tcaret(input, seekNext(getLastValidPosition()));\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\t\t\tif (opts.positionCaretOnTab === true && mouseEnter === false && (!isComplete(getBuffer()) || getLastValidPosition() === -1)) {\r\n\t\t\t\tEventHandlers.clickEvent.apply(input, [e, true]);\r\n\t\t\t}\r\n\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t},\r\n\t\tinvalidEvent: function (e) {\r\n\t\t\tvalidationEvent = true;\r\n\t\t},\r\n\t\tmouseleaveEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = false;\r\n\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== input) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t}\r\n\t\t},\r\n\t\tclickEvent: function (e, tabbed) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tvar newCaretPosition = determineNewCaretPosition(caret(input), tabbed);\r\n\t\t\t\tif (newCaretPosition !== undefined) {\r\n\t\t\t\t\tcaret(input, newCaretPosition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcutEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tpos = caret(input),\r\n\t\t\t\tev = e.originalEvent || e;\r\n\r\n\t\t\t//correct clipboardData\r\n\t\t\tvar clipboardData = window.clipboardData || ev.clipboardData,\r\n\t\t\t\tclipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n\t\t\tclipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\r\n\t\t\tif (document.execCommand) document.execCommand(\"copy\"); // copy selected content to system clipbaord\r\n\r\n\t\t\thandleRemove(input, Inputmask.keyCode.DELETE, pos);\r\n\t\t\twriteBuffer(input, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(\"\"));\r\n\t\t},\r\n\t\tblurEvent: function (e) {\r\n\t\t\tvar $input = $(this),\r\n\t\t\t\tinput = this;\r\n\t\t\tif (input.inputmask) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t\tvar nptValue = input.inputmask._valueGet(),\r\n\t\t\t\t\tbuffer = getBuffer().slice();\r\n\r\n\t\t\t\tif (nptValue !== \"\") {\r\n\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\tif (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t} else { //clearout optional tail of the mask\r\n\t\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t$input.trigger(\"incomplete\");\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer = getBufferTemplate().slice();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twriteBuffer(input, buffer, undefined, e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tmouseenterEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = true;\r\n\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\tif (originalPlaceholder == undefined && input.placeholder !== originalPlaceholder) {\r\n\t\t\t\t\toriginalPlaceholder = input.placeholder;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.showMaskOnHover) {\r\n\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubmitEvent: function () { //trigger change on submit if any\r\n\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t$el.trigger(\"change\");\r\n\t\t\t}\r\n\t\t\tif (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\r\n\t\t\t\tel.inputmask._valueSet(\"\"); //clear masktemplete on submit and still has focus\r\n\t\t\t}\r\n\t\t\tif (opts.clearIncomplete && isComplete(getBuffer()) === false) {\r\n\t\t\t\tel.inputmask._valueSet(\"\");\r\n\t\t\t}\r\n\t\t\tif (opts.removeMaskOnSubmit) {\r\n\t\t\t\tel.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\twriteBuffer(el, getBuffer());\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t},\r\n\t\tresetEvent: function () {\r\n\t\t\tel.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true));\r\n\t\t\t}, 0);\r\n\t\t},\r\n\t};\r\n\r\n\tfunction checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\r\n\t\tvar inputmask = this || input.inputmask,\r\n\t\t\tinputValue = nptvl.slice(),\r\n\t\t\tcharCodes = \"\",\r\n\t\t\tinitialNdx = -1,\r\n\t\t\tresult = undefined;\r\n\r\n\t\t// console.log(nptvl);\r\n\r\n\t\tfunction isTemplateMatch(ndx, charCodes) {\r\n\t\t\tif (opts.regex) return false;\r\n\t\t\tvar targetTemplate = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"),\r\n\t\t\t\tcharCodeNdx = targetTemplate.indexOf(charCodes);\r\n\t\t\t//strip spaces from targetTemplate\r\n\t\t\twhile (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === \" \") charCodeNdx--;\r\n\r\n\t\t\tvar match = charCodeNdx === 0 && !isMask(ndx)\r\n\t\t\t\t&& (getTest(ndx).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t|| (getTest(ndx).match.static === true && getTest(ndx).match.nativeDef === (\"'\" + charCodes.charAt(0)))\r\n\t\t\t\t\t|| (getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t\t|| (getTest(ndx + 1).match.static === true && getTest(ndx + 1).match.nativeDef === (\"'\" + charCodes.charAt(0))))));\r\n\r\n\t\t\tif (!match && charCodeNdx > 0) inputmask.caretPos = {begin: seekNext(charCodeNdx)};\r\n\t\t\treturn match;\r\n\t\t}\r\n\r\n\t\tresetMaskSet();\r\n\t\tinitialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0;\r\n\t\tmaskset.p = initialNdx;\r\n\t\tinputmask.caretPos = {begin: initialNdx};\r\n\r\n\t\tvar staticMatches = [], prevCaretPos = inputmask.caretPos;\r\n\t\t$.each(inputValue, function (ndx, charCode) {\r\n\t\t\tif (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined\r\n\t\t\t\tif (maskset.validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&\r\n\t\t\t\t\tisValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\");\r\n\t\t\t\t\tkeypress.which = charCode.charCodeAt(0);\r\n\t\t\t\t\tcharCodes += charCode;\r\n\t\t\t\t\tvar lvp = getLastValidPosition(undefined, true);\r\n\t\t\t\t\tif (!isTemplateMatch(initialNdx, charCodes)) {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\r\n\r\n\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\tinitialNdx = inputmask.caretPos.begin + 1;\r\n\t\t\t\t\t\t\tcharCodes = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tif (result.pos !== undefined && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t\tif (!isRTL) {\r\n\t\t\t\t\t\t\t\tresult.forwardPosition = result.pos + 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriteBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\r\n\t\t\t\t\t\tinputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};\r\n\t\t\t\t\t\tprevCaretPos = inputmask.caretPos;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinputmask.caretPos = prevCaretPos;\r\n\t\t\t\t\t}  //restore the caret position from before the failed validation\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (staticMatches.length > 0) {\r\n\t\t\tvar sndx, validPos, nextValid;\r\n\t\t\tif (!isComplete(getBuffer()) || staticMatches.length < seekNext(0)) {\r\n\t\t\t\twhile ((sndx = staticMatches.pop()) !== undefined) {\r\n\t\t\t\t\tif (sndx !== staticMatches.length) {\r\n\t\t\t\t\t\tvar keypress = new $.Event(\"_checkval\"),\r\n\t\t\t\t\t\t\tnextSndx = sndx + 1;\r\n\r\n\t\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t\tkeypress.which = validPos.input.charCodeAt(0);\r\n\t\t\t\t\t\twhile ((nextValid = maskset.validPositions[nextSndx]) && nextValid.input === validPos.input) {\r\n\t\t\t\t\t\t\tnextSndx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, nextSndx);\r\n\t\t\t\t\t\tif (result && result.pos !== undefined && result.pos !== sndx && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { //mark al statics as generated\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tif (validPos) {\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (writeOut) {\r\n\t\t\twriteBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unmaskedvalue(input) {\r\n\t\tif (input) {\r\n\t\t\tif (input.inputmask === undefined) {\r\n\t\t\t\treturn input.value;\r\n\t\t\t}\r\n\t\t\tif (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset\r\n\t\t\t\tapplyInputValue(input, input.inputmask._valueGet(true));\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar umValue = [],\r\n\t\t\tvps = maskset.validPositions;\r\n\t\tfor (var pndx in vps) {\r\n\t\t\tif (vps[pndx] && vps[pndx].match && vps[pndx].match.static != true) {\r\n\t\t\t\tumValue.push(vps[pndx].input);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n\t\tif ($.isFunction(opts.onUnMask)) {\r\n\t\t\tvar bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n\t\t\tunmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\r\n\t\t}\r\n\t\treturn unmaskedValue;\r\n\t}\r\n\r\n\tfunction translatePosition(pos) {\r\n\t\tif (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\r\n\t\t\tpos = el.inputmask._valueGet().length - pos;\r\n\t\t}\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tfunction caret(input, begin, end, notranslate) {\r\n\t\tvar range;\r\n\t\tif (begin !== undefined) {\r\n\t\t\tif ($.isArray(begin)) {\r\n\t\t\t\tend = isRTL ? begin[0] : begin[1];\r\n\t\t\t\tbegin = isRTL ? begin[1] : begin[0];\r\n\t\t\t}\r\n\t\t\tif (begin.begin !== undefined) {\r\n\t\t\t\tend = isRTL ? begin.begin : begin.end;\r\n\t\t\t\tbegin = isRTL ? begin.end : begin.begin;\r\n\t\t\t}\r\n\t\t\tif (typeof begin === \"number\") {\r\n\t\t\t\tbegin = notranslate ? begin : translatePosition(begin);\r\n\t\t\t\tend = notranslate ? end : translatePosition(end);\r\n\t\t\t\tend = (typeof end == \"number\") ? end : begin;\r\n\t\t\t\t// if (!$(input).is(\":visible\")) {\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tvar scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n\t\t\t\tinput.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\r\n\t\t\t\tinput.inputmask.caretPos = {begin: begin, end: end}; //track caret internally\r\n\t\t\t\tif (opts.insertMode === false && begin === end) end++; //set visualization for insert/overwrite mode\r\n\t\t\t\tif (input === document.activeElement) {\r\n\t\t\t\t\tif (\"setSelectionRange\" in input) {\r\n\t\t\t\t\t\tinput.setSelectionRange(begin, end);\r\n\t\t\t\t\t} else if (window.getSelection) {\r\n\t\t\t\t\t\trange = document.createRange();\r\n\t\t\t\t\t\tif (input.firstChild === undefined || input.firstChild === null) {\r\n\t\t\t\t\t\t\tvar textNode = document.createTextNode(\"\");\r\n\t\t\t\t\t\t\tinput.appendChild(textNode);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\tvar sel = window.getSelection();\r\n\t\t\t\t\t\tsel.removeAllRanges();\r\n\t\t\t\t\t\tsel.addRange(range);\r\n\t\t\t\t\t\t//input.focus();\r\n\t\t\t\t\t} else if (input.createTextRange) {\r\n\t\t\t\t\t\trange = input.createTextRange();\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\trange.moveEnd(\"character\", end);\r\n\t\t\t\t\t\trange.moveStart(\"character\", begin);\r\n\t\t\t\t\t\trange.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\"selectionStart\" in input && \"selectionEnd\" in input) {\r\n\t\t\t\tbegin = input.selectionStart;\r\n\t\t\t\tend = input.selectionEnd;\r\n\t\t\t} else if (window.getSelection) {\r\n\t\t\t\trange = window.getSelection().getRangeAt(0);\r\n\t\t\t\tif (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\r\n\t\t\t\t\tbegin = range.startOffset;\r\n\t\t\t\t\tend = range.endOffset;\r\n\t\t\t\t}\r\n\t\t\t} else if (document.selection && document.selection.createRange) {\r\n\t\t\t\trange = document.selection.createRange();\r\n\t\t\t\tbegin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\r\n\t\t\t\tend = begin + range.text.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (opts.insertMode === false && begin === (end - 1)) end--; //correct caret for insert/overwrite mode\r\n\r\n\t\t\t/*eslint-disable consistent-return */\r\n\t\t\treturn {\r\n\t\t\t\t\"begin\": notranslate ? begin : translatePosition(begin),\r\n\t\t\t\t\"end\": notranslate ? end : translatePosition(end)\r\n\t\t\t};\r\n\t\t\t/*eslint-enable consistent-return */\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineLastRequiredPosition(returnDefinition) {\r\n\t\tvar buffer = getMaskTemplate(true, getLastValidPosition(), true, true),\r\n\t\t\tbl = buffer.length,\r\n\t\t\tpos, lvp = getLastValidPosition(),\r\n\t\t\tpositions = {},\r\n\t\t\tlvTest = maskset.validPositions[lvp],\r\n\t\t\tndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,\r\n\t\t\ttestPos;\r\n\t\tfor (pos = lvp + 1; pos < buffer.length; pos++) {\r\n\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\tpositions[pos] = $.extend(true, {}, testPos);\r\n\t\t}\r\n\r\n\t\tvar lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\r\n\t\tfor (pos = bl - 1; pos > lvp; pos--) {\r\n\t\t\ttestPos = positions[pos];\r\n\t\t\tif ((testPos.match.optionality ||\r\n\t\t\t\t(testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\r\n\t\t\t\t(lvTestAlt &&\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||\r\n\t\t\t\t\t\t(testPos.match.static === true &&\r\n\t\t\t\t\t\t\ttestPos.locator[lvTest.alternation] &&\r\n\t\t\t\t\t\t\tcheckAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) &&\r\n\t\t\t\t\t\t\tgetTests(pos)[0].def !== \"\")\r\n\t\t\t\t\t)\r\n\t\t\t\t)) &&\r\n\t\t\t\tbuffer[pos] === getPlaceholder(pos, testPos.match)) {\r\n\t\t\t\tbl--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn returnDefinition ? {\r\n\t\t\t\"l\": bl,\r\n\t\t\t\"def\": positions[bl] ? positions[bl].match : undefined\r\n\t\t} : bl;\r\n\t}\r\n\r\n\tfunction clearOptionalTail(buffer) {\r\n\t\tbuffer.length = 0;\r\n\t\tvar template = getMaskTemplate(true, 0, true, undefined, true), lmnt;\r\n\t\twhile ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tfunction isComplete(buffer) { //return true / false / undefined (repeat *)\r\n\t\tif ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n\t\tif (opts.repeat === \"*\") return undefined;\r\n\t\tvar complete = false,\r\n\t\t\tlrp = determineLastRequiredPosition(true),\r\n\t\t\taml = seekPrevious(lrp.l);\r\n\r\n\t\tif (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n\t\t\tcomplete = true;\r\n\t\t\tfor (var i = 0; i <= aml; i++) {\r\n\t\t\t\tvar test = getTestTemplate(i).match;\r\n\t\t\t\tif ((test.static !== true && maskset.validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== getPlaceholder(i, test))) {\r\n\t\t\t\t\tcomplete = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn complete;\r\n\t}\r\n\r\n\r\n\tfunction handleRemove(input, k, pos, strict, fromIsValid) {\r\n\t\tif (opts.numericInput || isRTL) {\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE) {\r\n\t\t\t\tk = Inputmask.keyCode.DELETE;\r\n\t\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\tk = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t}\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tvar pend = pos.end;\r\n\t\t\t\tpos.end = pos.begin;\r\n\t\t\t\tpos.begin = pend;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (k === Inputmask.keyCode.BACKSPACE || (k === Inputmask.keyCode.DELETE && opts.insertMode === false)) {\r\n\t\t\tif ((pos.end - pos.begin < 1)) {\r\n\t\t\t\tpos.begin = seekPrevious(pos.begin);\r\n\t\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\t\tpos.begin--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\tif (pos.begin === pos.end) {\r\n\t\t\t\tpos.end = isMask(pos.end, true, true) /*&& (maskset.validPositions[pos.end] && maskset.validPositions[pos.end].input !== opts.radixPoint)*/ ?\r\n\t\t\t\t\tpos.end + 1 :\r\n\t\t\t\t\tseekNext(pos.end) + 1;\r\n\t\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\t\tpos.end++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar offset;\r\n\t\tif ((offset = revalidateMask(pos)) !== false) {\r\n\t\t\tif (strict !== true && opts.keepStatic !== false || (opts.regex !== null && getTest(pos.begin).match.def.indexOf(\"|\") !== -1)) { //TODO NEEDS BETTER CHECK WHEN TO ALTERNATE  ~ opts regex isn\"t good enough\r\n\t\t\t\tvar result = alternate(true);\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tvar newPos = result.caret !== undefined ? result.caret : (result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true));\r\n\t\t\t\t\tif (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\r\n\t\t\t\t\t\tpos.begin == newPos;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar lvp = getLastValidPosition(pos.end, true);\r\n\t\t\tif (lvp < pos.begin) {\r\n\t\t\t\tmaskset.p = opts.insertMode === false ? seekPrevious(lvp + 1) : seekNext(lvp);\r\n\t\t\t} else if (strict !== true) {\r\n\t\t\t\tmaskset.p = k === Inputmask.keyCode.DELETE ? pos.begin + offset : pos.begin;\r\n\t\t\t\tif (opts.insertMode === false && k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\t\tmaskset.p = pos.end + 1;\r\n\t\t\t\t\tif (maskset.validPositions[maskset.p] === undefined && getLastValidPosition(maskset.maskLength, true) < maskset.p) {\r\n\t\t\t\t\t\tmaskset.p = seekPrevious(lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyInputValue(input, value) {\r\n\t\tinput.inputmask.refreshValue = false;\r\n\t\tif ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\r\n\t\tvalue = value.toString().split(\"\");\r\n\t\tcheckVal(input, true, false, value);\r\n\t\tundoValue = getBuffer().join(\"\");\r\n\t\tif ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && getLastValidPosition() === -1) {\r\n\t\t\tinput.inputmask._valueSet(\"\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mask(elem) {\r\n\t\tfunction isElementTypeSupported(input, opts) {\r\n\t\t\tfunction patchValueProperty(npt) {\r\n\t\t\t\tvar valueGet;\r\n\t\t\t\tvar valueSet;\r\n\r\n\t\t\t\tfunction patchValhook(type) {\r\n\t\t\t\t\tif ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\r\n\t\t\t\t\t\tvar valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\r\n\t\t\t\t\t\t\treturn elem.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvar valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\r\n\t\t\t\t\t\t\telem.value = value;\r\n\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t$.valHooks[type] = {\r\n\t\t\t\t\t\t\tget: function (elem) {\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tif (elem.inputmask.opts.autoUnmask) {\r\n\t\t\t\t\t\t\t\t\t\treturn elem.inputmask.unmaskedvalue();\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar result = valhookGet(elem);\r\n\t\t\t\t\t\t\t\t\t\treturn getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn valhookGet(elem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function (elem, value) {\r\n\t\t\t\t\t\t\t\tvar result = valhookSet(elem, value);\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tapplyInputValue(elem, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tinputmaskpatch: true\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction getter() {\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\treturn this.inputmask.opts.autoUnmask ?\r\n\t\t\t\t\t\t\tthis.inputmask.unmaskedvalue() :\r\n\t\t\t\t\t\t\t(getLastValidPosition() !== -1 || opts.nullable !== true ?\r\n\t\t\t\t\t\t\t\t(document.activeElement === this && opts.clearMaskOnLostFocus ?\r\n\t\t\t\t\t\t\t\t\t(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") :\r\n\t\t\t\t\t\t\t\t\tvalueGet.call(this)) :\r\n\t\t\t\t\t\t\t\t\"\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn valueGet.call(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction setter(value) {\r\n\t\t\t\t\tvalueSet.call(this, value);\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\tapplyInputValue(this, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction installNativeValueSetFallback(npt) {\r\n\t\t\t\t\tEventRuler.on(npt, \"mouseenter\", function () {\r\n\t\t\t\t\t\tvar input = this,\r\n\t\t\t\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t\t\t\tif (value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\")) { //Is this correct? to apply RTL? TOCHECK\r\n\t\t\t\t\t\t\tapplyInputValue(input, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!npt.inputmask.__valueGet) {\r\n\t\t\t\t\tif (opts.noValuePatching !== true) {\r\n\t\t\t\t\t\tif (Object.getOwnPropertyDescriptor) {\r\n\t\t\t\t\t\t\tif (typeof Object.getPrototypeOf !== \"function\") {\r\n\t\t\t\t\t\t\t\tObject.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.__proto__;\r\n\t\t\t\t\t\t\t\t} : function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.constructor.prototype;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\r\n\t\t\t\t\t\t\tif (valueProperty && valueProperty.get && valueProperty.set) {\r\n\t\t\t\t\t\t\t\tvalueGet = valueProperty.get;\r\n\t\t\t\t\t\t\t\tvalueSet = valueProperty.set;\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else if (npt.tagName !== \"INPUT\") {\r\n\t\t\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\t\t\treturn this.textContent;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\t\t\tthis.textContent = value;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\t\tvalueGet = npt.__lookupGetter__(\"value\");\r\n\t\t\t\t\t\t\tvalueSet = npt.__lookupSetter__(\"value\");\r\n\r\n\t\t\t\t\t\t\tnpt.__defineGetter__(\"value\", getter);\r\n\t\t\t\t\t\t\tnpt.__defineSetter__(\"value\", setter);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnpt.inputmask.__valueGet = valueGet; //store native property getter\r\n\t\t\t\t\t\tnpt.inputmask.__valueSet = valueSet; //store native property setter\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnpt.inputmask._valueGet = function (overruleRTL) {\r\n\t\t\t\t\t\treturn isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tnpt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to \"null\"\r\n\t\t\t\t\t\tvalueSet.call(this.el, (value === null || value === undefined) ? \"\" : ((overruleRTL !== true && isRTL) ? value.split(\"\").reverse().join(\"\") : value));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (valueGet === undefined) { //jquery.val fallback\r\n\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\treturn this.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\tthis.value = value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tpatchValhook(npt.type);\r\n\t\t\t\t\t\tinstallNativeValueSetFallback(npt);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar elementType = input.getAttribute(\"type\");\r\n\t\t\tvar isSupported = (input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === \"TEXTAREA\";\r\n\t\t\tif (!isSupported) {\r\n\t\t\t\tif (input.tagName === \"INPUT\") {\r\n\t\t\t\t\tvar el = document.createElement(\"input\");\r\n\t\t\t\t\tel.setAttribute(\"type\", elementType);\r\n\t\t\t\t\tisSupported = el.type === \"text\"; //apply mask only if the type is not natively supported\r\n\t\t\t\t\tel = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tisSupported = \"partial\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isSupported !== false) {\r\n\t\t\t\tpatchValueProperty(input);\r\n\t\t\t} else {\r\n\t\t\t\tinput.inputmask = undefined;\r\n\t\t\t}\r\n\t\t\treturn isSupported;\r\n\t\t}\r\n\r\n\t\t//unbind all events - to make sure that no other mask will interfere when re-masking\r\n\t\tEventRuler.off(elem);\r\n\t\tvar isSupported = isElementTypeSupported(elem, opts);\r\n\t\tif (isSupported !== false) {\r\n\t\t\tel = elem;\r\n\t\t\t$el = $(el);\r\n\r\n\t\t\toriginalPlaceholder = el.placeholder;\r\n\r\n\t\t\t//read maxlength prop from el\r\n\t\t\tmaxLength = el !== undefined ? el.maxLength : undefined;\r\n\t\t\tif (maxLength === -1) maxLength = undefined;\r\n\t\t\tif (\"inputmode\" in el) {\r\n\t\t\t\tel.inputmode = opts.inputmode;\r\n\t\t\t\tel.setAttribute(\"inputmode\", opts.inputmode);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (isSupported === true) {\r\n\t\t\t\topts.showMaskOnFocus = opts.showMaskOnFocus && [\"cc-number\", \"cc-exp\"].indexOf(el.autocomplete) === -1;\r\n\r\n\t\t\t\t//bind events\r\n\t\t\t\tEventRuler.on(el, \"submit\", EventHandlers.submitEvent);\r\n\t\t\t\tEventRuler.on(el, \"reset\", EventHandlers.resetEvent);\r\n\t\t\t\tEventRuler.on(el, \"blur\", EventHandlers.blurEvent);\r\n\t\t\t\tEventRuler.on(el, \"focus\", EventHandlers.focusEvent);\r\n\t\t\t\tEventRuler.on(el, \"invalid\", EventHandlers.invalidEvent);\r\n\t\t\t\tEventRuler.on(el, \"click\", EventHandlers.clickEvent);\r\n\t\t\t\tEventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\r\n\t\t\t\tEventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\r\n\t\t\t\tEventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\r\n\t\t\t\tEventRuler.on(el, \"cut\", EventHandlers.cutEvent);\r\n\t\t\t\tEventRuler.on(el, \"complete\", opts.oncomplete);\r\n\t\t\t\tEventRuler.on(el, \"incomplete\", opts.onincomplete);\r\n\t\t\t\tEventRuler.on(el, \"cleared\", opts.oncleared);\r\n\t\t\t\tif (!mobile && opts.inputEventOnly !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tel.removeAttribute(\"maxLength\");\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\r\n\t\t\t\tEventRuler.on(el, \"compositionend\", EventHandlers.compositionendEvent);\r\n\t\t\t\t// EventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement\r\n\t\t\t}\r\n\t\t\tEventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\r\n\r\n\t\t\t//apply mask\r\n\t\t\tundoValue = getBufferTemplate().join(\"\"); //initialize the buffer and getmasklength\r\n\t\t\tif (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true), opts);\r\n\t\t\t\tvar buffer = getBuffer().slice();\r\n\t\t\t\t// Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\r\n\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== el) {\r\n\t\t\t\t\tif (getLastValidPosition() === -1) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && document.activeElement === el) || el.inputmask._valueGet(true) !== \"\") {\r\n\t\t\t\t\twriteBuffer(el, buffer);\r\n\t\t\t\t}\r\n\t\t\t\tif (document.activeElement === el) { //position the caret when in focus\r\n\t\t\t\t\tcaret(el, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//action object\r\n\tvar valueBuffer;\r\n\tif (actionObj !== undefined) {\r\n\t\tswitch (actionObj.action) {\r\n\t\t\tcase \"isComplete\":\r\n\t\t\t\tel = actionObj.el;\r\n\t\t\t\treturn isComplete(getBuffer());\r\n\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\tif (el === undefined || actionObj.value !== undefined) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value;\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, false, false, valueBuffer);\r\n\t\t\t\t\tif ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\r\n\t\t\t\t}\r\n\t\t\t\treturn unmaskedvalue(el);\r\n\t\t\tcase \"mask\":\r\n\t\t\t\tmask(el);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"format\":\r\n\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\tif (actionObj.metadata) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n\t\t\t\t\t\tmetadata: maskScope.call(this, {\r\n\t\t\t\t\t\t\t\"action\": \"getmetadata\"\r\n\t\t\t\t\t\t}, maskset, opts)\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\tcase \"isValid\":\r\n\t\t\t\tif (actionObj.value) {\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\t\t}\r\n\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\tvar rl = determineLastRequiredPosition(),\r\n\t\t\t\t\tlmib = buffer.length - 1;\r\n\t\t\t\tfor (; lmib > rl; lmib--) {\r\n\t\t\t\t\tif (isMask(lmib)) break;\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.splice(rl, lmib + 1 - rl);\r\n\r\n\t\t\t\treturn isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"));\r\n\t\t\tcase \"getemptymask\":\r\n\t\t\t\treturn getBufferTemplate().join(\"\");\r\n\t\t\tcase \"remove\":\r\n\t\t\t\tif (el && el.inputmask) {\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", null); //invalidate\r\n\t\t\t\t\t$el = $(el);\r\n\t\t\t\t\t//writeout the value\r\n\t\t\t\t\tvar cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);\r\n\t\t\t\t\tif (cv !== getBufferTemplate().join(\"\")) el.inputmask._valueSet(cv, opts.autoUnmask); else el.inputmask._valueSet(\"\");\r\n\t\t\t\t\t//unbind all events\r\n\t\t\t\t\tEventRuler.off(el);\r\n\r\n\t\t\t\t\t//restore the value property\r\n\t\t\t\t\tvar valueProperty;\r\n\t\t\t\t\tif (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\r\n\t\t\t\t\t\tvalueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\r\n\t\t\t\t\t\tif (valueProperty) {\r\n\t\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\t\tObject.defineProperty(el, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: el.inputmask.__valueGet,\r\n\t\t\t\t\t\t\t\t\tset: el.inputmask.__valueSet,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\tel.__defineGetter__(\"value\", el.inputmask.__valueGet);\r\n\t\t\t\t\t\t\tel.__defineSetter__(\"value\", el.inputmask.__valueSet);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//clear data\r\n\t\t\t\t\tel.inputmask = undefined;\r\n\t\t\t\t}\r\n\t\t\t\treturn el;\r\n\t\t\tcase \"getmetadata\":\r\n\t\t\t\tif ($.isArray(maskset.metadata)) {\r\n\t\t\t\t\tvar maskTarget = getMaskTemplate(true, 0, false).join(\"\");\r\n\t\t\t\t\t$.each(maskset.metadata, function (ndx, mtdt) {\r\n\t\t\t\t\t\tif (mtdt.mask === maskTarget) {\r\n\t\t\t\t\t\t\tmaskTarget = mtdt;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn maskTarget;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn maskset.metadata;\r\n\t\t}\r\n\t}\r\n}\r\n;\r\n\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib,\r\n\t//supported codes for formatting\r\n\t//http://blog.stevenlevithan.com/archives/date-time-format\r\n\t//https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings?view=netframework-4.7\r\n\tformatCode = { //regex, valueSetter, type, displayformatter\r\n\t\td: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], //Day of the month as digits; no leading zero for single-digit days.\r\n\t\tdd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\r\n\t\t\treturn pad(Date.prototype.getDate.call(this), 2);\r\n\t\t}], //Day of the month as digits; leading zero for single-digit days.\r\n\t\tddd: [\"\"], //Day of the week as a three-letter abbreviation.\r\n\t\tdddd: [\"\"], //Day of the week as its full name.\r\n\t\tm: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn Date.prototype.getMonth.call(this) + 1;\r\n\t\t}], //Month as digits; no leading zero for single-digit months.\r\n\t\tmm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn pad(Date.prototype.getMonth.call(this) + 1, 2);\r\n\t\t}], //Month as digits; leading zero for single-digit months.\r\n\t\tmmm: [\"\"], //Month as a three-letter abbreviation.\r\n\t\tmmmm: [\"\"], //Month as its full name.\r\n\t\tyy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 2);\r\n\t\t}], //Year as last two digits; leading zero for years less than 10.\r\n\t\tyyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 4);\r\n\t\t}],\r\n\t\th: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (12-hour clock).\r\n\t\thh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (12-hour clock).\r\n\t\thhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tH: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (24-hour clock).\r\n\t\tHH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (24-hour clock).\r\n\t\tHHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tM: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], //Minutes; no leading zero for single-digit minutes. Uppercase M unlike CF timeFormat's m to avoid conflict with months.\r\n\t\tMM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\r\n\t\t\treturn pad(Date.prototype.getMinutes.call(this), 2);\r\n\t\t}], //Minutes; leading zero for single-digit minutes. Uppercase MM unlike CF timeFormat's mm to avoid conflict with months.\r\n\t\ts: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], //Seconds; no leading zero for single-digit seconds.\r\n\t\tss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getSeconds.call(this), 2);\r\n\t\t}], //Seconds; leading zero for single-digit seconds.\r\n\t\tl: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 3);\r\n\t\t}], //Milliseconds. 3 digits.\r\n\t\tL: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 2);\r\n\t\t}], //Milliseconds. 2 digits.\r\n\t\tt: [\"[ap]\"], //Lowercase, single-character time marker string: a or p.\r\n\t\ttt: [\"[ap]m\"], //two-character time marker string: am or pm.\r\n\t\tT: [\"[AP]\"], //single-character time marker string: A or P.\r\n\t\tTT: [\"[AP]M\"], //two-character time marker string: AM or PM.\r\n\t\tZ: [\"\"], //US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500\r\n\t\to: [\"\"], //GMT/UTC timezone offset, e.g. -0500 or +0230.\r\n\t\tS: [\"\"] //The date's ordinal suffix (st, nd, rd, or th).\r\n\t},\r\n\tformatAlias = {\r\n\t\tisoDate: \"yyyy-mm-dd\", //2007-06-09\r\n\t\tisoTime: \"HH:MM:ss\", //17:46:21\r\n\t\tisoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", //2007-06-09T17:46:21\r\n\t\tisoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" //2007-06-09T22:46:21Z\r\n\t};\r\n\r\nfunction getTokenizer(opts) {\r\n\tif (!opts.tokenizer) {\r\n\t\tvar tokens = [];\r\n\t\tfor (var ndx in formatCode) {\r\n\t\t\tif (tokens.indexOf(ndx[0]) === -1) {\r\n\t\t\t\ttokens.push(ndx[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\r\n\t\topts.tokenizer = new RegExp(opts.tokenizer, \"g\");\r\n\t}\r\n\r\n\treturn opts.tokenizer;\r\n}\r\n\r\nfunction isValidDate(dateParts, currentResult) {\r\n\treturn !isFinite(dateParts.rawday)\r\n\t|| (dateParts.day == \"29\" && !isFinite(dateParts.rawyear))\r\n\t|| new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day\r\n\t\t? currentResult\r\n\t\t: false; //take corrective action if possible\r\n}\r\n\r\nfunction isDateInRange(dateParts, opts) {\r\n\tvar result = true;\r\n\tif (opts.min) {\r\n\t\tif (dateParts[\"rawyear\"]) {\r\n\t\t\tvar rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\r\n\t\t\t\tminYear = opts.min.year.substr(0, rawYear.length);\r\n\t\t\tresult = minYear <= rawYear;\r\n\t\t}\r\n\t\tif (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\r\n\t\t\tif (opts.min.date.getTime() === opts.min.date.getTime()) {\r\n\t\t\t\tresult = opts.min.date.getTime() <= dateParts.date.getTime();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\r\n\t\tresult = opts.max.date.getTime() >= dateParts.date.getTime();\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n//parse the given format and return a mask pattern\r\n//when a dateObjValue is passed a datestring in the requested format is returned\r\nfunction parse(format, dateObjValue, opts, raw) {\r\n\t//parse format to regex string\r\n\tvar mask = \"\", match;\r\n\tgetTokenizer(opts).lastIndex = 0;\r\n\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\tif (dateObjValue === undefined) {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tmask += \"(\" + formatCode[match[0]][0] + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tswitch (match[0]) {\r\n\t\t\t\t\tcase \"[\":\r\n\t\t\t\t\t\tmask += \"(\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"]\":\r\n\t\t\t\t\t\tmask += \")?\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmask += Inputmask.escapeRegex(match[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tif (raw !== true && formatCode[match[0]][3]) {\r\n\t\t\t\t\tvar getFn = formatCode[match[0]][3];\r\n\t\t\t\t\tmask += getFn.call(dateObjValue.date);\r\n\t\t\t\t} else if (formatCode[match[0]][2]) {\r\n\t\t\t\t\tmask += dateObjValue[\"raw\" + formatCode[match[0]][2]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmask += match[0];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmask += match[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn mask;\r\n}\r\n\r\n//padding function\r\nfunction pad(val, len) {\r\n\tval = String(val);\r\n\tlen = len || 2;\r\n\twhile (val.length < len) val = \"0\" + val;\r\n\treturn val;\r\n}\r\n\r\nfunction analyseMask(maskString, format, opts) {\r\n\tvar dateObj = {\"date\": new Date(1, 0, 1)}, targetProp, mask = maskString, match, dateOperation;\r\n\r\n\tfunction extendProperty(value) {\r\n\t\tvar correctedValue = value.replace(/[^0-9]/g, \"0\");\r\n\t\t// if (correctedValue != value) { //only do correction on incomplete values\r\n\t\t//     //determine best validation match\r\n\t\t//     var enteredPart = value.replace(/[^0-9]/g, \"\"),\r\n\t\t//         enteredPartIndex = value.indexOf(enteredPart),\r\n\t\t//         minPart = (opts.min && opts.min[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         maxPart = (opts.max && opts.max[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         correctedPart = enteredPart < minPart ? minPart : (enteredPart > maxPart ? maxPart : correctedValue.slice(enteredPartIndex, enteredPartIndex + enteredPart.length));\r\n\t\t//     correctedValue = correctedValue.split(\"\");\r\n\t\t//     correctedValue.splice(enteredPartIndex, 1, correctedPart);\r\n\t\t//     correctedValue = correctedValue.join(\"\");\r\n\t\t// }\r\n\t\treturn correctedValue;\r\n\t}\r\n\r\n\tfunction setValue(dateObj, value, opts) {\r\n\t\tdateObj[targetProp] = extendProperty(value);\r\n\t\tdateObj[\"raw\" + targetProp] = value;\r\n\r\n\t\tif (dateOperation !== undefined) {\r\n\t\t\tdateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof mask === \"string\") {\r\n\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\t\tvar value = mask.slice(0, match[0].length);\r\n\t\t\tif (formatCode.hasOwnProperty(match[0])) {\r\n\t\t\t\t// targetValidator = formatCode[match[0]][0];\r\n\t\t\t\ttargetProp = formatCode[match[0]][2];\r\n\t\t\t\tdateOperation = formatCode[match[0]][1];\r\n\t\t\t\tsetValue(dateObj, value, opts);\r\n\t\t\t}\r\n\t\t\tmask = mask.slice(value.length);\r\n\t\t}\r\n\r\n\t\treturn dateObj;\r\n\t} else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\r\n\t\treturn mask;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nInputmask.extendAliases({\r\n\t\"datetime\": {\r\n\t\tmask: function (opts) {\r\n\t\t\t//localize\r\n\t\t\tformatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\r\n\r\n\t\t\topts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\");\r\n\t\t\topts.regex = parse(opts.inputFormat, undefined, opts);\r\n\t\t\t// console.log(opts.regex);\r\n\t\t\treturn null; //migrate to regex mask\r\n\t\t},\r\n\t\tplaceholder: \"\", //set default as none (~ auto); when a custom placeholder is passed it will be used\r\n\t\tinputFormat: \"isoDateTime\", //format used to input the date\r\n\t\tdisplayFormat: undefined, //visual format when the input looses focus\r\n\t\toutputFormat: undefined, //unmasking format\r\n\t\tmin: null, //needs to be in the same format as the inputfornat\r\n\t\tmax: null, //needs to be in the same format as the inputfornat,\r\n\t\tskipOptionalPartCharacter: \"\",\r\n\t\t// Internationalization strings\r\n\t\ti18n: {\r\n\t\t\tdayNames: [\r\n\t\t\t\t\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\",\r\n\t\t\t\t\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"\r\n\t\t\t],\r\n\t\t\tmonthNames: [\r\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n\t\t\t\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n\t\t\t],\r\n\t\t\tordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset, caretPos) {\r\n\t\t\tvar calcPos = 0, targetMatch, match;\r\n\t\t\tif (isNaN(c) && buffer[pos] !== c) {\r\n\t\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\t\tif (calcPos >= pos) {\r\n\t\t\t\t\t\ttargetMatch = match;\r\n\t\t\t\t\t\tmatch = getTokenizer(opts).exec(opts.inputFormat);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (match && match[0] === c && targetMatch[0].length > 1) {\r\n\t\t\t\t\tbuffer[pos] = buffer[pos - 1];\r\n\t\t\t\t\tbuffer[pos - 1] = \"0\";\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tfuzzy: true,\r\n\t\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\t\trefreshFromBuffer: {start: pos - 1, end: pos + 1},\r\n\t\t\t\t\t\tpos: pos + 1\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts, maskset) {\r\n\t\t\topts.min = analyseMask(opts.min, opts.inputFormat, opts);\r\n\t\t\topts.max = analyseMask(opts.max, opts.inputFormat, opts);\r\n\r\n\t\t\tif (currentResult.fuzzy) {\r\n\t\t\t\tbuffer = currentResult.buffer;\r\n\t\t\t\tpos = currentResult.pos;\r\n\t\t\t}\r\n\r\n\t\t\t//full validate target\r\n\t\t\tvar calcPos = 0, match;\r\n\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\tif (calcPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (match && match[0] && formatCode[match[0]] !== undefined) {\r\n\t\t\t\tvar validator = formatCode[match[0]][0];\r\n\t\t\t\tvar part = buffer.slice(match.index, match.index + match[0].length);\r\n\t\t\t\tif (new RegExp(validator).test(part.join(\"\")) === false && match[0].length === 2 && maskset.validPositions[match.index] && maskset.validPositions[match.index + 1]) {\r\n\t\t\t\t\tmaskset.validPositions[match.index + 1].input = \"0\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\r\n\t\t\tif (result && dateParts.date.getTime() === dateParts.date.getTime()) { //check for a valid date ~ an invalid date returns NaN which isn't equal\r\n\t\t\t\tresult = isValidDate(dateParts, result);\r\n\t\t\t\tresult = result && isDateInRange(dateParts, opts);\r\n\t\t\t}\r\n\r\n\t\t\tif (pos && result && currentResult.pos !== pos) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbuffer: parse(opts.inputFormat, dateParts, opts).split(\"\"),\r\n\t\t\t\t\trefreshFromBuffer: {start: pos, end: currentResult.pos}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\tvar today = new Date(), match, date = \"\";\r\n\r\n\t\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tif (match[0].charAt(0) === \"d\") {\r\n\t\t\t\t\t\tdate += pad(today.getDate(), match[0].length);\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"m\") {\r\n\t\t\t\t\t\tdate += pad((today.getMonth() + 1), match[0].length);\r\n\t\t\t\t\t} else if (match[0] === \"yyyy\") {\r\n\t\t\t\t\t\tdate += today.getFullYear().toString();\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"y\") {\r\n\t\t\t\t\t\tdate += pad(today.getYear(), match[0].length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinput.inputmask._valueSet(date);\r\n\t\t\t\t$(input).trigger(\"setvalue\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true) : unmaskedValue;\r\n\t\t},\r\n\t\tcasing: function (elem, test, pos, validPositions) {\r\n\t\t\tif (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\r\n\t\t\tif (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\r\n\t\t\treturn elem;\r\n\t\t},\r\n\t\tinsertMode: false,\r\n\t\tshiftPositions: false,\r\n\t\tkeepStatic: false\r\n\t}\r\n});\r\n\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib;\r\n\r\nfunction autoEscape(txt, opts) {\r\n\tvar escapedTxt = \"\";\r\n\tfor (var i = 0; i < txt.length; i++) {\r\n\t\tif (Inputmask.prototype.definitions[txt.charAt(i)] ||\r\n\t\t\topts.definitions[txt.charAt(i)] ||\r\n\t\t\topts.optionalmarker.start === txt.charAt(i) ||\r\n\t\t\topts.optionalmarker.end === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.start === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.end === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.start === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.end === txt.charAt(i) ||\r\n\t\t\topts.alternatormarker === txt.charAt(i)) {\r\n\t\t\tescapedTxt += \"\\\\\" + txt.charAt(i);\r\n\t\t} else {\r\n\t\t\tescapedTxt += txt.charAt(i);\r\n\t\t}\r\n\t}\r\n\treturn escapedTxt;\r\n}\r\n\r\nfunction alignDigits(buffer, digits, opts) {\r\n\tif (digits > 0 && !opts.digitsOptional) {\r\n\t\tvar radixPosition = $.inArray(opts.radixPoint, buffer);\r\n\t\tif (radixPosition === -1) {\r\n\t\t\tbuffer.push(opts.radixPoint);\r\n\t\t\tradixPosition = buffer.length - 1;\r\n\t\t}\r\n\t\tfor (var i = 1; i <= digits; i++) {\r\n\t\t\tbuffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn buffer;\r\n}\r\n\r\nfunction findValidator(symbol, maskset) {\r\n\tvar posNdx = 0;\r\n\tif (symbol === \"+\") {\r\n\t\tfor (posNdx in maskset.validPositions) ;\r\n\t\tposNdx = parseInt(posNdx);\r\n\t}\r\n\tfor (var tstNdx in maskset.tests) {\r\n\t\ttstNdx = parseInt(tstNdx);\r\n\t\tif (tstNdx >= posNdx) {\r\n\t\t\tfor (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\r\n\t\t\t\tif ((maskset.validPositions[tstNdx] === undefined || symbol === \"-\") && maskset.tests[tstNdx][ndx].match.def === symbol) {\r\n\t\t\t\t\treturn tstNdx + ((maskset.validPositions[tstNdx] !== undefined && symbol !== \"-\") ? 1 : 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn posNdx;\r\n}\r\n\r\nfunction findValid(symbol, maskset) {\r\n\tvar ret = -1;\r\n\t$.each(maskset.validPositions, function (ndx, tst) {\r\n\t\tif (tst && tst.match.def === symbol) {\r\n\t\t\tret = parseInt(ndx);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\treturn ret;\r\n}\r\n\r\nfunction parseMinMaxOptions(opts) {\r\n\tif (opts.parseMinMaxOptions === undefined) {\r\n\t\t// convert min and max options\r\n\t\tif (opts.min !== null) {\r\n\t\t\topts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\r\n\t\t\topts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\r\n\t\t\tif (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\r\n\t\t}\r\n\t\tif (opts.max !== null) {\r\n\t\t\topts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\r\n\t\t\topts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\r\n\t\t\tif (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\r\n\t\t}\r\n\t\topts.parseMinMaxOptions = \"done\";\r\n\t}\r\n}\r\n\r\nfunction genMask(opts) {\r\n\topts.repeat = 0;\r\n\t//treat equal separator and radixpoint\r\n\tif (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\r\n\t\tif (opts.radixPoint === \".\") {\r\n\t\t\topts.groupSeparator = \",\";\r\n\t\t} else if (opts.radixPoint === \",\") {\r\n\t\t\topts.groupSeparator = \".\";\r\n\t\t} else {\r\n\t\t\topts.groupSeparator = \"\";\r\n\t\t}\r\n\t}\r\n\t//prevent conflict with default skipOptionalPartCharacter\r\n\tif (opts.groupSeparator === \" \") {\r\n\t\topts.skipOptionalPartCharacter = undefined;\r\n\t}\r\n\r\n\t//enforce placeholder to single\r\n\tif (opts.placeholder.length > 1) {\r\n\t\topts.placeholder = opts.placeholder.charAt(0);\r\n\t}\r\n\t//only allow radixfocus when placeholder = 0\r\n\tif (opts.positionCaretOnClick === \"radixFocus\" && opts.placeholder === \"\") {\r\n\t\topts.positionCaretOnClick = \"lvp\";\r\n\t}\r\n\r\n\tvar decimalDef = \"0\";\r\n\tif (opts.numericInput === true && opts.__financeInput === undefined) { //finance people input style\r\n\t\tdecimalDef = \"1\";\r\n\t\topts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\r\n\t\t// opts.digitsOptional = false;\r\n\t\tif (isNaN(opts.digits)) opts.digits = 2;\r\n\t\topts._radixDance = false;\r\n\t} else {\r\n\t\topts.__financeInput = false; //needed to keep original selection when remasking\r\n\t\topts.numericInput = true;\r\n\t}\r\n\r\n\tvar mask = \"[+]\", altMask;\r\n\tmask += autoEscape(opts.prefix, opts);\r\n\tif (opts.groupSeparator !== \"\") {\r\n\t\tmask += opts._mask(opts);\r\n\t} else {\r\n\t\tmask += \"9{+}\";\r\n\t}\r\n\tif (opts.digits !== undefined && opts.digits !== 0) {\r\n\t\tvar dq = opts.digits.toString().split(\",\");\r\n\t\tif (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\r\n\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t} else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\r\n\t\t\tif (opts.digitsOptional) {\r\n\t\t\t\taltMask = mask + opts.radixPoint + decimalDef + \"{0,\" + opts.digits + \"}\";\r\n\t\t\t\t// mask += \"[\" + opts.radixPoint + \"]\";\r\n\t\t\t\topts.keepStatic = true;\r\n\t\t\t} else {\r\n\t\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmask += autoEscape(opts.suffix, opts);\r\n\tmask += \"[-]\";\r\n\r\n\tif (altMask) {\r\n\t\tmask = [(altMask + autoEscape(opts.suffix, opts) + \"[-]\"), mask];\r\n\t}\r\n\r\n\r\n\topts.greedy = false; //enforce greedy false\r\n\r\n\tparseMinMaxOptions(opts);\r\n\r\n\t// console.log(mask);\r\n\treturn mask;\r\n}\r\n\r\nfunction hanndleRadixDance(pos, c, radixPos, opts) {\r\n\tif (opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back) {\r\n\t\tif (pos <= radixPos && (radixPos > 0 || c == opts.radixPoint)) {\r\n\t\t\tpos -= 1;\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\n\r\nfunction decimalValidator(chrs, maskset, pos, strict, opts) {\r\n\tvar radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,\r\n\t\tresult = radixPos !== -1 && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\r\n\tif (opts._radixDance && result && maskset.validPositions[radixPos] == undefined) {\r\n\t\treturn {\r\n\t\t\tinsert: {\r\n\t\t\t\tpos: radixPos === pos ? radixPos + 1 : radixPos,\r\n\t\t\t\tc: opts.radixPoint\r\n\t\t\t},\r\n\t\t\tpos: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction checkForLeadingZeroes(buffer, opts) {\r\n\t//check leading zeros\r\n\tvar numberMatches = new RegExp(\"(^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(buffer.slice().reverse().join(\"\")),\r\n\t\tnumber = numberMatches ? numberMatches[2] : \"\", leadingzeroes = false;\r\n\tif (number) {\r\n\t\tnumber = number.split(opts.radixPoint.charAt(0))[0];\r\n\t\tleadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number);\r\n\t}\r\n\treturn leadingzeroes && (leadingzeroes[0].length > 1 || leadingzeroes[0].length > 0 && leadingzeroes[0].length < number.length) ? leadingzeroes : false;\r\n}\r\n\r\n//number aliases\r\nInputmask.extendAliases({\r\n\t\"numeric\": {\r\n\t\tmask: genMask,\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"999){+|1}\";\r\n\t\t},\r\n\t\tplaceholder: \"0\",\r\n\t\tgreedy: false,\r\n\t\tdigits: \"*\", //number of fractionalDigits\r\n\t\tdigitsOptional: true,\r\n\t\tenforceDigitsOnBlur: false,\r\n\t\tradixPoint: \".\",\r\n\t\tpositionCaretOnClick: \"radixFocus\",\r\n\t\t_radixDance: true,\r\n\t\tgroupSeparator: \"\",\r\n\t\tallowMinus: true,\r\n\t\tnegationSymbol: {\r\n\t\t\tfront: \"-\", //\"(\"\r\n\t\t\tback: \"\" //\")\"\r\n\t\t},\r\n\t\tprefix: \"\",\r\n\t\tsuffix: \"\",\r\n\t\trightAlign: true,\r\n\t\tmin: null, //minimum value\r\n\t\tmax: null, //maximum value\r\n\t\tstep: 1,\r\n\t\tinsertMode: true,\r\n\t\tautoUnmask: false,\r\n\t\tunmaskAsNumber: false,\r\n\t\tinputmode: \"numeric\",\r\n\t\tskipOptionalPartCharacter: \"\",\r\n\t\tdefinitions: {\r\n\t\t\t\"0\": {\r\n\t\t\t\tvalidator: decimalValidator\r\n\t\t\t},\r\n\t\t\t\"1\": {\r\n\t\t\t\tvalidator: decimalValidator,\r\n\t\t\t\tdefinitionSymbol: \"*\"\r\n\t\t\t},\r\n\t\t\t\"+\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front));\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && chrs === opts.negationSymbol.back);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset, caretPos) {\r\n\t\t\tif (opts.__financeInput !== false && c === opts.radixPoint) return false;\r\n\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\tpos = hanndleRadixDance(pos, c, radixPos, opts);\r\n\t\t\tif (c === \"-\" || c === opts.negationSymbol.front) {\r\n\t\t\t\tif (opts.allowMinus !== true) return false;\r\n\t\t\t\tvar isNegative = false,\r\n\t\t\t\t\tfront = findValid(\"+\", maskset), back = findValid(\"-\", maskset);\r\n\t\t\t\tif (front !== -1) {\r\n\t\t\t\t\tisNegative = [front, back];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isNegative !== false ? {\r\n\t\t\t\t\tremove: isNegative,\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t} : {\r\n\t\t\t\t\tinsert: [\r\n\t\t\t\t\t\t{pos: findValidator(\"+\", maskset), c: opts.negationSymbol.front, fromIsValid: true},\r\n\t\t\t\t\t\t{pos: findValidator(\"-\", maskset), c: opts.negationSymbol.back, fromIsValid: undefined}],\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (radixPos !== -1 && (opts._radixDance === true && isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) && radixPos !== pos)) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"caret\": opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn {rewritePosition: (isSelection && opts.digitsOptional) ? caretPos.end : pos};\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts, maskset) {\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t}));\r\n\t\t\t\tif (opts.min !== null && unmasked < opts.min && (unmasked.toString().length >= opts.min.toString().length || unmasked < 0)) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.max !== null && unmasked > opts.max) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: alignDigits(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn currentResult;\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\tif (unmaskedValue === \"\" && opts.nullable === true) {\r\n\t\t\t\treturn unmaskedValue;\r\n\t\t\t}\r\n\t\t\tvar processValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tprocessValue = processValue.replace(opts.suffix, \"\");\r\n\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.placeholder.charAt(0) !== \"\") {\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\r\n\t\t\t}\r\n\t\t\tif (opts.unmaskAsNumber) {\r\n\t\t\t\tif (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\t\treturn Number(processValue);\r\n\t\t\t}\r\n\t\t\treturn processValue;\r\n\t\t},\r\n\t\tisComplete: function (buffer, opts) {\r\n\t\t\tvar maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.suffix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\r\n\t\t\tif (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\r\n\t\t\treturn isFinite(maskedValue);\r\n\t\t},\r\n\t\tonBeforeMask: function (initialValue, opts) {\r\n\t\t\tvar radixPoint = opts.radixPoint || \",\";\r\n\r\n\t\t\tif ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\r\n\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t}\r\n\r\n\t\t\tvar valueParts = initialValue.split(radixPoint),\r\n\t\t\t\tintegerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\r\n\t\t\t\tdecimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\r\n\r\n\t\t\tinitialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\r\n\r\n\t\t\tvar digits = 0;\r\n\t\t\tif (radixPoint !== \"\") {\r\n\t\t\t\tdigits = decimalPart.length;\r\n\t\t\t\tif (decimalPart !== \"\") {\r\n\t\t\t\t\tvar digitsFactor = Math.pow(10, digits || 1);\r\n\t\t\t\t\tif (isFinite(opts.digits)) {\r\n\t\t\t\t\t\tdigits = parseInt(opts.digits);\r\n\t\t\t\t\t\tdigitsFactor = Math.pow(10, digits);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//make the initialValue a valid javascript number for the parsefloat\r\n\t\t\t\t\tinitialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\r\n\t\t\t\t\tif (isFinite(initialValue)) {\r\n\t\t\t\t\t\tinitialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//this needs to be in a separate part and not directly in decimalPart to allow rounding\r\n\t\t\tif (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\r\n\t\t\t\tinitialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\r\n\t\t\t}\r\n\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar numberValue = initialValue.toString().replace(radixPoint, \".\");\r\n\t\t\t\tif (opts.min !== null && numberValue < opts.min) {\r\n\t\t\t\t\tinitialValue = opts.min.toString().replace(\".\", radixPoint);\r\n\t\t\t\t} else if (opts.max !== null && numberValue > opts.max) {\r\n\t\t\t\t\tinitialValue = opts.max.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\r\n\t\t},\r\n\t\tonBeforeWrite: function (e, buffer, caretPos, opts) {\r\n\t\t\tfunction stripBuffer(buffer, stripRadix) {\r\n\t\t\t\tif (opts.__financeInput !== false || stripRadix) {\r\n\t\t\t\t\tvar position = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (position !== -1) {\r\n\t\t\t\t\t\tbuffer.splice(position, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.groupSeparator !== \"\") {\r\n\t\t\t\t\twhile ((position = buffer.indexOf(opts.groupSeparator)) !== -1) {\r\n\t\t\t\t\t\tbuffer.splice(position, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn buffer;\r\n\t\t\t}\r\n\r\n\t\t\tvar result,\r\n\t\t\t\tleadingzeroes = checkForLeadingZeroes(buffer, opts);\r\n\r\n\t\t\tif (leadingzeroes) {\r\n\t\t\t\tvar buf = buffer.slice().reverse(), caretNdx = buf.join(\"\").indexOf(leadingzeroes[0]);\r\n\t\t\t\tbuf.splice(caretNdx, leadingzeroes[0].length);\r\n\t\t\t\tvar newCaretPos = buf.length - caretNdx;\r\n\t\t\t\tstripBuffer(buf);\r\n\t\t\t\tresult = {\r\n\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\tbuffer: buf.reverse(),\r\n\t\t\t\t\tcaret: caretPos < newCaretPos ? caretPos : newCaretPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase \"blur\":\r\n\t\t\t\t\tcase \"checkval\":\r\n\t\t\t\t\t\tif (opts.min !== null) {\r\n\t\t\t\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t\t\t\t}));\r\n\t\t\t\t\t\t\tif (opts.min !== null && unmasked < opts.min) {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\t\t\t\tbuffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (opts.radixPoint !== \"\" && buffer[0] === opts.radixPoint) {\r\n\t\t\t\t\t\t\tif (result && result.buffer) {\r\n\t\t\t\t\t\t\t\tresult.buffer.shift();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer.shift();\r\n\t\t\t\t\t\t\t\tresult =\r\n\t\t\t\t\t\t\t\t\t{refreshFromBuffer: true, buffer: stripBuffer(buffer)};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (buffer[buffer.length - 1] === opts.negationSymbol.front) {\r\n\t\t\t\t\t\t\t\tvar nmbrMtchs = new RegExp(\"(^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(stripBuffer(buffer.slice(), true).reverse().join(\"\")),\r\n\t\t\t\t\t\t\t\t\tnumber = nmbrMtchs ? nmbrMtchs[2] : \"\";\r\n\t\t\t\t\t\t\t\tif (number == 0) {\r\n\t\t\t\t\t\t\t\t\tresult = {refreshFromBuffer: true, buffer: [0]};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar $input = $(this), bffr;\r\n\t\t\tif (e.ctrlKey) {\r\n\t\t\t\tswitch (e.keyCode) {\r\n\t\t\t\t\tcase Inputmask.keyCode.UP:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase Inputmask.keyCode.DOWN:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!e.shiftKey && (e.keyCode === Inputmask.keyCode.DELETE || e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI)) {\r\n\t\t\t\tif (buffer[e.keyCode === Inputmask.keyCode.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) {\r\n\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\tif (opts.negationSymbol.front !== \"\") bffr.shift();\r\n\t\t\t\t\tif (opts.negationSymbol.back !== \"\") bffr.pop();\r\n\t\t\t\t\t$input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else if (opts._radixDance === true) {\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (!opts.digitsOptional) {\r\n\t\t\t\t\t\tif (radixPos !== -1 && (caretPos.begin < radixPos || (e.keyCode === Inputmask.keyCode.DELETE && caretPos.begin === radixPos))) {\r\n\t\t\t\t\t\t\tif (e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\t\t\t\t\tcaretPos.begin++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\t\t\tbffr.splice(bffr.length - caretPos.begin, 1);\r\n\t\t\t\t\t\t\t$input.trigger(\"setvalue\", [alignDigits(bffr, opts.digits, opts).join(\"\"), caretPos.begin]);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (radixPos === 0) {\r\n\t\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\t\tbffr.pop();\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\"currency\": {\r\n\t\tprefix: \"$ \",\r\n\t\tgroupSeparator: \",\",\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t},\r\n\t\"decimal\": {\r\n\t\talias: \"numeric\"\r\n\t},\r\n\t\"integer\": {\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 0\r\n\t},\r\n\t\"percentage\": {\r\n\t\talias: \"numeric\",\r\n\t\tmin: 0,\r\n\t\tmax: 100,\r\n\t\tsuffix: \" %\",\r\n\t\tdigits: 0,\r\n\t\tallowMinus: false\r\n\t},\r\n\t\"indianns\": { //indian numbering system\r\n\t\talias: \"numeric\",\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\r\n\t\t},\r\n\t\tgroupSeparator: \",\",\r\n\t\tradixPoint: \".\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask plugin for jquery\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"jquery\"), Inputmask = require(\"./inputmask\");\r\nif ($.fn.inputmask === undefined) {\r\n\t//jquery plugin\r\n\t$.fn.inputmask = function (fn, options) {\r\n\t\tvar nptmask, input = this[0];\r\n\t\tif (options === undefined) options = {};\r\n\t\tif (typeof fn === \"string\") {\r\n\t\t\tswitch (fn) {\r\n\t\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();\r\n\t\t\t\tcase \"remove\":\r\n\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\tif (this.inputmask) this.inputmask.remove();\r\n\t\t\t\t\t});\r\n\t\t\t\tcase \"getemptymask\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.getemptymask() : \"\";\r\n\t\t\t\tcase \"hasMaskedValue\": //check whether the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.hasMaskedValue() : false;\r\n\t\t\t\tcase \"isComplete\":\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.isComplete() : true;\r\n\t\t\t\tcase \"getmetadata\": //return mask metadata if exists\r\n\t\t\t\t\treturn input && input.inputmask ? input.inputmask.getmetadata() : undefined;\r\n\t\t\t\tcase \"setvalue\":\r\n\t\t\t\t\tInputmask.setValue(input, options);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"option\":\r\n\t\t\t\t\tif (typeof options === \"string\") {\r\n\t\t\t\t\t\tif (input && input.inputmask !== undefined) {\r\n\t\t\t\t\t\t\treturn input.inputmask.option(options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\t\tif (this.inputmask !== undefined) {\r\n\t\t\t\t\t\t\t\treturn this.inputmask.option(options);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\toptions.alias = fn;\r\n\t\t\t\t\tnptmask = new Inputmask(options);\r\n\t\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\t\tnptmask.mask(this);\r\n\t\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (Array.isArray(fn)) {\r\n\t\t\toptions.alias = fn;\r\n\t\t\tnptmask = new Inputmask(options);\r\n\t\t\treturn this.each(function () {\r\n\t\t\t\tnptmask.mask(this);\r\n\t\t\t});\r\n\t\t} else if (typeof fn == \"object\") {\r\n\t\t\tnptmask = new Inputmask(fn);\r\n\t\t\tif (fn.mask === undefined && fn.alias === undefined) {\r\n\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\tif (this.inputmask !== undefined) {\r\n\t\t\t\t\t\treturn this.inputmask.option(fn);\r\n\t\t\t\t\t} else nptmask.mask(this);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\treturn this.each(function () {\r\n\t\t\t\t\tnptmask.mask(this);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t} else if (fn === undefined) {\r\n\t\t\t//look for data-inputmask atributes\r\n\t\t\treturn this.each(function () {\r\n\t\t\t\tnptmask = new Inputmask(options);\r\n\t\t\t\tnptmask.mask(this);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}