{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./bundle.js","webpack:///./lib/extensions/inputmask.extensions.js","webpack:///./lib/inputmask.js","webpack:///./lib/dependencyLibs/inputmask.dependencyLib.js","webpack:///./lib/global/window.js","webpack:///./lib/maskset.js","webpack:///./lib/maskScope.js","webpack:///./lib/extensions/inputmask.date.extensions.js","webpack:///./lib/extensions/inputmask.numeric.extensions.js","webpack:///webpack/bootstrap"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","a","i","window","require","Inputmask","ipValidator","chrs","maskset","pos","strict","opts","buffer","RegExp","test","extendDefinitions","validator","casing","extendAliases","regex","autoUnmask","mask","definitions","onUnMask","maskedValue","unmaskedValue","inputmode","greedy","onBeforePaste","pastedValue","toLowerCase","replace","clearIncomplete","$","document","generateMaskSet","analyseMask","maskScope","alias","options","internal","this","el","undefined","events","refreshValue","isPlainObject","extend","defaults","noMasksCache","userOptions","resolveAlias","isRTL","numericInput","aliasStr","aliasDefinition","prototype","aliases","importAttributeOptions","npt","dataAttribute","importOption","option","optionData","getAttribute","indexOf","importDataAttributes","attrOptions","dataoptions","p","JSON","parse","dir","rightAlign","style","textAlign","removeAttribute","Object","keys","length","placeholder","optionalmarker","quantifiermarker","groupmarker","alternatormarker","escapeChar","oncomplete","noop","onincomplete","oncleared","repeat","removeMaskOnSubmit","clearMaskOnLostFocus","insertMode","onKeyDown","onBeforeMask","isFunction","call","onBeforeWrite","showMaskOnFocus","showMaskOnHover","onKeyValidation","skipOptionalPartCharacter","undoOnEscape","radixPoint","_radixDance","groupSeparator","keepStatic","positionCaretOnTab","tabThrough","supportsInputType","ignorables","isComplete","preValidation","postValidation","staticDefinitionSymbol","jitMasking","nullable","inputEventOnly","noValuePatching","positionCaretOnClick","shiftPositions","definitionSymbol","masksCache","elems","that","getElementById","querySelectorAll","nodeName","each","ndx","scopedOpts","inputmask","remove","data","noremask","unmaskedvalue","value","getemptymask","hasMaskedValue","getmetadata","isValid","format","metadata","setValue","trigger","extendDefaults","definition","unmask","escapeRegex","str","specials","join","keyCode","BACKSPACE","BACKSPACE_SAFARI","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","SPACE","TAB","UP","X","CONTROL","dependencyLib","list","elem","len","isWindow","obj","isArraylike","ltype","nodeType","isValidElement","Element","DependencyLib","querySelector","eventRegistry","on","handler","addEvent","ev","namespace","addEventListener","attachEvent","push","_events","split","endx","nsEvent","off","removeEvent","removeEventListener","detachEvent","nmsp","splice","resolveNamespace","evts","hndx","hndL","evNdx","offEvents","offEventsL","type","evnt","params","bubbles","cancelable","detail","createEvent","CustomEvent","e","initCustomEvent","dispatchEvent","createEventObject","eventType","fireEvent","Event","arguments","slice","apply","isArray","Array","inArray","arr","valHooks","constructor","hasOwnProperty","name","src","copy","copyIsArray","clone","target","deep","callback","owner","key","__data","event","evt","eval","nocache","ms","generateMask","regexMask","masksetDefinition","maskdefKey","repeatStart","reverse","charAt","altMask","msk","pop","tokenizer","regexTokenizer","escaped","currentToken","MaskToken","match","m","openenings","maskTokens","openingToken","currentOpeningToken","alternator","lastMatch","closeRegexGroup","isGroup","isOptional","isQuantifier","isAlternator","matches","openGroup","alternatorGroup","quantifier","min","max","insertTestDefinition","mtoken","element","position","prevMatch","fn","static","optionality","newBlockMarker","def","nativeDef","lmnt","maskdef","verifyGroupMarker","maskToken","token","nextToken","defaultCase","mndx","reverseTokens","reverseStatic","st","intMatch","parseInt","qt","groupify","groupToken","closeGroup","groupQuantifier","exec","altRegexGroup","mqj","mq","mq0","isNaN","mq1","jit","tmpMatch","subToken","ua","navigator","userAgent","ie","mobile","iemobile","iphone","actionObj","undoValue","$el","skipKeyPressEvent","skipInputEvent","validationEvent","ignorable","maxLength","mouseEnter","originalPlaceholder","getMaskTemplate","baseOnInput","minimalPos","includeMode","noJit","clearOptionalTail","maskTemplate","ndxIntlzr","testPos","validPositions","generatedInput","input","determineTestTemplate","getTests","locator","getPlaceholder","getTestTemplate","isFinite","maskLength","resetMaskSet","soft","getLastValidPosition","closestTo","before","after","valids","posNdx","psNdx","getDecisionTaker","tst","decisionTaker","alternation","toString","getLocator","align","mloc","tests","altTest","getTest","targetLocator","tstLocator","closest","bestMatch","distance","Math","abs","optionalQuantifier","tstPs","positionCanMatchDefinition","testDefinition","valid","defProp","tndx","jitOffset","ndxInitializer","insertStop","latestMatch","cacheDependency","resolveTestFromToken","loopNdx","quantifierRecurse","handleMatch","isFirstMatch","tokenGroup","firstMatch","resolveNdxInitializer","alternateNdx","targetAlternation","indexPos","ndxPos","bestMatchAltIndex","isSubsetOf","source","expand","pattern","expanded","start","end","l","charCodeAt","String","fromCharCode","staticCanMatchDefinition","setMergeLocators","targetMatch","altMatch","locNdx","optionalToken","mtchsNdx","mtch","alternateToken","malternateMatches","maltMatches","currentMatches","loopNdxCnt","altIndex","shift","currentPos","ndxInitializerClone","altIndexArr","amndx","excludes","altIndexArrClone","unMatchedAlternation","concat","ndx1","dropMatch","ndx2","altMatch2","qndx","mergeLocators","previousPos","cd","mtndx","getBufferTemplate","_buffer","getBuffer","noCache","refreshFromBuffer","valResult","negationSymbol","front","caret","toUpperCase","posBefore","args","checkAlternationMatch","altArr1","altArr2","na","altArrC","isMatch","naArr","naNdx","alndx","alternate","maskPos","c","fromIsValid","rAltPos","selection","validPsClone","tstClone","lastAlt","isValidRslt","returnRslt","altPos","prevAltPos","validPos","decisionPos","lAltPos","nextPos","begin","validInputs","resultPos","fromAlternate","validateOnly","isSelection","posObj","processCommandObject","commandObj","sort","b","revalidateMask","insert","refresh","rewritePosition","_isValid","rslt","validatedPos","result","positionsClone","currentPosValid","seekNext","skip","isMask","nPos","snPos","trackbackPositions","postResult","endResult","originalPos","newPos","fillOnly","ps","vp","np","cvpInput","validTest","IsEnclosedStatic","posMatch","nextMatch","offset","lvp","j","t","fuzzy","newBlock","seekPrevious","writeBuffer","caretPos","triggerEvents","_valueSet","$input","nptVal","_valueGet","setTimeout","returnPL","staticAlternations","prevTest","HandleNativePlaceholder","nptValue","determineNewCaretPosition","selectedCaret","tabbed","doRadixFocus","clickPos","digits","vps","radixPos","clickPosition","lvclickPosition","lastPosition","tt","EventRuler","eventName","eventHandler","imOpts","disabled","readOnly","ctrlKey","originalEvent","inputType","preventDefault","blur","focus","returnVal","stopPropagation","form","evArr","EventHandlers","keydownEvent","fromInputFallback","k","kdResult","handleRemove","shiftKey","altKey","checkVal","translatePosition","keypressEvent","checkval","writeOut","which","charCode","metaKey","forwardPosition","writeOutBuffer","pasteEvent","inputValue","tempValue","valueBeforeCaret","substr","valueAfterCaret","clipboardData","getData","pasteValue","inputFallBackEvent","radixPointHandler","ieMobileHandler","inputChar","iv","frontPart","backPart","frontBufferPart","backBufferPart","entries","isEntry","fpl","activeElement","entry","keypress","keydown","compositionendEvent","setValueEvent","applyInputValue","focusEvent","clickEvent","invalidEvent","mouseleaveEvent","newCaretPosition","cutEvent","clipData","setData","execCommand","blurEvent","mouseenterEvent","submitEvent","resetEvent","valueBuffer","nptvl","initiatingEvent","charCodes","initialNdx","isTemplateMatch","targetTemplate","charCodeNdx","staticMatches","prevCaretPos","sndx","nextValid","nextSndx","umValue","pndx","bufferValue","notranslate","range","selectionStart","selectionEnd","getSelection","getRangeAt","commonAncestorContainer","parentNode","startOffset","endOffset","createRange","duplicate","moveStart","text","scrollCalc","ownerDocument","defaultView","getComputedStyle","currentStyle","fontSize","scrollLeft","scrollWidth","setSelectionRange","firstChild","textNode","createTextNode","appendChild","setStart","setEnd","collapse","sel","removeAllRanges","addRange","createTextRange","moveEnd","select","determineLastRequiredPosition","returnDefinition","bl","positions","lvTest","lvTestAlt","template","complete","lrp","aml","pend","isElementTypeSupported","patchValueProperty","valueGet","valueSet","patchValhook","inputmaskpatch","valhookGet","get","valhookSet","set","getter","setter","installNativeValueSetFallback","__valueGet","getOwnPropertyDescriptor","getPrototypeOf","__proto__","object","valueProperty","defineProperty","configurable","tagName","textContent","__lookupGetter__","__lookupSetter__","__defineGetter__","__defineSetter__","__valueSet","overruleRTL","elementType","isSupported","isContentEditable","createElement","setAttribute","autocomplete","action","rl","lmib","cv","maskTarget","mtdt","formatCode","d","Date","setDate","getDate","dd","pad","ddd","dddd","setMonth","getMonth","mm","mmm","mmmm","yy","setFullYear","getFullYear","yyyy","h","setHours","getHours","hh","hhh","H","HH","HHH","M","setMinutes","getMinutes","MM","s","setSeconds","getSeconds","ss","setMilliseconds","getMilliseconds","L","T","TT","Z","o","S","formatAlias","isoDate","isoTime","isoDateTime","isoUtcDateTime","getTokenizer","tokens","isValidDate","dateParts","currentResult","rawday","day","rawyear","date","rawmonth","month","isDateInRange","rawYear","minYear","year","getTime","dateObjValue","raw","lastIndex","getFn","val","maskString","dateObj","targetProp","dateOperation","extendProperty","correctedValue","i18n","ordinalSuffix","inputFormat","displayFormat","outputFormat","dayNames","monthNames","calcPos","part","index","today","getYear","autoEscape","txt","escapedTxt","alignDigits","digitsOptional","radixPosition","findValidator","symbol","tstNdx","ndxl","findValid","ret","parseMinMaxOptions","parseFloat","NaN","Number","MIN_VALUE","MAX_VALUE","genMask","decimalDef","__financeInput","prefix","_mask","dq","suffix","hanndleRadixDance","back","decimalValidator","checkForLeadingZeroes","numberMatches","number","leadingzeroes","enforceDigitsOnBlur","allowMinus","step","unmaskAsNumber","isNegative","unmasked","processValue","initialValue","valueParts","integerPart","decimalPart","digitsFactor","pow","round","substring","numberValue","stripBuffer","stripRadix","buf","caretNdx","newCaretPos","nmbrMtchs","bffr","installedModules","__webpack_require__","modules","enumerable","r","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","getDefault","getModuleExports","property","moduleId"],"mappings":"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","file":"dist/inputmask.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn ","require(\"./lib/extensions/inputmask.extensions\");\r\nrequire(\"./lib/extensions/inputmask.date.extensions\");\r\nrequire(\"./lib/extensions/inputmask.numeric.extensions\");\r\nmodule.exports = require(\"./lib/inputmask.js\");\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\");\r\n//extra definitions\r\nInputmask.extendDefinitions({\r\n\t\"A\": {\r\n\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\" //auto uppercasing\r\n\t},\r\n\t\"&\": { //alfanumeric uppercasing\r\n\t\tvalidator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\tcasing: \"upper\"\r\n\t},\r\n\t\"#\": { //hexadecimal\r\n\t\tvalidator: \"[0-9A-Fa-f]\",\r\n\t\tcasing: \"upper\"\r\n\t}\r\n});\r\n\r\n\r\nfunction ipValidator(chrs, maskset, pos, strict, opts) {\r\n\tif (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\r\n\t\tchrs = maskset.buffer[pos - 1] + chrs;\r\n\t\tif (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\r\n\t\t\tchrs = maskset.buffer[pos - 2] + chrs;\r\n\t\t} else chrs = \"0\" + chrs;\r\n\t} else chrs = \"00\" + chrs;\r\n\treturn new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n}\r\n\r\n\r\nInputmask.extendAliases({\r\n\t\"cssunit\": {\r\n\t\tregex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\r\n\t},\r\n\t\"url\": { //needs update => https://en.wikipedia.org/wiki/URL\r\n\t\tregex: \"(https?|ftp)//.*\",\r\n\t\tautoUnmask: false\r\n\t},\r\n\t\"ip\": { //ip-address mask\r\n\t\tmask: \"i[i[i]].j[j[j]].k[k[k]].l[l[l]]\",\r\n\t\tdefinitions: {\r\n\t\t\t\"i\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"j\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"k\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t},\r\n\t\t\t\"l\": {\r\n\t\t\t\tvalidator: ipValidator\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"numeric\",\r\n\t},\r\n\t\"email\": {\r\n\t\t//https://en.wikipedia.org/wiki/Domain_name#Domain_name_space\r\n\t\t//https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\r\n\t\t//should be extended with the toplevel domains at the end\r\n\t\tmask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n\t\tgreedy: false,\r\n\t\tcasing: \"lower\",\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\tpastedValue = pastedValue.toLowerCase();\r\n\t\t\treturn pastedValue.replace(\"mailto:\", \"\");\r\n\t\t},\r\n\t\tdefinitions: {\r\n\t\t\t\"*\": {\r\n\t\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5!#$%&'*+/=?^_`{|}~-]\"\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: \"[0-9A-Za-z-]\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn maskedValue;\r\n\t\t},\r\n\t\tinputmode: \"email\"\r\n\t},\r\n\t\"mac\": {\r\n\t\tmask: \"##:##:##:##:##:##\"\r\n\t},\r\n\t//https://en.wikipedia.org/wiki/Vehicle_identification_number\r\n\t// see issue #1199\r\n\t\"vin\": {\r\n\t\tmask: \"V{13}9{4}\",\r\n\t\tdefinitions: {\r\n\t\t\t\"V\": {\r\n\t\t\t\tvalidator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n\t\t\t\tcasing: \"upper\"\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearIncomplete: true,\r\n\t\tautoUnmask: true\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n","/*\r\n * Input Mask Core\r\n * http://github.com/RobinHerbots/jquery.inputmask\r\n * Copyright (c) Robin Herbots\r\n * Licensed under the MIT license\r\n */\r\nvar $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tgenerateMaskSet = require(\"./maskset\").generateMaskSet,\r\n\tanalyseMask = require(\"./maskset\").analyseMask,\r\n\tmaskScope = require(\"./maskScope\");\r\n\r\n\r\nfunction Inputmask(alias, options, internal) {\r\n\t//allow instanciating without new\r\n\tif (!(this instanceof Inputmask)) {\r\n\t\treturn new Inputmask(alias, options, internal);\r\n\t}\r\n\r\n\tthis.el = undefined;\r\n\tthis.events = {};\r\n\tthis.maskset = undefined;\r\n\tthis.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)\r\n\r\n\tif (internal !== true) {\r\n\t\t//init options\r\n\t\tif ($.isPlainObject(alias)) {\r\n\t\t\toptions = alias;\r\n\t\t} else {\r\n\t\t\toptions = options || {};\r\n\t\t\tif (alias) options.alias = alias;\r\n\t\t}\r\n\t\tthis.opts = $.extend(true, {}, this.defaults, options);\r\n\t\tthis.noMasksCache = options && options.definitions !== undefined;\r\n\t\tthis.userOptions = options || {}; //user passed options\r\n\t\tresolveAlias(this.opts.alias, options, this.opts);\r\n\t\tthis.isRTL = this.opts.numericInput;\r\n\t}\r\n}\r\n\r\nInputmask.prototype = {\r\n\tdataAttribute: \"data-inputmask\", //data attribute prefix used for attribute binding\r\n\t//options default\r\n\tdefaults: {\r\n\t\tplaceholder: \"_\",\r\n\t\toptionalmarker: [\"[\", \"]\"],\r\n\t\tquantifiermarker: [\"{\", \"}\"],\r\n\t\tgroupmarker: [\"(\", \")\"],\r\n\t\talternatormarker: \"|\",\r\n\t\tescapeChar: \"\\\\\",\r\n\t\tmask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value\r\n\t\tregex: null, //regular expression as a mask\r\n\t\toncomplete: $.noop, //executes when the mask is complete\r\n\t\tonincomplete: $.noop, //executes when the mask is incomplete and focus is lost\r\n\t\toncleared: $.noop, //executes when the mask is cleared\r\n\t\trepeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\r\n\t\tgreedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\r\n\t\tautoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\r\n\t\tremoveMaskOnSubmit: false, //remove the mask before submitting the form.\r\n\t\tclearMaskOnLostFocus: true,\r\n\t\tinsertMode: true, //insert the input or overwrite the input\r\n\t\tclearIncomplete: false, //clear the incomplete input on blur\r\n\t\talias: null,\r\n\t\tonKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts\r\n\t\tonBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.\targs => initialValue, opts => return processedValue\r\n\t\tonBeforePaste: function (pastedValue, opts) {\r\n\t\t\treturn $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\r\n\t\t}, //executes before masking the pasted value to allow preprocessing of the pasted value.\targs => pastedValue, opts => return processedValue\r\n\t\tonBeforeWrite: null, //executes before writing to the masked element. args => event, opts\r\n\t\tonUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.\targs => maskedValue, unmaskedValue, opts\r\n\t\tshowMaskOnFocus: true, //show the mask-placeholder when the input has focus\r\n\t\tshowMaskOnHover: true, //show the mask-placeholder when hovering the empty input\r\n\t\tonKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts\r\n\t\tskipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\r\n\t\tnumericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\r\n\t\trightAlign: false, //align to the right\r\n\t\tundoOnEscape: true, //pressing escape reverts the value to the value before focus\r\n\t\t//numeric basic properties\r\n\t\tradixPoint: \"\", //\".\", // | \",\"\r\n\t\t_radixDance: false, //dance around the radixPoint\r\n\t\tgroupSeparator: \"\", //\",\", // | \".\"\r\n\t\t//numeric basic properties\r\n\t\tkeepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks\r\n\t\tpositionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB\r\n\t\ttabThrough: false, //allows for tabbing through the different parts of the masked field\r\n\t\tsupportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], //list with the supported input types\r\n\t\t//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\r\n\t\tignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\r\n\t\tisComplete: null, //override for isComplete - args => buffer, opts - return true || false\r\n\t\tpreValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.\targs => buffer, pos, char, isSelection, opts, maskset, caretPos => return true/false/command object\r\n\t\tpostValidation: null, //hook to postValidate the result from isValid.\tUsefull for validating the entry as a whole.\targs => buffer, pos, currentResult, opts => return true/false/json\r\n\t\tstaticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators\r\n\t\tjitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false\r\n\t\tnullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.\r\n\t\tinputEventOnly: false, //dev option - testing inputfallback behavior\r\n\t\tnoValuePatching: false, //disable value property patching\r\n\t\tpositionCaretOnClick: \"lvp\", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)\r\n\t\tcasing: null, //mask-level casing. Options: null, \"upper\", \"lower\" or \"title\" or callback args => elem, test, pos, validPositions return charValue\r\n\t\tinputmode: \"verbatim\", //specify the inputmode  - already in place for when browsers will support it\r\n\t\timportDataAttributes: true, //import data-inputmask attributes\r\n\t\tshiftPositions: true //shift position of the mask entries on entry and deletion.\r\n\t},\r\n\tdefinitions: {\r\n\t\t\"9\": { //\\uFF11-\\uFF19 #1606\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"a\": { //\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5 #76\r\n\t\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\r\n\t\t\tdefinitionSymbol: \"*\"\r\n\t\t},\r\n\t\t\"*\": {\r\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\"\r\n\t\t}\r\n\t},\r\n\taliases: {}, //aliases definitions\r\n\tmasksCache: {},\r\n\tmask: function (elems) {\r\n\t\tvar that = this;\r\n\t\tif (typeof elems === \"string\") {\r\n\t\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t\t}\r\n\t\telems = elems.nodeName ? [elems] : elems;\r\n\t\t$.each(elems, function (ndx, el) {\r\n\t\t\tvar scopedOpts = $.extend(true, {}, that.opts);\r\n\t\t\tif (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\r\n\t\t\t\tvar maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n\t\t\t\tif (maskset !== undefined) {\r\n\t\t\t\t\tif (el.inputmask !== undefined) {\r\n\t\t\t\t\t\tel.inputmask.opts.autoUnmask = true; //force autounmasking when remasking\r\n\t\t\t\t\t\tel.inputmask.remove();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//store inputmask instance on the input with element reference\r\n\t\t\t\t\tel.inputmask = new Inputmask(undefined, undefined, true);\r\n\t\t\t\t\tel.inputmask.opts = scopedOpts;\r\n\t\t\t\t\tel.inputmask.noMasksCache = that.noMasksCache;\r\n\t\t\t\t\tel.inputmask.userOptions = $.extend(true, {}, that.userOptions);\r\n\t\t\t\t\tel.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\r\n\t\t\t\t\tel.inputmask.el = el;\r\n\t\t\t\t\tel.inputmask.maskset = maskset;\r\n\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", scopedOpts);\r\n\r\n\t\t\t\t\tmaskScope.call(el.inputmask, {\r\n\t\t\t\t\t\t\"action\": \"mask\"\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn elems && elems[0] ? (elems[0].inputmask || this) : this;\r\n\t},\r\n\toption: function (options, noremask) { //set extra options || retrieve value of a current option\r\n\t\tif (typeof options === \"string\") {\r\n\t\t\treturn this.opts[options];\r\n\t\t} else if (typeof options === \"object\") {\r\n\t\t\t$.extend(this.userOptions, options); //user passed options\r\n\t\t\t//remask\r\n\t\t\tif (this.el && noremask !== true) {\r\n\t\t\t\tthis.mask(this.el);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t}\r\n\t},\r\n\tunmaskedvalue: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"unmaskedvalue\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tremove: function () {\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"remove\"\r\n\t\t});\r\n\t},\r\n\tgetemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getemptymask\"\r\n\t\t});\r\n\t},\r\n\thasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\r\n\t\treturn !this.opts.autoUnmask;\r\n\t},\r\n\tisComplete: function () {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isComplete\"\r\n\t\t});\r\n\t},\r\n\tgetmetadata: function () { //return mask metadata if exists\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"getmetadata\"\r\n\t\t});\r\n\t},\r\n\tisValid: function (value) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"isValid\",\r\n\t\t\t\"value\": value\r\n\t\t});\r\n\t},\r\n\tformat: function (value, metadata) {\r\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\r\n\t\treturn maskScope.call(this, {\r\n\t\t\t\"action\": \"format\",\r\n\t\t\t\"value\": value,\r\n\t\t\t\"metadata\": metadata //true/false getmetadata\r\n\t\t});\r\n\t},\r\n\tsetValue: function (value) {\r\n\t\tif (this.el) {\r\n\t\t\t$(this.el).trigger(\"setvalue\", [value]);\r\n\t\t}\r\n\t},\r\n\tanalyseMask: analyseMask\r\n};\r\n\r\nfunction resolveAlias(aliasStr, options, opts) {\r\n\tvar aliasDefinition = Inputmask.prototype.aliases[aliasStr];\r\n\tif (aliasDefinition) {\r\n\t\tif (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\r\n\t\t$.extend(true, opts, aliasDefinition); //merge alias definition in the options\r\n\t\t$.extend(true, opts, options); //reapply extra given options\r\n\t\treturn true;\r\n\t} else //alias not found - try as mask\r\n\tif (opts.mask === null) {\r\n\t\topts.mask = aliasStr;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfunction importAttributeOptions(npt, opts, userOptions, dataAttribute) {\r\n\tfunction importOption(option, optionData) {\r\n\t\toptionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\r\n\t\tif (optionData !== null) {\r\n\t\t\tif (typeof optionData === \"string\") {\r\n\t\t\t\tif (option.indexOf(\"on\") === 0) {\r\n\t\t\t\t\toptionData = window[optionData];\r\n\t\t\t\t}//get function definition\r\n\t\t\t\telse if (optionData === \"false\") {\r\n\t\t\t\t\toptionData = false;\r\n\t\t\t\t} else if (optionData === \"true\") optionData = true;\r\n\t\t\t}\r\n\t\t\tuserOptions[option] = optionData;\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.importDataAttributes === true) {\r\n\t\tvar attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\r\n\r\n\t\tif (attrOptions && attrOptions !== \"\") {\r\n\t\t\tattrOptions = attrOptions.replace(/'/g, \"\\\"\");\r\n\t\t\tdataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\r\n\t\t}\r\n\r\n\t\t//resolve aliases\r\n\t\tif (dataoptions) { //pickup alias from dataAttribute\r\n\t\t\toptionData = undefined;\r\n\t\t\tfor (p in dataoptions) {\r\n\t\t\t\tif (p.toLowerCase() === \"alias\") {\r\n\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\timportOption(\"alias\", optionData); //pickup alias from dataAttribute-alias\r\n\t\tif (userOptions.alias) {\r\n\t\t\tresolveAlias(userOptions.alias, userOptions, opts);\r\n\t\t}\r\n\r\n\t\tfor (option in opts) {\r\n\t\t\tif (dataoptions) {\r\n\t\t\t\toptionData = undefined;\r\n\t\t\t\tfor (p in dataoptions) {\r\n\t\t\t\t\tif (p.toLowerCase() === option.toLowerCase()) {\r\n\t\t\t\t\t\toptionData = dataoptions[p];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\timportOption(option, optionData);\r\n\t\t}\r\n\t}\r\n\t$.extend(true, opts, userOptions);\r\n\r\n\t//handle dir=rtl\r\n\tif (npt.dir === \"rtl\" || opts.rightAlign) {\r\n\t\tnpt.style.textAlign = \"right\";\r\n\t}\r\n\r\n\tif (npt.dir === \"rtl\" || opts.numericInput) {\r\n\t\tnpt.dir = \"ltr\";\r\n\t\tnpt.removeAttribute(\"dir\");\r\n\t\topts.isRTL = true;\r\n\t}\r\n\r\n\treturn Object.keys(userOptions).length;\r\n}\r\n\r\n//apply defaults, definitions, aliases\r\nInputmask.extendDefaults = function (options) {\r\n\t$.extend(true, Inputmask.prototype.defaults, options);\r\n};\r\nInputmask.extendDefinitions = function (definition) {\r\n\t$.extend(true, Inputmask.prototype.definitions, definition);\r\n};\r\nInputmask.extendAliases = function (alias) {\r\n\t$.extend(true, Inputmask.prototype.aliases, alias);\r\n};\r\n//static fn on inputmask\r\nInputmask.format = function (value, options, metadata) {\r\n\treturn Inputmask(options).format(value, metadata);\r\n};\r\nInputmask.unmask = function (value, options) {\r\n\treturn Inputmask(options).unmaskedvalue(value);\r\n};\r\nInputmask.isValid = function (value, options) {\r\n\treturn Inputmask(options).isValid(value);\r\n};\r\nInputmask.remove = function (elems) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.remove();\r\n\t});\r\n};\r\nInputmask.setValue = function (elems, value) {\r\n\tif (typeof elems === \"string\") {\r\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\r\n\t}\r\n\telems = elems.nodeName ? [elems] : elems;\r\n\t$.each(elems, function (ndx, el) {\r\n\t\tif (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [value]);\r\n\t});\r\n};\r\nInputmask.escapeRegex = function (str) {\r\n\tvar specials = [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"];\r\n\treturn str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n};\r\nInputmask.keyCode = {\r\n\tBACKSPACE: 8,\r\n\tBACKSPACE_SAFARI: 127,\r\n\tDELETE: 46,\r\n\tDOWN: 40,\r\n\tEND: 35,\r\n\tENTER: 13,\r\n\tESCAPE: 27,\r\n\tHOME: 36,\r\n\tINSERT: 45,\r\n\tLEFT: 37,\r\n\tPAGE_DOWN: 34,\r\n\tPAGE_UP: 33,\r\n\tRIGHT: 39,\r\n\tSPACE: 32,\r\n\tTAB: 9,\r\n\tUP: 38,\r\n\tX: 88,\r\n\tCONTROL: 17\r\n};\r\nInputmask.dependencyLib = $;\r\n\r\n//make inputmask available\r\nwindow.Inputmask = Inputmask;\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin dependencyLib\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\n\r\nvar window = require(\"../global/window\"), document = window.document;\r\n//helper functions\r\n\r\n// Use a stripped-down indexOf as it's faster than native\r\n// http://jsperf.com/thor-indexof-vs-for/5\r\nfunction indexOf(list, elem) {\r\n\tvar i = 0,\r\n\t\tlen = list.length;\r\n\tfor (; i < len; i++) {\r\n\t\tif (list[i] === elem) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\nfunction isWindow(obj) {\r\n\treturn obj != null && obj === obj[\"window\"];\r\n}\r\n\r\nfunction isArraylike(obj) {\r\n\t// Support: iOS 8.2 (not reproducible in simulator)\r\n\t// `in` check used to prevent JIT error (gh-2145)\r\n\t// hasOwn isn't used here due to false negatives\r\n\t// regarding Nodelist length in IE\r\n\tvar length = \"length\" in obj && obj.length,\r\n\t\tltype = typeof obj;\r\n\r\n\tif (ltype === \"function\" || isWindow(obj)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (obj.nodeType === 1 && length) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn ltype === \"array\" || length === 0 ||\r\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\r\n}\r\n\r\nfunction isValidElement(elem) {\r\n\treturn elem instanceof Element;\r\n}\r\n\r\nfunction DependencyLib(elem) {\r\n\tif (elem instanceof DependencyLib) {\r\n\t\treturn elem;\r\n\t}\r\n\tif (!(this instanceof DependencyLib)) {\r\n\t\treturn new DependencyLib(elem);\r\n\t}\r\n\tif (elem !== undefined && elem !== null && elem !== window) {\r\n\t\tthis[0] = elem.nodeName ? elem : (elem[0] !== undefined && elem[0].nodeName ? elem[0] : document.querySelector(elem));\r\n\t\tif (this[0] !== undefined && this[0] !== null) {\r\n\t\t\tthis[0].eventRegistry = this[0].eventRegistry || {};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nDependencyLib.prototype = {\r\n\ton: function (events, handler) {\r\n\t\tfunction addEvent(ev, namespace) {\r\n\t\t\t//register domevent\r\n\t\t\tif (elem.addEventListener) { // all browsers except IE before version 9\r\n\t\t\t\telem.addEventListener(ev, handler, false);\r\n\t\t\t} else if (elem.attachEvent) { // IE before version 9\r\n\t\t\t\telem.attachEvent(\"on\" + ev, handler);\r\n\t\t\t}\r\n\t\t\teventRegistry[ev] = eventRegistry[ev] || {};\r\n\t\t\teventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [];\r\n\t\t\teventRegistry[ev][namespace].push(handler);\r\n\t\t}\r\n\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\tvar eventRegistry = this[0].eventRegistry,\r\n\t\t\t\telem = this[0];\r\n\r\n\r\n\t\t\tvar _events = events.split(\" \");\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\tev = nsEvent[0],\r\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\r\n\t\t\t\taddEvent(ev, namespace);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\toff: function (events, handler) {\r\n\t\tvar eventRegistry, elem;\r\n\r\n\t\tfunction removeEvent(ev, namespace, handler) {\r\n\t\t\tif (ev in eventRegistry === true) {\r\n\t\t\t\t//unbind to dom events\r\n\t\t\t\tif (elem.removeEventListener) { // all browsers except IE before version 9\r\n\t\t\t\t\telem.removeEventListener(ev, handler, false);\r\n\t\t\t\t} else if (elem.detachEvent) { // IE before version 9\r\n\t\t\t\t\telem.detachEvent(\"on\" + ev, handler);\r\n\t\t\t\t}\r\n\t\t\t\tif (namespace === \"global\") {\r\n\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\r\n\t\t\t\t\t\teventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\teventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction resolveNamespace(ev, namespace) {\r\n\t\t\tvar evts = [],\r\n\t\t\t\thndx, hndL;\r\n\t\t\tif (ev.length > 0) {\r\n\t\t\t\tif (handler === undefined) {\r\n\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {\r\n\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\tev: ev,\r\n\t\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\r\n\t\t\t\t\t\t\thandler: eventRegistry[ev][namespace][hndx]\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\tev: ev,\r\n\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\r\n\t\t\t\t\t\thandler: handler\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else if (namespace.length > 0) {\r\n\t\t\t\tfor (var evNdx in eventRegistry) {\r\n\t\t\t\t\tfor (var nmsp in eventRegistry[evNdx]) {\r\n\t\t\t\t\t\tif (nmsp === namespace) {\r\n\t\t\t\t\t\t\tif (handler === undefined) {\r\n\t\t\t\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {\r\n\t\t\t\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\t\t\t\tev: evNdx,\r\n\t\t\t\t\t\t\t\t\t\tnamespace: nmsp,\r\n\t\t\t\t\t\t\t\t\t\thandler: eventRegistry[evNdx][nmsp][hndx]\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tevts.push({\r\n\t\t\t\t\t\t\t\t\tev: evNdx,\r\n\t\t\t\t\t\t\t\t\tnamespace: nmsp,\r\n\t\t\t\t\t\t\t\t\thandler: handler\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn evts;\r\n\t\t}\r\n\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\teventRegistry = this[0].eventRegistry;\r\n\t\t\telem = this[0];\r\n\r\n\r\n\t\t\tvar _events = events.split(\" \");\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\toffEvents = resolveNamespace(nsEvent[0], nsEvent[1]);\r\n\t\t\t\tfor (var i = 0, offEventsL = offEvents.length; i < offEventsL; i++) {\r\n\t\t\t\t\tremoveEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\ttrigger: function (events /* , args... */) {\r\n\t\tif (isValidElement(this[0])) {\r\n\t\t\tvar eventRegistry = this[0].eventRegistry,\r\n\t\t\t\telem = this[0];\r\n\t\t\tvar _events = typeof events === \"string\" ? events.split(\" \") : [events.type];\r\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\r\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\r\n\t\t\t\t\tev = nsEvent[0],\r\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\r\n\t\t\t\tif (document !== undefined && namespace === \"global\") {\r\n\t\t\t\t\t//trigger domevent\r\n\t\t\t\t\tvar evnt, i, params = {\r\n\t\t\t\t\t\tbubbles: true,\r\n\t\t\t\t\t\tcancelable: true,\r\n\t\t\t\t\t\tdetail: arguments[1]\r\n\t\t\t\t\t};\r\n\t\t\t\t\t// The custom event that will be created\r\n\t\t\t\t\tif (document.createEvent) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tevnt = new CustomEvent(ev, params);\r\n\t\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\t\tevnt = document.createEvent(\"CustomEvent\");\r\n\t\t\t\t\t\t\tevnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\r\n\t\t\t\t\t\telem.dispatchEvent(evnt);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tevnt = document.createEventObject();\r\n\t\t\t\t\t\tevnt.eventType = ev;\r\n\t\t\t\t\t\tevnt.detail = arguments[1];\r\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\r\n\t\t\t\t\t\telem.fireEvent(\"on\" + evnt.eventType, evnt);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (eventRegistry[ev] !== undefined) {\r\n\t\t\t\t\targuments[0] = arguments[0].type ? arguments[0] : DependencyLib.Event(arguments[0]);\r\n\t\t\t\t\targuments[0].detail = arguments.slice(1);\r\n\t\t\t\t\tif (namespace === \"global\") {\r\n\t\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\r\n\t\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][nmsp].length; i++) {\r\n\t\t\t\t\t\t\t\teventRegistry[ev][nmsp][i].apply(elem, arguments);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][namespace].length; i++) {\r\n\t\t\t\t\t\t\teventRegistry[ev][namespace][i].apply(elem, arguments);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n};\r\n\r\n//static\r\nDependencyLib.isFunction = function (obj) {\r\n\treturn typeof obj === \"function\";\r\n};\r\nDependencyLib.noop = function () {\r\n};\r\nDependencyLib.isArray = Array.isArray;\r\nDependencyLib.inArray = function (elem, arr, i) {\r\n\treturn arr == null ? -1 : indexOf(arr, elem, i);\r\n};\r\nDependencyLib.valHooks = undefined;\r\n\r\n\r\nDependencyLib.isPlainObject = function (obj) {\r\n\t// Not plain objects:\r\n\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n\t// - DOM nodes\r\n\t// - window\r\n\tif (typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// If the function hasn't returned already, we're confident that\r\n\t// |obj| is a plain object, created by {} or constructed with new Object\r\n\treturn true;\r\n};\r\n\r\nDependencyLib.extend = function () {\r\n\tvar options, name, src, copy, copyIsArray, clone,\r\n\t\ttarget = arguments[0] || {},\r\n\t\ti = 1,\r\n\t\tlength = arguments.length,\r\n\t\tdeep = false;\r\n\r\n\t// Handle a deep copy situation\r\n\tif (typeof target === \"boolean\") {\r\n\t\tdeep = target;\r\n\r\n\t\t// Skip the boolean and the target\r\n\t\ttarget = arguments[i] || {};\r\n\t\ti++;\r\n\t}\r\n\r\n\t// Handle case when target is a string or something (possible in deep copy)\r\n\tif (typeof target !== \"object\" && !DependencyLib.isFunction(target)) {\r\n\t\ttarget = {};\r\n\t}\r\n\r\n\t// Extend jQuery itself if only one argument is passed\r\n\tif (i === length) {\r\n\t\ttarget = this;\r\n\t\ti--;\r\n\t}\r\n\r\n\tfor (; i < length; i++) {\r\n\t\t// Only deal with non-null/undefined values\r\n\t\tif ((options = arguments[i]) != null) {\r\n\t\t\t// Extend the base object\r\n\t\t\tfor (name in options) {\r\n\t\t\t\tsrc = target[name];\r\n\t\t\t\tcopy = options[name];\r\n\r\n\t\t\t\t// Prevent never-ending loop\r\n\t\t\t\tif (target === copy) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Recurse if we're merging plain objects or arrays\r\n\t\t\t\tif (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy)))) {\r\n\t\t\t\t\tif (copyIsArray) {\r\n\t\t\t\t\t\tcopyIsArray = false;\r\n\t\t\t\t\t\tclone = src && DependencyLib.isArray(src) ? src : [];\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclone = src && DependencyLib.isPlainObject(src) ? src : {};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Never move original objects, clone them\r\n\t\t\t\t\ttarget[name] = DependencyLib.extend(deep, clone, copy);\r\n\r\n\t\t\t\t\t// Don't bring in undefined values\r\n\t\t\t\t} else if (copy !== undefined) {\r\n\t\t\t\t\ttarget[name] = copy;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Return the modified object\r\n\treturn target;\r\n};\r\n\r\nDependencyLib.each = function (obj, callback) {\r\n\tvar value, i = 0;\r\n\r\n\tif (isArraylike(obj)) {\r\n\t\tfor (var length = obj.length; i < length; i++) {\r\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\t\t\tif (value === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor (i in obj) {\r\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\r\n\t\t\tif (value === false) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn obj;\r\n};\r\n\r\nDependencyLib.data = function (owner, key, value) {\r\n\tif (value === undefined) {\r\n\t\treturn owner.__data ? owner.__data[key] : null;\r\n\t} else {\r\n\t\towner.__data = owner.__data || {};\r\n\t\towner.__data[key] = value;\r\n\t}\r\n};\r\n\r\nif (typeof window.CustomEvent === \"function\") {\r\n\tDependencyLib.Event = window.CustomEvent;\r\n} else {\r\n\tDependencyLib.Event = function (event, params) {\r\n\t\tparams = params || {bubbles: false, cancelable: false, detail: undefined};\r\n\t\tvar evt = document.createEvent(\"CustomEvent\");\r\n\t\tevt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n\t\treturn evt;\r\n\t};\r\n\tDependencyLib.Event.prototype = window.Event.prototype;\r\n}\r\n\r\nmodule.exports = DependencyLib;\r\n","if (typeof define === \"function\" && define.amd)\r\n\tdefine(function () {\r\n\t\treturn typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\t});\r\nelse if (typeof exports === \"object\")\r\n\tmodule.exports = typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\r\n\r\n","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\");\r\n\r\nfunction generateMaskSet(opts, nocache) {\r\n\tvar ms;\r\n\r\n\tfunction generateMask(mask, metadata, opts) {\r\n\t\tvar regexMask = false;\r\n\t\tif (mask === null || mask === \"\") {\r\n\t\t\tregexMask = opts.regex !== null;\r\n\t\t\tif (regexMask) {\r\n\t\t\t\tmask = opts.regex;\r\n\t\t\t\tmask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\");\r\n\t\t\t} else {\r\n\t\t\t\tregexMask = true;\r\n\t\t\t\tmask = \".*\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\r\n\t\t\topts.placeholder = \"\";\r\n\t\t} //hide placeholder with single non-greedy mask\r\n\t\tif (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\r\n\t\t\tvar repeatStart = opts.repeat === \"*\" ? 0 : (opts.repeat === \"+\" ? 1 : opts.repeat);\r\n\t\t\tmask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\r\n\t\t}\r\n\r\n\t\t// console.log(mask);\r\n\t\tvar masksetDefinition, maskdefKey;\r\n\t\tmaskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\r\n\t\tif (opts.keepStatic !== false) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache\r\n\t\t\tmaskdefKey = \"ks_\" + maskdefKey;\r\n\t\t}\r\n\r\n\t\tif (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\r\n\t\t\tmasksetDefinition = {\r\n\t\t\t\t\"mask\": mask,\r\n\t\t\t\t\"maskToken\": Inputmask.prototype.analyseMask(mask, regexMask, opts),\r\n\t\t\t\t\"validPositions\": {},\r\n\t\t\t\t\"_buffer\": undefined,\r\n\t\t\t\t\"buffer\": undefined,\r\n\t\t\t\t\"tests\": {},\r\n\t\t\t\t\"excludes\": {}, //excluded alternations\r\n\t\t\t\t\"metadata\": metadata,\r\n\t\t\t\t\"maskLength\": undefined,\r\n\t\t\t\t\"jitOffset\": {}\r\n\t\t\t};\r\n\t\t\tif (nocache !== true) {\r\n\t\t\t\tInputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\r\n\t\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\r\n\t\t}\r\n\r\n\t\treturn masksetDefinition;\r\n\t}\r\n\r\n\tif ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\r\n\t\topts.mask = opts.mask(opts);\r\n\t}\r\n\tif ($.isArray(opts.mask)) {\r\n\t\tif (opts.mask.length > 1) {\r\n\t\t\tif (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified\r\n\t\t\t\topts.keepStatic = \"auto\";\r\n\t\t\t\tfor (var i = 0; i < opts.mask.length; i++) {\r\n\t\t\t\t\tif (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\r\n\t\t\t\t\t\topts.keepStatic = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar altMask = opts.groupmarker[0];\r\n\t\t\t$.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\r\n\t\t\t\tif (altMask.length > 1) {\r\n\t\t\t\t\taltMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\r\n\t\t\t\t}\r\n\t\t\t\tif (msk.mask !== undefined && !$.isFunction(msk.mask)) {\r\n\t\t\t\t\taltMask += msk.mask;\r\n\t\t\t\t} else {\r\n\t\t\t\t\taltMask += msk;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\taltMask += opts.groupmarker[1];\r\n\t\t\t// console.log(altMask);\r\n\t\t\treturn generateMask(altMask, opts.mask, opts);\r\n\t\t} else {\r\n\t\t\topts.mask = opts.mask.pop();\r\n\t\t}\r\n\t}\r\n\r\n\tif (opts.keepStatic === null) opts.keepStatic = false;\r\n\tif (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\r\n\t\tms = generateMask(opts.mask.mask, opts.mask, opts);\r\n\t} else {\r\n\t\tms = generateMask(opts.mask, opts.mask, opts);\r\n\t}\r\n\r\n\treturn ms;\r\n}\r\n\r\nfunction analyseMask(mask, regexMask, opts) {\r\n\tvar tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\r\n\t\t//Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex\r\n\t\tregexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\r\n\t\tescaped = false,\r\n\t\tcurrentToken = new MaskToken(),\r\n\t\tmatch,\r\n\t\tm,\r\n\t\topenenings = [],\r\n\t\tmaskTokens = [],\r\n\t\topeningToken,\r\n\t\tcurrentOpeningToken,\r\n\t\talternator,\r\n\t\tlastMatch,\r\n\t\tcloseRegexGroup = false;\r\n\r\n\tfunction MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n\t\tthis.matches = [];\r\n\t\tthis.openGroup = isGroup || false;\r\n\t\tthis.alternatorGroup = false;\r\n\t\tthis.isGroup = isGroup || false;\r\n\t\tthis.isOptional = isOptional || false;\r\n\t\tthis.isQuantifier = isQuantifier || false;\r\n\t\tthis.isAlternator = isAlternator || false;\r\n\t\tthis.quantifier = {\r\n\t\t\tmin: 1,\r\n\t\t\tmax: 1\r\n\t\t};\r\n\t}\r\n\r\n\t//test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}\r\n\tfunction insertTestDefinition(mtoken, element, position) {\r\n\t\tposition = position !== undefined ? position : mtoken.matches.length;\r\n\t\tvar prevMatch = mtoken.matches[position - 1];\r\n\t\tif (regexMask) {\r\n\t\t\tif (element.indexOf(\"[\") === 0 || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || element === \".\") {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: new RegExp(element, opts.casing ? \"i\" : \"\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: element,\r\n\t\t\t\t\tplaceholder: undefined,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tif (escaped) element = element[element.length - 1];\r\n\t\t\t\t$.each(element.split(\"\"), function (ndx, lmnt) {\r\n\t\t\t\t\tprevMatch = mtoken.matches[position - 1];\r\n\t\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\t\tstatic: true,\r\n\t\t\t\t\t\toptionality: false,\r\n\t\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== lmnt && prevMatch.static !== true),\r\n\t\t\t\t\t\tcasing: null,\r\n\t\t\t\t\t\tdef: opts.staticDefinitionSymbol || lmnt,\r\n\t\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\r\n\t\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + lmnt\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tescaped = false;\r\n\t\t} else {\r\n\t\t\tvar maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\r\n\t\t\tif (maskdef && !escaped) {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\r\n\t\t\t\t\t\tthis.test = maskdef.validator;\r\n\t\t\t\t\t} : new RegExp(\".\"),\r\n\t\t\t\t\tstatic: false,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\r\n\t\t\t\t\tcasing: maskdef.casing,\r\n\t\t\t\t\tdef: maskdef.definitionSymbol || element,\r\n\t\t\t\t\tplaceholder: maskdef.placeholder,\r\n\t\t\t\t\tnativeDef: element\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tmtoken.matches.splice(position++, 0, {\r\n\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== element && prevMatch.static !== true),\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: opts.staticDefinitionSymbol || element,\r\n\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\r\n\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + element\r\n\t\t\t\t});\r\n\t\t\t\tescaped = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction verifyGroupMarker(maskToken) {\r\n\t\tif (maskToken && maskToken.matches) {\r\n\t\t\t$.each(maskToken.matches, function (ndx, token) {\r\n\t\t\t\tvar nextToken = maskToken.matches[ndx + 1];\r\n\t\t\t\tif ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert\r\n\t\t\t\t\ttoken.isGroup = false;\r\n\t\t\t\t\tif (!regexMask) {\r\n\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[0], 0);\r\n\t\t\t\t\t\tif (token.openGroup !== true) {\r\n\t\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tverifyGroupMarker(token);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction defaultCase() {\r\n\t\tif (openenings.length > 0) {\r\n\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\tinsertTestDefinition(currentOpeningToken, m);\r\n\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator a | b case\r\n\t\t\t\talternator = openenings.pop();\r\n\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\tif (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t}\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tinsertTestDefinition(currentToken, m);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reverseTokens(maskToken) {\r\n\t\tfunction reverseStatic(st) {\r\n\t\t\tif (st === opts.optionalmarker[0]) {\r\n\t\t\t\tst = opts.optionalmarker[1];\r\n\t\t\t} else if (st === opts.optionalmarker[1]) {\r\n\t\t\t\tst = opts.optionalmarker[0];\r\n\t\t\t} else if (st === opts.groupmarker[0]) {\r\n\t\t\t\tst = opts.groupmarker[1];\r\n\t\t\t} else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\r\n\r\n\t\t\treturn st;\r\n\t\t}\r\n\r\n\t\tmaskToken.matches = maskToken.matches.reverse();\r\n\t\tfor (var match in maskToken.matches) {\r\n\t\t\tif (Object.prototype.hasOwnProperty.call(maskToken.matches, match)) {\r\n\t\t\t\tvar intMatch = parseInt(match);\r\n\t\t\t\tif (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier\r\n\t\t\t\t\tvar qt = maskToken.matches[match];\r\n\t\t\t\t\tmaskToken.matches.splice(match, 1);\r\n\t\t\t\t\tmaskToken.matches.splice(intMatch + 1, 0, qt);\r\n\t\t\t\t}\r\n\t\t\t\tif (maskToken.matches[match].matches !== undefined) {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseTokens(maskToken.matches[match]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmaskToken.matches[match] = reverseStatic(maskToken.matches[match]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn maskToken;\r\n\t}\r\n\r\n\tfunction groupify(matches) {\r\n\t\tvar groupToken = new MaskToken(true);\r\n\t\tgroupToken.openGroup = false;\r\n\t\tgroupToken.matches = matches;\r\n\t\treturn groupToken;\r\n\t}\r\n\r\n\tfunction closeGroup() {\r\n\t\t// Group closing\r\n\t\topeningToken = openenings.pop();\r\n\t\topeningToken.openGroup = false; //mark group as complete\r\n\t\tif (openingToken !== undefined) {\r\n\t\t\tif (openenings.length > 0) {\r\n\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\tcurrentOpeningToken.matches.push(openingToken);\r\n\t\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case\r\n\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\r\n\t\t\t\t\t\talternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\r\n\t\t\t\t\t\talternator.matches[mndx].alternatorGroup = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentToken.matches.push(alternator);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcurrentToken.matches.push(openingToken);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction groupQuantifier(matches) {\r\n\t\tvar lastMatch = matches.pop();\r\n\t\tif (lastMatch.isQuantifier) {\r\n\t\t\tlastMatch = groupify([matches.pop(), lastMatch]);\r\n\t\t}\r\n\t\treturn lastMatch;\r\n\t}\r\n\r\n\tif (regexMask) {\r\n\t\topts.optionalmarker[0] = undefined;\r\n\t\topts.optionalmarker[1] = undefined;\r\n\t}\r\n\twhile ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {\r\n\t\tm = match[0];\r\n\r\n\t\tif (regexMask) {\r\n\t\t\tswitch (m.charAt(0)) {\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tcase \"?\":\r\n\t\t\t\t\tm = \"{0,1}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"+\":\r\n\t\t\t\tcase \"*\":\r\n\t\t\t\t\tm = \"{\" + m + \"}\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"|\":\r\n\t\t\t\t\t//regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])\r\n\t\t\t\t\tif (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])\r\n\t\t\t\t\t\tvar altRegexGroup = groupify(currentToken.matches);\r\n\t\t\t\t\t\taltRegexGroup.openGroup = true;\r\n\t\t\t\t\t\topenenings.push(altRegexGroup);\r\n\t\t\t\t\t\tcurrentToken.matches = [];\r\n\t\t\t\t\t\tcloseRegexGroup = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (escaped) {\r\n\t\t\tdefaultCase();\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tswitch (m.charAt(0)) {\r\n\t\t\tcase \"(?=\": //lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?!\": //negative lookahead\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<=\": //lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"(?<!\": //negative lookbehind\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.escapeChar:\r\n\t\t\t\tescaped = true;\r\n\t\t\t\tif (regexMask) {\r\n\t\t\t\t\tdefaultCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t// optional closing\r\n\t\t\tcase opts.optionalmarker[1]:\r\n\t\t\tcase opts.groupmarker[1]:\r\n\t\t\t\tcloseGroup();\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.optionalmarker[0]:\r\n\t\t\t\t// optional opening\r\n\t\t\t\topenenings.push(new MaskToken(false, true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.groupmarker[0]:\r\n\t\t\t\t// Group opening\r\n\t\t\t\topenenings.push(new MaskToken(true));\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.quantifiermarker[0]:\r\n\t\t\t\t//Quantifier\r\n\t\t\t\tvar quantifier = new MaskToken(false, false, true);\r\n\r\n\t\t\t\tm = m.replace(/[{}]/g, \"\");\r\n\t\t\t\tvar mqj = m.split(\"|\"),\r\n\t\t\t\t\tmq = mqj[0].split(\",\"),\r\n\t\t\t\t\tmq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\r\n\t\t\t\t\tmq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\r\n\t\t\t\tif (mq0 === \"*\" || mq0 === \"+\") {\r\n\t\t\t\t\tmq0 = mq1 === \"*\" ? 0 : 1;\r\n\t\t\t\t}\r\n\t\t\t\tquantifier.quantifier = {\r\n\t\t\t\t\tmin: mq0,\r\n\t\t\t\t\tmax: mq1,\r\n\t\t\t\t\tjit: mqj[1]\r\n\t\t\t\t};\r\n\t\t\t\tvar matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\r\n\t\t\t\tmatch = matches.pop();\r\n\t\t\t\tif (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}\r\n\t\t\t\t\tmatches.push(match); //push back alternator\r\n\t\t\t\t\tmatches = match.matches; //remap target matches\r\n\t\t\t\t\tvar groupToken = new MaskToken(true);\r\n\t\t\t\t\tvar tmpMatch = matches.pop();\r\n\t\t\t\t\tmatches.push(groupToken); //push the group\r\n\t\t\t\t\tmatches = groupToken.matches;\r\n\t\t\t\t\tmatch = tmpMatch;\r\n\t\t\t\t}\r\n\t\t\t\tif (!match.isGroup) {\r\n\t\t\t\t\t// if (regexMask && match.fn === null) { //why is this needed???\r\n\t\t\t\t\t//     if (match.def === \".\") match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\");\r\n\t\t\t\t\t// }\r\n\r\n\t\t\t\t\tmatch = groupify([match]);\r\n\t\t\t\t}\r\n\t\t\t\tmatches.push(match);\r\n\t\t\t\tmatches.push(quantifier);\r\n\r\n\t\t\t\tbreak;\r\n\t\t\tcase opts.alternatormarker:\r\n\r\n\r\n\t\t\t\tif (openenings.length > 0) {\r\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\r\n\t\t\t\t\tvar subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\r\n\t\t\t\t\tif (currentOpeningToken.openGroup && //regexp alt syntax\r\n\t\t\t\t\t\t(subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group\r\n\t\t\t\t\t\tlastMatch = openenings.pop();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlastMatch = groupQuantifier(currentOpeningToken.matches);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlastMatch = groupQuantifier(currentToken.matches);\r\n\t\t\t\t}\r\n\t\t\t\tif (lastMatch.isAlternator) {\r\n\t\t\t\t\topenenings.push(lastMatch);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastMatch.alternatorGroup) {\r\n\t\t\t\t\t\talternator = openenings.pop();\r\n\t\t\t\t\t\tlastMatch.alternatorGroup = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\talternator = new MaskToken(false, false, false, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t\talternator.matches.push(lastMatch);\r\n\t\t\t\t\topenenings.push(alternator);\r\n\t\t\t\t\tif (lastMatch.openGroup) { //regexp alt syntax\r\n\t\t\t\t\t\tlastMatch.openGroup = false;\r\n\t\t\t\t\t\tvar alternatorGroup = new MaskToken(true);\r\n\t\t\t\t\t\talternatorGroup.alternatorGroup = true;\r\n\t\t\t\t\t\topenenings.push(alternatorGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tdefaultCase();\r\n\t\t}\r\n\t}\r\n\r\n\tif (closeRegexGroup) closeGroup();\r\n\r\n\twhile (openenings.length > 0) {\r\n\t\topeningToken = openenings.pop();\r\n\t\tcurrentToken.matches.push(openingToken);\r\n\t}\r\n\tif (currentToken.matches.length > 0) {\r\n\t\tverifyGroupMarker(currentToken);\r\n\t\tmaskTokens.push(currentToken);\r\n\t}\r\n\r\n\tif (opts.numericInput || opts.isRTL) {\r\n\t\treverseTokens(maskTokens[0]);\r\n\t}\r\n\t// console.log(JSON.stringify(maskTokens));\r\n\treturn maskTokens;\r\n}\r\n\r\nmodule.exports = {\r\n\tgenerateMaskSet: generateMaskSet,\r\n\tanalyseMask: analyseMask\r\n};","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\r\n\tdocument = window.document,\r\n\tua = (window.navigator && window.navigator.userAgent) || \"\",\r\n\tie = (ua.indexOf(\"MSIE \") > 0) || (ua.indexOf(\"Trident/\") > 0),\r\n\tmobile = \"ontouchstart\" in window, //not entirely correct but will currently do\r\n\tiemobile = /iemobile/i.test(ua),\r\n\tiphone = /iphone/i.test(ua) && !iemobile;\r\n\r\n//masking scope\r\n//actionObj definition see below\r\nmodule.exports = function maskScope(actionObj, maskset, opts) {\r\n\tmaskset = maskset || this.maskset;\r\n\topts = opts || this.opts;\r\n\r\n\tvar inputmask = this,\r\n\t\tel = this.el,\r\n\t\tisRTL = this.isRTL || (this.isRTL = opts.numericInput),\r\n\t\tundoValue,\r\n\t\t$el,\r\n\t\tskipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\tskipInputEvent = false, //skip when triggered from within inputmask\r\n\t\tvalidationEvent = false,\r\n\t\tignorable = false,\r\n\t\tmaxLength,\r\n\t\tmouseEnter = false,\r\n\t\toriginalPlaceholder = undefined; //needed for FF\r\n\r\n\t//maskset helperfunctions\r\n\tfunction getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\r\n\t\t//includeMode true => input, undefined => placeholder, false => mask\r\n\r\n\t\tvar greedy = opts.greedy;\r\n\t\tif (clearOptionalTail) opts.greedy = false;\r\n\t\tminimalPos = minimalPos || 0;\r\n\t\tvar maskTemplate = [],\r\n\t\t\tndxIntlzr, pos = 0,\r\n\t\t\ttest, testPos;\r\n\t\tdo {\r\n\t\t\tif (baseOnInput === true && maskset.validPositions[pos]) {\r\n\t\t\t\ttestPos = (clearOptionalTail && maskset.validPositions[pos].match.optionality === true\r\n\t\t\t\t\t&& maskset.validPositions[pos + 1] === undefined\r\n\t\t\t\t\t&& (maskset.validPositions[pos].generatedInput === true || (maskset.validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))\r\n\t\t\t\t\t? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\r\n\t\t\t\t\t: maskset.validPositions[pos];\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tmaskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t} else {\r\n\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\t\ttest = testPos.match;\r\n\t\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\t\tvar jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);\r\n\t\t\t\tif (jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos)) {\r\n\t\t\t\t\tmaskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (opts.keepStatic === \"auto\") {\r\n\t\t\t\tif (test.newBlockMarker && test.static !== true) {\r\n\t\t\t\t\topts.keepStatic = pos - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpos++;\r\n\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || minimalPos > pos);\r\n\t\tif (maskTemplate[maskTemplate.length - 1] === \"\") {\r\n\t\t\tmaskTemplate.pop(); //drop the last one which is empty\r\n\t\t}\r\n\t\tif (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition\r\n\t\t\tmaskset.maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)\r\n\t\t{\r\n\t\t\tmaskset.maskLength = pos - 1;\r\n\t\t}\r\n\r\n\t\topts.greedy = greedy;\r\n\t\treturn maskTemplate;\r\n\t}\r\n\r\n\tfunction resetMaskSet(soft) {\r\n\t\tmaskset.buffer = undefined;\r\n\t\tif (soft !== true) {\r\n\t\t\tmaskset.validPositions = {};\r\n\t\t\tmaskset.p = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getLastValidPosition(closestTo, strict, validPositions) {\r\n\t\tvar before = -1,\r\n\t\t\tafter = -1,\r\n\t\t\tvalids = validPositions || maskset.validPositions; //for use in valhook ~ context switch\r\n\t\tif (closestTo === undefined) closestTo = -1;\r\n\t\tfor (var posNdx in valids) {\r\n\t\t\tvar psNdx = parseInt(posNdx);\r\n\t\t\tif (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\r\n\t\t\t\tif (psNdx <= closestTo) before = psNdx;\r\n\t\t\t\tif (psNdx >= closestTo) after = psNdx;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;\r\n\t}\r\n\r\n\tfunction getDecisionTaker(tst) {\r\n\t\tvar decisionTaker = tst.locator[tst.alternation];\r\n\t\tif (typeof decisionTaker == \"string\" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider\r\n\t\t\tdecisionTaker = decisionTaker.split(\",\")[0];\r\n\t\t}\r\n\t\treturn decisionTaker !== undefined ? decisionTaker.toString() : \"\";\r\n\t}\r\n\r\n\tfunction getLocator(tst, align) { //need to align the locators to be correct\r\n\t\tvar locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\r\n\t\tif (locator !== \"\") while (locator.length < align) locator += \"0\";\r\n\t\treturn locator;\r\n\t}\r\n\r\n\tfunction determineTestTemplate(pos, tests) {\r\n\t\tpos = pos > 0 ? pos - 1 : 0;\r\n\t\tvar altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\r\n\t\tfor (var ndx = 0; ndx < tests.length; ndx++) { //find best matching\r\n\t\t\tvar tst = tests[ndx];\r\n\t\t\ttstLocator = getLocator(tst, targetLocator.length);\r\n\t\t\tvar distance = Math.abs(tstLocator - targetLocator);\r\n\t\t\tif (closest === undefined\r\n\t\t\t\t|| (tstLocator !== \"\" && distance < closest)\r\n\t\t\t\t|| (bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker))\r\n\t\t\t\t|| (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {\r\n\t\t\t\tclosest = distance;\r\n\t\t\t\tbestMatch = tst;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bestMatch;\r\n\t}\r\n\r\n\r\n\tfunction getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n\t\treturn maskset.validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n\t}\r\n\r\n\tfunction getTest(pos, tests) {\r\n\t\tif (maskset.validPositions[pos]) {\r\n\t\t\treturn maskset.validPositions[pos];\r\n\t\t}\r\n\t\treturn (tests || getTests(pos))[0];\r\n\t}\r\n\r\n\tfunction positionCanMatchDefinition(pos, testDefinition, opts) {\r\n\t\tvar valid = false,\r\n\t\t\ttests = getTests(pos),\r\n\t\t\tdefProp = opts.shiftPositions ? \"def\" : \"nativeDef\";\r\n\t\tfor (var tndx = 0; tndx < tests.length; tndx++) {\r\n\t\t\tif (tests[tndx].match && tests[tndx].match[defProp] === testDefinition.match[defProp]) {\r\n\t\t\t\tvalid = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (valid === false) {\r\n\t\t\tif (maskset.jitOffset[pos] !== undefined) {\r\n\t\t\t\tvalid = positionCanMatchDefinition(pos + maskset.jitOffset[pos], testDefinition, opts);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn valid;\r\n\t}\r\n\r\n\r\n\tfunction getTests(pos, ndxIntlzr, tstPs) {\r\n\t\tvar maskTokens = maskset.maskToken,\r\n\t\t\ttestPos = ndxIntlzr ? tstPs : 0,\r\n\t\t\tndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\r\n\t\t\tmatches = [],\r\n\t\t\tinsertStop = false,\r\n\t\t\tlatestMatch,\r\n\t\t\tcacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n\r\n\t\tfunction resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens\r\n\t\t\tfunction handleMatch(match, loopNdx, quantifierRecurse) {\r\n\t\t\t\tfunction isFirstMatch(latestMatch, tokenGroup) {\r\n\t\t\t\t\tvar firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\r\n\t\t\t\t\tif (!firstMatch) {\r\n\t\t\t\t\t\t$.each(tokenGroup.matches, function (ndx, match) {\r\n\t\t\t\t\t\t\tif (match.isQuantifier === true) {\r\n\t\t\t\t\t\t\t\tfirstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);\r\n\t\t\t\t\t\t\t} else if (Object.prototype.hasOwnProperty.call(match, \"matches\")) firstMatch = isFirstMatch(latestMatch, match);\r\n\t\t\t\t\t\t\tif (firstMatch) return false;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn firstMatch;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\r\n\t\t\t\t\tvar bestMatch, indexPos;\r\n\r\n\t\t\t\t\tif (maskset.tests[pos] || maskset.validPositions[pos]) {\r\n\t\t\t\t\t\t$.each(maskset.tests[pos] || [maskset.validPositions[pos]], function (ndx, lmnt) {\r\n\t\t\t\t\t\t\tif (lmnt.mloc[alternateNdx]) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\treturn false; //break\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,\r\n\t\t\t\t\t\t\t\tndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\r\n\t\t\t\t\t\t\tif ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\r\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\r\n\t\t\t\t\t\t\t\tindexPos = ndxPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (bestMatch) {\r\n\t\t\t\t\t\tvar bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\r\n\t\t\t\t\t\tvar locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\r\n\t\t\t\t\t\treturn locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction isSubsetOf(source, target) {\r\n\t\t\t\t\tfunction expand(pattern) {\r\n\t\t\t\t\t\tvar expanded = [], start = -1, end;\r\n\t\t\t\t\t\tfor (var i = 0, l = pattern.length; i < l; i++) {\r\n\t\t\t\t\t\t\tif (pattern.charAt(i) === \"-\") {\r\n\t\t\t\t\t\t\t\tend = pattern.charCodeAt(i + 1);\r\n\t\t\t\t\t\t\t\twhile (++start < end) expanded.push(String.fromCharCode(start));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tstart = pattern.charCodeAt(i);\r\n\t\t\t\t\t\t\t\texpanded.push(pattern.charAt(i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn expanded.join(\"\");\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (source.match.def === target.match.nativeDef) return true;\r\n\t\t\t\t\tif ((opts.regex || (source.match.fn instanceof RegExp && target.match.fn instanceof RegExp)) && source.match.static !== true && target.match.static !== true) { //is regex a subset\r\n\t\t\t\t\t\treturn expand(target.match.fn.toString().replace(/[[\\]/]/g, \"\")).indexOf(expand(source.match.fn.toString().replace(/[[\\]/]/g, \"\"))) !== -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction staticCanMatchDefinition(source, target) {\r\n\t\t\t\t\treturn source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, maskset, pos, false, opts, false) : false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//mergelocators for retrieving the correct locator match when merging\r\n\t\t\t\tfunction setMergeLocators(targetMatch, altMatch) {\r\n\t\t\t\t\tif (altMatch === undefined || (targetMatch.alternation === altMatch.alternation &&\r\n\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1)) {\r\n\t\t\t\t\t\ttargetMatch.mloc = targetMatch.mloc || {};\r\n\t\t\t\t\t\tvar locNdx = targetMatch.locator[targetMatch.alternation];\r\n\t\t\t\t\t\tif (locNdx === undefined) {\r\n\t\t\t\t\t\t\ttargetMatch.alternation = undefined;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\r\n\t\t\t\t\t\t\tif (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\r\n\t\t\t\t\t\t\tif (altMatch !== undefined) {\r\n\t\t\t\t\t\t\t\tfor (var ndx in altMatch.mloc) {\r\n\t\t\t\t\t\t\t\t\tif (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\r\n\t\t\t\t\t\t\t\t\tif (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (testPos > 500 && quantifierRecurse !== undefined) {\r\n\t\t\t\t\tthrow \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + maskset.mask;\r\n\t\t\t\t}\r\n\t\t\t\tif (testPos === pos && match.matches === undefined) {\r\n\t\t\t\t\tmatches.push({\r\n\t\t\t\t\t\t\"match\": match,\r\n\t\t\t\t\t\t\"locator\": loopNdx.reverse(),\r\n\t\t\t\t\t\t\"cd\": cacheDependency,\r\n\t\t\t\t\t\t\"mloc\": {}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t} else if (match.matches !== undefined) {\r\n\t\t\t\t\tif (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier\r\n\t\t\t\t\t\tmatch = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isOptional) {\r\n\t\t\t\t\t\tvar optionalToken = match, mtchsNdx = matches.length;\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t//mark optionality in matches\r\n\t\t\t\t\t\t\t$.each(matches, function (ndx, mtch) {\r\n\t\t\t\t\t\t\t\tif (ndx >= mtchsNdx) {\r\n\t\t\t\t\t\t\t\t\tmtch.match.optionality = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\tif (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698\r\n\t\t\t\t\t\t\t\tinsertStop = true; //insert a stop\r\n\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (match.isAlternator) {\r\n\t\t\t\t\t\tvar alternateToken = match,\r\n\t\t\t\t\t\t\tmalternateMatches = [],\r\n\t\t\t\t\t\t\tmaltMatches,\r\n\t\t\t\t\t\t\tcurrentMatches = matches.slice(),\r\n\t\t\t\t\t\t\tloopNdxCnt = loopNdx.length;\r\n\t\t\t\t\t\tvar altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n\t\t\t\t\t\tif (altIndex === -1 || typeof altIndex === \"string\") {\r\n\t\t\t\t\t\t\tvar currentPos = testPos,\r\n\t\t\t\t\t\t\t\tndxInitializerClone = ndxInitializer.slice(),\r\n\t\t\t\t\t\t\t\taltIndexArr = [],\r\n\t\t\t\t\t\t\t\tamndx;\r\n\t\t\t\t\t\t\tif (typeof altIndex == \"string\") {\r\n\t\t\t\t\t\t\t\taltIndexArr = altIndex.split(\",\");\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.push(amndx.toString());\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (maskset.excludes[pos] !== undefined) {\r\n\t\t\t\t\t\t\t\tvar altIndexArrClone = altIndexArr.slice();\r\n\t\t\t\t\t\t\t\tfor (var i = 0, el = maskset.excludes[pos].length; i < el; i++) {\r\n\t\t\t\t\t\t\t\t\taltIndexArr.splice(altIndexArr.indexOf(maskset.excludes[pos][i].toString()), 1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (altIndexArr.length === 0) { //fully alternated => reset\r\n\t\t\t\t\t\t\t\t\tdelete maskset.excludes[pos];\r\n\t\t\t\t\t\t\t\t\taltIndexArr = altIndexArrClone;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);\r\n\t\t\t\t\t\t\tvar unMatchedAlternation = false;\r\n\t\t\t\t\t\t\tfor (var ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n\t\t\t\t\t\t\t\tamndx = parseInt(altIndexArr[ndx]);\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\t\t\t\t\t\t\t\t//set the correct ndxInitializer\r\n\t\t\t\t\t\t\t\tndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\r\n\t\t\t\t\t\t\t\tif (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)) {\r\n\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t} else if (ndx === 0) {\r\n\t\t\t\t\t\t\t\t\tunMatchedAlternation = true;\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tmaltMatches = matches.slice();\r\n\t\t\t\t\t\t\t\ttestPos = currentPos;\r\n\t\t\t\t\t\t\t\tmatches = [];\r\n\r\n\t\t\t\t\t\t\t\t//fuzzy merge matches\r\n\t\t\t\t\t\t\t\tfor (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n\t\t\t\t\t\t\t\t\tvar altMatch = maltMatches[ndx1],\r\n\t\t\t\t\t\t\t\t\t\tdropMatch = false;\r\n\t\t\t\t\t\t\t\t\taltMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: \"(a|aa)\"\r\n\t\t\t\t\t\t\t\t\taltMatch.alternation = altMatch.alternation || loopNdxCnt;\r\n\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch);\r\n\t\t\t\t\t\t\t\t\tfor (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n\t\t\t\t\t\t\t\t\t\tvar altMatch2 = malternateMatches[ndx2];\r\n\t\t\t\t\t\t\t\t\t\tif (typeof altIndex !== \"string\" || (altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch2, altMatch)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t} else if (staticCanMatchDefinition(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t//insert match above general match\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (!dropMatch) {\r\n\t\t\t\t\t\t\t\t\t\tmalternateMatches.push(altMatch);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tmatches = currentMatches.concat(malternateMatches);\r\n\t\t\t\t\t\t\ttestPos = pos;\r\n\t\t\t\t\t\t\tinsertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option\r\n\t\t\t\t\t\t\tmatch = malternateMatches.length > 0; //set correct match state\r\n\r\n\t\t\t\t\t\t\t//cloneback\r\n\t\t\t\t\t\t\tndxInitializer = ndxInitializerClone.slice();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tmatch = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\r\n\t\t\t\t\t\tvar qt = match;\r\n\t\t\t\t\t\tfor (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\r\n\t\t\t\t\t\t\tvar tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n\t\t\t\t\t\t\tmatch = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker\r\n\t\t\t\t\t\t\tif (match) {\r\n\t\t\t\t\t\t\t\t//get latest match\r\n\t\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\r\n\t\t\t\t\t\t\t\t//mark optionality\r\n\t\t\t\t\t\t\t\t//TODO FIX RECURSIVE QUANTIFIERS\r\n\t\t\t\t\t\t\t\tlatestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\r\n\t\t\t\t\t\t\t\t// console.log(pos + \" \" + qt.quantifier.min + \" \" + latestMatch.optionalQuantifier);\r\n\t\t\t\t\t\t\t\tlatestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\r\n\t\t\t\t\t\t\t\tif (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\r\n\t\t\t\t\t\t\t\t\tinsertStop = true;\r\n\t\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\r\n\t\t\t\t\t\t\t\t\tbreak; //stop quantifierloop && search for next possible match\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {\r\n\t\t\t\t\t\t\t\t\t//always set jitOffset, isvalid checks when to apply\r\n\t\t\t\t\t\t\t\t\tmaskset.jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\r\n\t\t\t\t\t\tif (match) return true;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttestPos++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//the offset is set in the quantifierloop when git masking is used\r\n\t\t\tfor (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {\r\n\t\t\t\tif (maskToken.matches[tndx].isQuantifier !== true) {\r\n\t\t\t\t\tvar match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\r\n\t\t\t\t\tif (match && testPos === pos) {\r\n\t\t\t\t\t\treturn match;\r\n\t\t\t\t\t} else if (testPos > pos) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction mergeLocators(pos, tests) {\r\n\t\t\tvar locator = [];\r\n\t\t\tif (!$.isArray(tests)) tests = [tests];\r\n\t\t\tif (tests.length > 0) {\r\n\t\t\t\tif (tests[0].alternation === undefined || opts.keepStatic === true) {\r\n\t\t\t\t\tlocator = determineTestTemplate(pos, tests.slice()).locator.slice();\r\n\t\t\t\t\tif (locator.length === 0) locator = tests[0].locator.slice();\r\n\t\t\t\t} else {\r\n\t\t\t\t\t$.each(tests, function (ndx, tst) {\r\n\t\t\t\t\t\tif (tst.def !== \"\") {\r\n\t\t\t\t\t\t\tif (locator.length === 0) {\r\n\t\t\t\t\t\t\t\tlocator = tst.locator.slice();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tfor (var i = 0; i < locator.length; i++) {\r\n\t\t\t\t\t\t\t\t\tif (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\r\n\t\t\t\t\t\t\t\t\t\tlocator[i] += \",\" + tst.locator[i];\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn locator;\r\n\t\t}\r\n\r\n\t\tif (pos > -1 && (maxLength === undefined || pos < maxLength)) {\r\n\t\t\tif (ndxIntlzr === undefined) { //determine index initializer\r\n\t\t\t\tvar previousPos = pos - 1,\r\n\t\t\t\t\ttest;\r\n\t\t\t\twhile ((test = maskset.validPositions[previousPos] || maskset.tests[previousPos]) === undefined && previousPos > -1) {\r\n\t\t\t\t\tpreviousPos--;\r\n\t\t\t\t}\r\n\t\t\t\tif (test !== undefined && previousPos > -1) {\r\n\t\t\t\t\tndxInitializer = mergeLocators(previousPos, test);\r\n\t\t\t\t\tcacheDependency = ndxInitializer.join(\"\");\r\n\t\t\t\t\ttestPos = previousPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (maskset.tests[pos] && maskset.tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first\r\n\t\t\t\treturn maskset.tests[pos];\r\n\t\t\t}\r\n\t\t\tfor (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n\t\t\t\tvar match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\r\n\t\t\t\tif ((match && testPos === pos) || testPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (matches.length === 0 || insertStop) {\r\n\t\t\tmatches.push({\r\n\t\t\t\tmatch: {\r\n\t\t\t\t\tfn: null,\r\n\t\t\t\t\tstatic: true,\r\n\t\t\t\t\toptionality: false,\r\n\t\t\t\t\tcasing: null,\r\n\t\t\t\t\tdef: \"\",\r\n\t\t\t\t\tplaceholder: \"\"\r\n\t\t\t\t},\r\n\t\t\t\tlocator: [],\r\n\t\t\t\tmloc: {},\r\n\t\t\t\tcd: cacheDependency\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (ndxIntlzr !== undefined && maskset.tests[pos]) { //prioritize full tests for caching\r\n\t\t\treturn $.extend(true, [], matches);\r\n\t\t}\r\n\t\tmaskset.tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props\r\n\t\t// console.log(pos + \" - \" + JSON.stringify(matches));\r\n\t\treturn maskset.tests[pos];\r\n\t}\r\n\r\n\tfunction getBufferTemplate() {\r\n\t\tif (maskset._buffer === undefined) {\r\n\t\t\t//generate template\r\n\t\t\tmaskset._buffer = getMaskTemplate(false, 1);\r\n\t\t\tif (maskset.buffer === undefined) maskset.buffer = maskset._buffer.slice();\r\n\t\t}\r\n\t\treturn maskset._buffer;\r\n\t}\r\n\r\n\tfunction getBuffer(noCache) {\r\n\t\tif (maskset.buffer === undefined || noCache === true) {\r\n\t\t\tmaskset.buffer = getMaskTemplate(true, getLastValidPosition(), true);\r\n\t\t\tif (maskset._buffer === undefined) maskset._buffer = maskset.buffer.slice();\r\n\t\t}\r\n\t\treturn maskset.buffer;\r\n\t}\r\n\r\n\tfunction refreshFromBuffer(start, end, buffer) {\r\n\t\tvar i, p, skipOptionalPartCharacter = opts.skipOptionalPartCharacter;\r\n\t\topts.skipOptionalPartCharacter = \"\";\r\n\t\tif (start === true) {\r\n\t\t\tresetMaskSet();\r\n\t\t\tmaskset.tests = {}; //refresh tests after possible alternating\r\n\t\t\tstart = 0;\r\n\t\t\tend = buffer.length;\r\n\t\t} else {\r\n\t\t\tfor (i = start; i < end; i++) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tp = start;\r\n\t\tfor (i = start; i < end; i++) {\r\n\t\t\tvar valResult = isValid(p, buffer[i], opts.negationSymbol ? buffer[i] !== opts.negationSymbol.front : true, opts.negationSymbol ? buffer[i] !== opts.negationSymbol.front : true);  //hackery for + validator (numeric alias)\r\n\t\t\tif (valResult !== false) {\r\n\t\t\t\tp = (valResult.caret !== undefined && valResult.caret > valResult.pos) ? valResult.caret : valResult.pos + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.skipOptionalPartCharacter = skipOptionalPartCharacter;\r\n\t}\r\n\r\n\tfunction casing(elem, test, pos) {\r\n\t\tswitch (opts.casing || test.casing) {\r\n\t\t\tcase \"upper\":\r\n\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"lower\":\r\n\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"title\":\r\n\t\t\t\tvar posBefore = maskset.validPositions[pos - 1];\r\n\t\t\t\tif (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\r\n\t\t\t\t\telem = elem.toUpperCase();\r\n\t\t\t\t} else {\r\n\t\t\t\t\telem = elem.toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tif ($.isFunction(opts.casing)) {\r\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\t\targs.push(maskset.validPositions);\r\n\t\t\t\t\telem = opts.casing.apply(this, args);\r\n\t\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn elem;\r\n\t}\r\n\r\n\tfunction checkAlternationMatch(altArr1, altArr2, na) {\r\n\t\tvar altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\r\n\t\t\tisMatch = false,\r\n\t\t\tnaArr = na !== undefined ? na.split(\",\") : [],\r\n\t\t\tnaNdx;\r\n\r\n\t\t//remove no alternate indexes from alternation array\r\n\t\tfor (var i = 0; i < naArr.length; i++) {\r\n\t\t\tif ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\r\n\t\t\t\taltArr1.splice(naNdx, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var alndx = 0; alndx < altArr1.length; alndx++) {\r\n\t\t\tif ($.inArray(altArr1[alndx], altArrC) !== -1) {\r\n\t\t\t\tisMatch = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isMatch;\r\n\t}\r\n\r\n\tfunction alternate(maskPos, c, strict, fromIsValid, rAltPos, selection) { //pos == true => generalize\r\n\t\tvar validPsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\ttstClone = $.extend(true, {}, maskset.tests),\r\n\t\t\tlastAlt,\r\n\t\t\talternation,\r\n\t\t\tisValidRslt = false, returnRslt = false,\r\n\t\t\taltPos, prevAltPos, i, validPos,\r\n\t\t\tdecisionPos,\r\n\t\t\tlAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition(), nextPos, input, begin, end;\r\n\r\n\t\tif (selection) {\r\n\t\t\tbegin = selection.begin;\r\n\t\t\tend = selection.end;\r\n\t\t\tif (selection.begin > selection.end) {\r\n\t\t\t\tbegin = selection.end;\r\n\t\t\t\tend = selection.begin;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning\r\n\t\t\tlastAlt = 0;\r\n\t\t\tprevAltPos = getTest(lastAlt);\r\n\t\t\talternation = prevAltPos.alternation;\r\n\t\t} else {\r\n\t\t\t//find last modified alternation\r\n\t\t\tfor (; lAltPos >= 0; lAltPos--) {\r\n\t\t\t\taltPos = maskset.validPositions[lAltPos];\r\n\t\t\t\tif (altPos && altPos.alternation !== undefined) {\r\n\t\t\t\t\tif (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlastAlt = lAltPos;\r\n\t\t\t\t\talternation = maskset.validPositions[lastAlt].alternation;\r\n\t\t\t\t\tprevAltPos = altPos;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (alternation !== undefined) {\r\n\t\t\tdecisionPos = parseInt(lastAlt);\r\n\t\t\tmaskset.excludes[decisionPos] = maskset.excludes[decisionPos] || [];\r\n\t\t\tif (maskPos !== true) { //generalize\r\n\t\t\t\tmaskset.excludes[decisionPos].push(getDecisionTaker(prevAltPos));\r\n\t\t\t}\r\n\r\n\t\t\tvar validInputs = [], resultPos = -1;\r\n\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\r\n\t\t\t\tif (resultPos === -1 && maskPos <= i && c !== undefined) {\r\n\t\t\t\t\tvalidInputs.push(c);\r\n\t\t\t\t\tresultPos = validInputs.length - 1;\r\n\t\t\t\t}\r\n\t\t\t\tvalidPos = maskset.validPositions[i];\r\n\t\t\t\tif (validPos && validPos.generatedInput !== true && (selection === undefined || (i < begin || i >= end))) {\r\n\t\t\t\t\tvalidInputs.push(validPos.input);\r\n\t\t\t\t}\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t}\r\n\t\t\tif (resultPos === -1 && c !== undefined) {\r\n\t\t\t\tvalidInputs.push(c);\r\n\t\t\t\tresultPos = validInputs.length - 1;\r\n\t\t\t}\r\n\r\n\t\t\twhile (maskset.excludes[decisionPos] !== undefined && maskset.excludes[decisionPos].length < 10) {\r\n\t\t\t\tmaskset.tests[decisionPos] = undefined; //clear decisionPos\r\n\t\t\t\tresetMaskSet(true); //clear getbuffer\r\n\t\t\t\tisValidRslt = true;\r\n\t\t\t\tfor (i = 0; i < validInputs.length; i++) {\r\n\t\t\t\t\tnextPos = isValidRslt.caret || (getLastValidPosition(undefined, true) + 1);\r\n\t\t\t\t\tinput = validInputs[i];\r\n\t\t\t\t\tif (!(isValidRslt = isValid(nextPos, input, false, fromIsValid, true))) {\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (i === resultPos) {\r\n\t\t\t\t\t\treturnRslt = isValidRslt;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!isValidRslt) {\r\n\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\tprevAltPos = getTest(decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation\r\n\t\t\t\t\t//reset & revert\r\n\t\t\t\t\tmaskset.validPositions = $.extend(true, {}, validPsClone);\r\n\t\t\t\t\tmaskset.tests = $.extend(true, {}, tstClone); //refresh tests after possible alternating\r\n\t\t\t\t\tif (maskset.excludes[decisionPos]) {\r\n\t\t\t\t\t\tvar decisionTaker = getDecisionTaker(prevAltPos);\r\n\t\t\t\t\t\tif (maskset.excludes[decisionPos].indexOf(decisionTaker) !== -1) {\r\n\t\t\t\t\t\t\treturnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmaskset.excludes[decisionPos].push(decisionTaker);\r\n\t\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete maskset.validPositions[i];\r\n\t\t\t\t\t} else { //latest alternation\r\n\t\t\t\t\t\treturnRslt = alternate(maskPos, c, strict, fromIsValid, decisionPos - 1, selection);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//reset alternation excludes\r\n\t\tdelete maskset.excludes[decisionPos];\r\n\t\treturn returnRslt;\r\n\t}\r\n\r\n\tfunction isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill\r\n\t\tfunction isSelection(posObj) {\r\n\t\t\treturn isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :\r\n\t\t\t\t(posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);\r\n\t\t}\r\n\r\n\t\tstrict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions\r\n\r\n\t\tvar maskPos = pos;\r\n\t\tif (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection\r\n\t\t\tmaskPos = isRTL ? pos.end : pos.begin;\r\n\t\t}\r\n\r\n\t\tfunction processCommandObject(commandObj) {\r\n\t\t\tif (commandObj !== undefined) {\r\n\t\t\t\tif (commandObj.remove !== undefined) { //remove position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];\r\n\t\t\t\t\t$.each(commandObj.remove.sort(function (a, b) {\r\n\t\t\t\t\t\treturn b.pos - a.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\trevalidateMask({begin: lmnt, end: lmnt + 1});\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.remove = undefined;\r\n\t\t\t\t}\r\n\t\t\t\tif (commandObj.insert !== undefined) { //insert position(s)\r\n\t\t\t\t\tif (!$.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];\r\n\t\t\t\t\t$.each(commandObj.insert.sort(function (a, b) {\r\n\t\t\t\t\t\treturn a.pos - b.pos;\r\n\t\t\t\t\t}), function (ndx, lmnt) {\r\n\t\t\t\t\t\tif (lmnt.c !== \"\") {\r\n\t\t\t\t\t\t\tisValid(lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcommandObj.insert = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.refreshFromBuffer && commandObj.buffer) {\r\n\t\t\t\t\tvar refresh = commandObj.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);\r\n\t\t\t\t\tcommandObj.refreshFromBuffer = undefined;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (commandObj.rewritePosition !== undefined) {\r\n\t\t\t\t\tmaskPos = commandObj.rewritePosition;\r\n\t\t\t\t\t// commandObj.rewritePosition = undefined;\r\n\t\t\t\t\tcommandObj = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn commandObj;\r\n\t\t}\r\n\r\n\t\tfunction _isValid(position, c, strict) {\r\n\t\t\tvar rslt = false;\r\n\r\n\t\t\t$.each(getTests(position), function (ndx, tst) {\r\n\t\t\t\tvar test = tst.match;\r\n\t\t\t\t//make sure the buffer is set and correct\r\n\t\t\t\tgetBuffer(true);\r\n\t\t\t\t//return is false or a json object => { pos: ??, c: ??} or true\r\n\t\t\t\trslt = test.fn != null ?\r\n\t\t\t\t\ttest.fn.test(c, maskset, position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? //non mask\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc: getPlaceholder(position, test, true) || test.def,\r\n\t\t\t\t\t\t\tpos: position\r\n\t\t\t\t\t\t} : false;\r\n\r\n\t\t\t\tif (rslt !== false) {\r\n\t\t\t\t\tvar elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\r\n\t\t\t\t\telem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?\r\n\t\t\t\t\t\t(getPlaceholder(position, test, true) || test.def) : elem;\r\n\r\n\t\t\t\t\trslt = processCommandObject(rslt);\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset\r\n\t\t\t\t\t\tvalidatedPos = rslt.pos;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\r\n\t\t\t\t\t\treturn false; //breakout if nothing to insert\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (revalidateMask(pos, $.extend({}, tst, {\r\n\t\t\t\t\t\t\"input\": casing(elem, test, validatedPos)\r\n\t\t\t\t\t}), fromIsValid, validatedPos) === false) {\r\n\t\t\t\t\t\trslt = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false; //break from $.each\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn rslt;\r\n\t\t}\r\n\r\n\t\tvar result = true,\r\n\t\t\tpositionsClone = $.extend(true, {}, maskset.validPositions); //clone the currentPositions\r\n\r\n\t\tif ($.isFunction(opts.preValidation) && !strict && fromIsValid !== true && validateOnly !== true && fromAlternate !== true) {\r\n\t\t\tresult = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, maskset, pos);\r\n\t\t\tresult = processCommandObject(result);\r\n\t\t}\r\n\t\tif (result === true) { //preValidation result\r\n\t\t\tif (maxLength === undefined || maskPos < maxLength) {\r\n\t\t\t\tresult = _isValid(maskPos, c, strict);\r\n\t\t\t\tif ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {\r\n\t\t\t\t\tvar currentPosValid = maskset.validPositions[maskPos];\r\n\t\t\t\t\tif (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\r\n\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\"caret\": seekNext(maskPos)\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (opts.insertMode || maskset.validPositions[seekNext(maskPos)] === undefined || pos.end > maskPos) { //does the input match on a further position?\r\n\t\t\t\t\t\t\tvar skip = false;\r\n\t\t\t\t\t\t\tif (maskset.jitOffset[maskPos] && maskset.validPositions[seekNext(maskPos)] === undefined) {\r\n\t\t\t\t\t\t\t\tresult = isValid(maskPos + maskset.jitOffset[maskPos], c, true);\r\n\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\tif (fromAlternate !== true) result.caret = maskPos;\r\n\t\t\t\t\t\t\t\t\tskip = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (pos.end > maskPos) {\r\n\t\t\t\t\t\t\t\tmaskset.validPositions[maskPos] = undefined;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!skip && !isMask(maskPos, true)) {\r\n\t\t\t\t\t\t\t\tfor (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\r\n\t\t\t\t\t\t\t\t\t// if (!isMask(nPos, true)) {\r\n\t\t\t\t\t\t\t\t\t// \tcontinue;\r\n\t\t\t\t\t\t\t\t\t// }\r\n\t\t\t\t\t\t\t\t\tresult = _isValid(nPos, c, strict);\r\n\t\t\t\t\t\t\t\t\tif (result !== false) {\r\n\t\t\t\t\t\t\t\t\t\tresult = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\r\n\t\t\t\t\t\t\t\t\t\tmaskPos = nPos;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t\tif (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) { //try fuzzy alternator logic\r\n\t\t\t\tresult = alternate(maskPos, c, strict, fromIsValid, undefined, pos);\r\n\t\t\t}\r\n\t\t\tif (result === true) {\r\n\t\t\t\tresult = {\r\n\t\t\t\t\t\"pos\": maskPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ($.isFunction(opts.postValidation) && result !== false && !strict && fromIsValid !== true && validateOnly !== true) {\r\n\t\t\tvar postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? (isRTL ? pos.end : pos.begin) : pos, result, opts, maskset);\r\n\t\t\tif (postResult !== undefined) {\r\n\t\t\t\tresult = postResult === true ? result : postResult;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (result && result.pos === undefined) {\r\n\t\t\tresult.pos = maskPos;\r\n\t\t}\r\n\r\n\t\tif (result === false || validateOnly === true) {\r\n\t\t\tresetMaskSet(true);\r\n\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone); //revert validation changes\r\n\t\t} else {\r\n\t\t\ttrackbackPositions(undefined, maskPos, true);\r\n\t\t}\r\n\r\n\t\tvar endResult = processCommandObject(result);\r\n\t\t// console.log(\"returned result \" + JSON.stringify(endResult));\r\n\t\treturn endResult;\r\n\t}\r\n\r\n\t//fill in best positions according the current input\r\n\tfunction trackbackPositions(originalPos, newPos, fillOnly) {\r\n\t\t// console.log(\"trackbackPositions \" + originalPos + \" \" + newPos);\r\n\t\tif (originalPos === undefined) {\r\n\t\t\t//find previous valid\r\n\t\t\tfor (originalPos = newPos - 1; originalPos > 0; originalPos--) {\r\n\t\t\t\tif (maskset.validPositions[originalPos]) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var ps = originalPos; ps < newPos; ps++) {\r\n\t\t\tif (maskset.validPositions[ps] === undefined && !isMask(ps, true)) {\r\n\t\t\t\tvar vp = ps == 0 ? getTest(ps) : maskset.validPositions[ps - 1];\r\n\t\t\t\tif (vp) {\r\n\t\t\t\t\tvar tests = getTests(ps).slice();\r\n\t\t\t\t\tif (tests[tests.length - 1].match.def === \"\") tests.pop();\r\n\t\t\t\t\tvar bestMatch = determineTestTemplate(ps, tests), np;\r\n\t\t\t\t\tif (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === \"master\" && (np = maskset.validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {\r\n\t\t\t\t\t\tbestMatch = $.extend({}, bestMatch, {\r\n\t\t\t\t\t\t\t\"input\": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbestMatch.generatedInput = true;\r\n\t\t\t\t\t\trevalidateMask(ps, bestMatch, true);\r\n\r\n\t\t\t\t\t\tif (fillOnly !== true) {\r\n\t\t\t\t\t\t\t//revalidate the new position to update the locator value\r\n\t\t\t\t\t\t\tvar cvpInput = maskset.validPositions[newPos].input;\r\n\t\t\t\t\t\t\tmaskset.validPositions[newPos] = undefined;\r\n\t\t\t\t\t\t\treturn isValid(newPos, cvpInput, true, true);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction revalidateMask(pos, validTest, fromIsValid, validatedPos) {\r\n\t\tfunction IsEnclosedStatic(pos, valids, selection) {\r\n\t\t\tvar posMatch = valids[pos];\r\n\t\t\tif (posMatch !== undefined && posMatch.match.static === true && posMatch.match.optionality !== true && (valids[0] === undefined || valids[0].alternation === undefined)) {\r\n\t\t\t\tvar prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],\r\n\t\t\t\t\tnextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];\r\n\t\t\t\treturn prevMatch && nextMatch;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar offset = 0, begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\r\n\t\tif (pos.begin > pos.end) {\r\n\t\t\tbegin = pos.end;\r\n\t\t\tend = pos.begin;\r\n\t\t}\r\n\t\tif (validTest === undefined && opts.insertMode === false && end < maskset.maskLength) {\r\n\t\t\tif (begin !== 0 || end !== 0) {\r\n\t\t\t\tbegin += 1;\r\n\t\t\t\tend += 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvalidatedPos = validatedPos !== undefined ? validatedPos : begin;\r\n\t\tif (begin !== end || (opts.insertMode && maskset.validPositions[validatedPos] !== undefined && fromIsValid === undefined) || validTest === undefined) {\r\n\t\t\t//reposition & revalidate others\r\n\t\t\tvar positionsClone = $.extend(true, {}, maskset.validPositions),\r\n\t\t\t\tlvp = (validTest === undefined && opts.insertMode === false) ? (end > 1 ? end - 1 : end) : getLastValidPosition(undefined, true),\r\n\t\t\t\ti;\r\n\t\t\tmaskset.p = begin; //needed for alternated position after overtype selection\r\n\r\n\t\t\tfor (i = lvp; i >= begin; i--) {\r\n\t\t\t\tdelete maskset.validPositions[i];\r\n\t\t\t\tif (validTest === undefined) delete maskset.tests[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tvar valid = true, j = validatedPos,\r\n\t\t\t\tposMatch = j, t;\r\n\t\t\ti = j;\r\n\r\n\t\t\tif (validTest) {\r\n\t\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t\t\tposMatch++;\r\n\t\t\t\tj++;\r\n\t\t\t\tif (begin < end) i++; //if selection and entry move start by one\r\n\t\t\t}\r\n\t\t\tif (validTest || opts.insertMode) {\r\n\t\t\t\tfor (; i <= lvp; i++) {\r\n\t\t\t\t\tif ((t = positionsClone[i]) !== undefined && t.generatedInput !== true &&\r\n\t\t\t\t\t\t(i >= end || (i >= begin && IsEnclosedStatic(i, positionsClone, {\r\n\t\t\t\t\t\t\tbegin: begin,\r\n\t\t\t\t\t\t\tend: end\r\n\t\t\t\t\t\t})))) {\r\n\t\t\t\t\t\twhile (getTest(posMatch).match.def !== \"\") { //loop needed to match further positions\r\n\t\t\t\t\t\t\tif (positionCanMatchDefinition(posMatch, t, opts) || t.match.def === \"+\") { //validated match //we still need some hackery for the + validator (numeric alias)\r\n\t\t\t\t\t\t\t\tif (t.match.def === \"+\") getBuffer(true);\r\n\t\t\t\t\t\t\t\tvar result = isValid(posMatch, t.input, t.match.def !== \"+\", t.match.def !== \"+\");\r\n\t\t\t\t\t\t\t\tvalid = result !== false;\r\n\t\t\t\t\t\t\t\tj = (result.pos || posMatch) + 1;\r\n\t\t\t\t\t\t\t\tif (!valid) break;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (valid) {\r\n\t\t\t\t\t\t\t\tif (validTest === undefined && t.match.static && i === pos.begin) offset++;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (!valid && posMatch > maskset.maskLength) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tposMatch++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (getTest(posMatch).match.def == \"\") {\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//restore position\r\n\t\t\t\t\t\tposMatch = j;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!valid) break;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!valid) {\r\n\t\t\t\tmaskset.validPositions = $.extend(true, {}, positionsClone);\r\n\t\t\t\tresetMaskSet(true);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else if (validTest) {\r\n\t\t\tmaskset.validPositions[validatedPos] = $.extend(true, {}, validTest);\r\n\t\t}\r\n\r\n\t\tresetMaskSet(true);\r\n\t\treturn offset;\r\n\t}\r\n\r\n\tfunction isMask(pos, strict, fuzzy) {\r\n\t\tvar test = getTestTemplate(pos).match;\r\n\t\tif (test.def === \"\") test = getTest(pos).match;\r\n\r\n\t\tif (test.static !== true) {\r\n\t\t\treturn test.fn;\r\n\t\t}\r\n\t\tif (fuzzy === true && (maskset.validPositions[pos] !== undefined && maskset.validPositions[pos].generatedInput !== true)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (strict !== true && pos > -1) {\r\n\t\t\tvar tests = getTests(pos);\r\n\t\t\treturn tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction seekNext(pos, newBlock) {\r\n\t\tvar position = pos + 1;\r\n\t\twhile (getTest(position).match.def !== \"\" &&\r\n\t\t((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position, undefined, true))) ||\r\n\t\t\t(newBlock !== true && !isMask(position, undefined, true)))) {\r\n\t\t\tposition++;\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction seekPrevious(pos, newBlock) {\r\n\t\tvar position = pos,\r\n\t\t\ttests;\r\n\t\tif (position <= 0) return 0;\r\n\r\n\t\twhile (--position > 0 &&\r\n\t\t((newBlock === true && getTest(position).match.newBlockMarker !== true) ||\r\n\t\t\t(newBlock !== true && !isMask(position, undefined, true) &&\r\n\t\t\t\t// eslint-disable-next-line no-empty\r\n\t\t\t\t(tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === \"\"))))) {\r\n\t\t}\r\n\t\treturn position;\r\n\t}\r\n\r\n\tfunction writeBuffer(input, buffer, caretPos, event, triggerEvents) {\r\n\t\tif (event && $.isFunction(opts.onBeforeWrite)) {\r\n\t\t\t//    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer\r\n\t\t\tvar result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\r\n\t\t\tif (result) {\r\n\t\t\t\tif (result.refreshFromBuffer) {\r\n\t\t\t\t\tvar refresh = result.refreshFromBuffer;\r\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\r\n\t\t\t\t\tbuffer = getBuffer(true);\r\n\t\t\t\t}\r\n\t\t\t\tif (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (input !== undefined) {\r\n\t\t\tinput.inputmask._valueSet(buffer.join(\"\"));\r\n\t\t\tif (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\r\n\t\t\t\tcaret(input, caretPos);\r\n\t\t\t}\r\n\t\t\tif (triggerEvents === true) {\r\n\t\t\t\tvar $input = $(input), nptVal = input.inputmask._valueGet();\r\n\t\t\t\tskipInputEvent = true;\r\n\t\t\t\t$input.trigger(\"input\");\r\n\t\t\t\tsetTimeout(function () { //timeout needed for IE\r\n\t\t\t\t\tif (nptVal === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t$input.trigger(\"cleared\");\r\n\t\t\t\t\t} else if (isComplete(buffer) === true) {\r\n\t\t\t\t\t\t$input.trigger(\"complete\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPlaceholder(pos, test, returnPL) {\r\n\t\ttest = test || getTest(pos).match;\r\n\t\tif (test.placeholder !== undefined || returnPL === true) {\r\n\t\t\treturn $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\r\n\t\t} else if (test.static === true) {\r\n\t\t\tif (pos > -1 && maskset.validPositions[pos] === undefined) {\r\n\t\t\t\tvar tests = getTests(pos),\r\n\t\t\t\t\tstaticAlternations = [],\r\n\t\t\t\t\tprevTest;\r\n\t\t\t\tif (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\r\n\t\t\t\t\tfor (var i = 0; i < tests.length; i++) {\r\n\t\t\t\t\t\tif (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&\r\n\t\t\t\t\t\t\t(tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, maskset, pos, true, opts) !== false))) {\r\n\t\t\t\t\t\t\tstaticAlternations.push(tests[i]);\r\n\t\t\t\t\t\t\tif (tests[i].match.static === true) prevTest = tests[i];\r\n\t\t\t\t\t\t\tif (staticAlternations.length > 1) {\r\n\t\t\t\t\t\t\t\tif (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\r\n\t\t\t\t\t\t\t\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn test.def;\r\n\t\t}\r\n\r\n\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\r\n\t}\r\n\r\n\tfunction HandleNativePlaceholder(npt, value) {\r\n\t\tif (ie) {\r\n\t\t\tif (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === \"\")) {\r\n\t\t\t\tvar buffer = getBuffer().slice(),\r\n\t\t\t\t\tnptValue = npt.inputmask._valueGet();\r\n\t\t\t\tif (nptValue !== value) {\r\n\t\t\t\t\tvar lvp = getLastValidPosition();\r\n\t\t\t\t\tif (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else if (lvp !== -1) { //clearout optional tail of the mask\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriteBuffer(npt, buffer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (npt.placeholder !== value) {\r\n\t\t\tnpt.placeholder = value;\r\n\t\t\tif (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineNewCaretPosition(selectedCaret, tabbed) {\r\n\t\tfunction doRadixFocus(clickPos) {\r\n\t\t\tif (opts.radixPoint !== \"\" && opts.digits !== 0) {\r\n\t\t\t\tvar vps = maskset.validPositions;\r\n\t\t\t\tif (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {\r\n\t\t\t\t\tif (clickPos < seekNext(-1)) return true;\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n\t\t\t\t\tif (radixPos !== -1) {\r\n\t\t\t\t\t\tfor (var vp in vps) {\r\n\t\t\t\t\t\t\tif (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (tabbed) {\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tselectedCaret.end = selectedCaret.begin;\r\n\t\t\t} else {\r\n\t\t\t\tselectedCaret.begin = selectedCaret.end;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedCaret.begin === selectedCaret.end) {\r\n\t\t\tswitch (opts.positionCaretOnClick) {\r\n\t\t\t\tcase \"none\":\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\treturn {begin: 0, end: getBuffer().length};\r\n\t\t\t\tcase \"ignore\":\r\n\t\t\t\t\treturn seekNext(getLastValidPosition());\r\n\t\t\t\tcase \"radixFocus\":\r\n\t\t\t\t\tif (doRadixFocus(selectedCaret.begin)) {\r\n\t\t\t\t\t\tvar radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\r\n\t\t\t\t\t\treturn opts.numericInput ? seekNext(radixPos) : radixPos;\r\n\t\t\t\t\t} //fallback to lvp\r\n\t\t\t\t// eslint-disable-next-line no-fallthrough\r\n\t\t\t\tdefault: //lvp:\r\n\t\t\t\t\tvar clickPosition = selectedCaret.begin,\r\n\t\t\t\t\t\tlvclickPosition = getLastValidPosition(clickPosition, true),\r\n\t\t\t\t\t\tlastPosition = seekNext((lvclickPosition === -1 && !isMask(0)) ? 0 : lvclickPosition);\r\n\t\t\t\t\tif (clickPosition < lastPosition) {\r\n\t\t\t\t\t\treturn !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar lvp = maskset.validPositions[lvclickPosition],\r\n\t\t\t\t\t\t\ttt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),\r\n\t\t\t\t\t\t\tplaceholder = getPlaceholder(lastPosition, tt.match);\r\n\t\t\t\t\t\tif ((placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)) {\r\n\t\t\t\t\t\t\tvar newPos = seekNext(lastPosition);\r\n\t\t\t\t\t\t\tif (clickPosition >= newPos || clickPosition === lastPosition) {\r\n\t\t\t\t\t\t\t\tlastPosition = newPos;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn lastPosition;\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvar EventRuler = {\r\n\t\ton: function (input, eventName, eventHandler) {\r\n\t\t\tvar ev = function (e) {\r\n\t\t\t\tvar that = this, args;\r\n\t\t\t\tif (that.inputmask === undefined && this.nodeName !== \"FORM\") { //happens when cloning an object with jquery.clone\r\n\t\t\t\t\tvar imOpts = $.data(that, \"_inputmask_opts\");\r\n\t\t\t\t\tif (imOpts) {\r\n\t\t\t\t\t\t(new Inputmask(imOpts)).mask(that);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tEventRuler.off(that);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || (that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\t\tcase \"input\":\r\n\t\t\t\t\t\t\tif (skipInputEvent === true || (e.originalEvent && e.originalEvent.inputType === \"insertCompositionText\")) {\r\n\t\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (mobile) {\r\n\t\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\t\tsetTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818\r\n\t\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t\t\tcaret(that, that.inputmask.caretPos, undefined, true);\r\n\t\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keydown\":\r\n\t\t\t\t\t\t\t//Safari 5.1.x - modal dialog fires keypress twice workaround\r\n\t\t\t\t\t\t\tskipKeyPressEvent = false;\r\n\t\t\t\t\t\t\tskipInputEvent = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"keypress\":\r\n\t\t\t\t\t\t\tif (skipKeyPressEvent === true) {\r\n\t\t\t\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tskipKeyPressEvent = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"click\":\r\n\t\t\t\t\t\tcase \"focus\":\r\n\t\t\t\t\t\t\tif (validationEvent) { // #841\r\n\t\t\t\t\t\t\t\tvalidationEvent = false;\r\n\t\t\t\t\t\t\t\tinput.blur();\r\n\t\t\t\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t\t\tinput.focus();\r\n\t\t\t\t\t\t\t\t}, 3000);\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\targs = arguments;\r\n\t\t\t\t\t\t\tsetTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent\r\n\t\t\t\t\t\t\t\teventHandler.apply(that, args);\r\n\t\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar returnVal = eventHandler.apply(that, arguments);\r\n\t\t\t\t\tif (returnVal === false) {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t\te.stopPropagation();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn returnVal;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t//keep instance of the event\r\n\t\t\tinput.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\r\n\t\t\tinput.inputmask.events[eventName].push(ev);\r\n\r\n\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\r\n\t\t\t\tif (input.form !== null) $(input.form).on(eventName, ev);\r\n\t\t\t} else {\r\n\t\t\t\t$(input).on(eventName, ev);\r\n\t\t\t}\r\n\t\t},\r\n\t\toff: function (input, event) {\r\n\t\t\tif (input.inputmask && input.inputmask.events) {\r\n\t\t\t\tvar events;\r\n\t\t\t\tif (event) {\r\n\t\t\t\t\tevents = [];\r\n\t\t\t\t\tevents[event] = input.inputmask.events[event];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tevents = input.inputmask.events;\r\n\t\t\t\t}\r\n\t\t\t\t$.each(events, function (eventName, evArr) {\r\n\t\t\t\t\twhile (evArr.length > 0) {\r\n\t\t\t\t\t\tvar ev = evArr.pop();\r\n\t\t\t\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\",]) !== -1) {\r\n\t\t\t\t\t\t\tif (input.form !== null) $(input.form).off(eventName, ev);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$(input).off(eventName, ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete input.inputmask.events[eventName];\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tvar EventHandlers = {\r\n\t\tkeydownEvent: function (e, fromInputFallback) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.keyCode,\r\n\t\t\t\tpos = caret(input);\r\n\r\n\t\t\tvar kdResult = opts.onKeyDown.call(this, e, getBuffer(), pos, opts);\r\n\t\t\tif (kdResult !== undefined) return kdResult;\r\n\r\n\t\t\t//backspace, delete, and escape get special treatment\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !(\"oncut\" in input))) { //backspace/delete\r\n\t\t\t\te.preventDefault(); //stop default action but allow propagation\r\n\t\t\t\thandleRemove(input, k, pos);\r\n\t\t\t\twriteBuffer(input, getBuffer(true), fromInputFallback === true && opts.insertMode === false ? seekPrevious(maskset.p) : maskset.p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\r\n\t\t\t} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tvar caretPos = seekNext(getLastValidPosition());\r\n\t\t\t\tcaret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\r\n\t\t\t} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\tcaret(input, 0, e.shiftKey ? pos.begin : 0, true);\r\n\t\t\t} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762\r\n\t\t\t\tcheckVal(input, true, false, undoValue.split(\"\"));\r\n\t\t\t\t$input.trigger(\"click\");\r\n\t\t\t\t// } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey) && inputmask.userOptions.insertMode === undefined) { //insert\r\n\t\t\t\t// \topts.insertMode = !opts.insertMode;\r\n\t\t\t\t// \tcaret(input, pos.begin, pos.end);\r\n\t\t\t} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\r\n\t\t\t\tif (e.shiftKey === true) {\r\n\t\t\t\t\tif (getTest(pos.begin).match.static === true) {\r\n\t\t\t\t\t\tpos.begin = seekNext(pos.begin);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpos.end = seekPrevious(pos.begin, true);\r\n\t\t\t\t\tpos.begin = seekPrevious(pos.end, true);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpos.begin = seekNext(pos.begin, true);\r\n\t\t\t\t\tpos.end = seekNext(pos.begin, true);\r\n\t\t\t\t\tif (pos.end < maskset.maskLength) pos.end--;\r\n\t\t\t\t}\r\n\t\t\t\tif (pos.begin < maskset.maskLength) {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tcaret(input, pos.begin, pos.end);\r\n\t\t\t\t}\r\n\t\t\t} else if (!e.shiftKey) {\r\n\t\t\t\tif (opts.insertMode === false) {\r\n\t\t\t\t\tif (k === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\t\t\t\tcaret(input, caretPos.begin);\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t} else if (k === Inputmask.keyCode.LEFT) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\tvar caretPos = {\r\n\t\t\t\t\t\t\t\tbegin: translatePosition(input.inputmask.caretPos.begin),\r\n\t\t\t\t\t\t\t\tend: translatePosition(input.inputmask.caretPos.end)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif (isRTL) {\r\n\t\t\t\t\t\t\t\tcaret(input, caretPos.begin + (caretPos.begin === maskset.maskLength ? 0 : 1));\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, caretPos.begin - (caretPos.begin === 0 ? 0 : 1));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tignorable = $.inArray(k, opts.ignorables) !== -1;\r\n\t\t},\r\n\t\tkeypressEvent: function (e, checkval, writeOut, strict, ndx) {\r\n\t\t\tvar input = this,\r\n\t\t\t\t$input = $(input),\r\n\t\t\t\tk = e.which || e.charCode || e.keyCode;\r\n\r\n\t\t\tif (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\r\n\t\t\t\tif (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t// e.preventDefault();\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t} else if (k) {\r\n\t\t\t\t//special treat the decimal separator\r\n\t\t\t\tif (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\r\n\t\t\t\tvar pos = checkval ? {\r\n\t\t\t\t\t\tbegin: ndx,\r\n\t\t\t\t\t\tend: ndx\r\n\t\t\t\t\t} : caret(input),\r\n\t\t\t\t\tforwardPosition, c = String.fromCharCode(k);\r\n\r\n\t\t\t\tmaskset.writeOutBuffer = true;\r\n\t\t\t\tvar valResult = isValid(pos, c, strict);\r\n\t\t\t\tif (valResult !== false) {\r\n\t\t\t\t\tresetMaskSet(true);\r\n\t\t\t\t\tforwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\r\n\t\t\t\t\tmaskset.p = forwardPosition; //needed for checkval\r\n\t\t\t\t}\r\n\r\n\t\t\t\tforwardPosition = ((opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition);\r\n\t\t\t\tif (writeOut !== false) {\r\n\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\topts.onKeyValidation.call(input, k, valResult, opts);\r\n\t\t\t\t\t}, 0);\r\n\t\t\t\t\tif (maskset.writeOutBuffer && valResult !== false) {\r\n\t\t\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\t\t\twriteBuffer(input, buffer, forwardPosition, e, checkval !== true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\te.preventDefault();\r\n\r\n\t\t\t\tif (checkval) {\r\n\t\t\t\t\tif (valResult !== false) valResult.forwardPosition = forwardPosition;\r\n\t\t\t\t\treturn valResult;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpasteEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tev = e.originalEvent || e,\r\n\t\t\t\tinputValue = input.inputmask._valueGet(true),\r\n\t\t\t\tcaretPos = caret(input),\r\n\t\t\t\ttempValue;\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\ttempValue = caretPos.end;\r\n\t\t\t\tcaretPos.end = caretPos.begin;\r\n\t\t\t\tcaretPos.begin = tempValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar valueBeforeCaret = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\tvalueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n\r\n\t\t\tif (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\r\n\t\t\tif (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\r\n\r\n\t\t\tif (window.clipboardData && window.clipboardData.getData) { // IE\r\n\t\t\t\tinputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\r\n\t\t\t} else if (ev.clipboardData && ev.clipboardData.getData) {\r\n\t\t\t\tinputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n\t\t\t} else {\r\n\t\t\t\treturn true;\r\n\t\t\t} //allow native paste event as fallback ~ masking will continue by inputfallback\r\n\r\n\t\t\tvar pasteValue = inputValue;\r\n\t\t\tif ($.isFunction(opts.onBeforePaste)) {\r\n\t\t\t\tpasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\r\n\t\t\t\tif (pasteValue === false) {\r\n\t\t\t\t\treturn e.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t\tif (!pasteValue) {\r\n\t\t\t\t\tpasteValue = inputValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcheckVal(input, false, false, pasteValue.toString().split(\"\"));\r\n\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\r\n\t\t\treturn e.preventDefault();\r\n\t\t},\r\n\t\tinputFallBackEvent: function (e) { //fallback when keypress is not triggered\r\n\t\t\tfunction radixPointHandler(input, inputValue, caretPos) {\r\n\t\t\t\t//radixpoint tweak\r\n\t\t\t\tif (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\r\n\t\t\t\t\tinputValue = inputValue.split(\"\");\r\n\t\t\t\t\tinputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\r\n\t\t\t\t\tinputValue = inputValue.join(\"\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction ieMobileHandler(input, inputValue, caretPos) {\r\n\t\t\t\tif (iemobile) { //iemobile just sets the character at the end althought the caret position is correctly set\r\n\t\t\t\t\tvar inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n\t\t\t\t\tif (inputChar.length === 1) {\r\n\t\t\t\t\t\tvar iv = inputValue.split(\"\");\r\n\t\t\t\t\t\tiv.splice(caretPos.begin, 0, inputChar);\r\n\t\t\t\t\t\tinputValue = iv.join(\"\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn inputValue;\r\n\t\t\t}\r\n\r\n\t\t\tvar input = this,\r\n\t\t\t\tinputValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\r\n\t\t\t\tvar caretPos = caret(input);\r\n\t\t\t\tinputValue = radixPointHandler(input, inputValue, caretPos);\r\n\t\t\t\tinputValue = ieMobileHandler(input, inputValue, caretPos);\r\n\r\n\t\t\t\tif (getBuffer().join(\"\") !== inputValue) {\r\n\t\t\t\t\tvar buffer = getBuffer().join(\"\"),\r\n\t\t\t\t\t\toffset = (!opts.numericInput && inputValue.length > buffer.length) ? -1 : 0,\r\n\t\t\t\t\t\tfrontPart = inputValue.substr(0, caretPos.begin),\r\n\t\t\t\t\t\tbackPart = inputValue.substr(caretPos.begin),\r\n\t\t\t\t\t\tfrontBufferPart = buffer.substr(0, caretPos.begin + offset),\r\n\t\t\t\t\t\tbackBufferPart = buffer.substr(caretPos.begin + offset);\r\n\r\n\t\t\t\t\t//check if thare was a selection\r\n\t\t\t\t\tvar selection = caretPos,\r\n\t\t\t\t\t\tentries = \"\",\r\n\t\t\t\t\t\tisEntry = false;\r\n\t\t\t\t\tif (frontPart !== frontBufferPart) {\r\n\t\t\t\t\t\tvar fpl = ((isEntry = frontPart.length >= frontBufferPart.length)) ? frontPart.length : frontBufferPart.length,\r\n\t\t\t\t\t\t\ti;\r\n\t\t\t\t\t\tfor (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\r\n\t\t\t\t\t\tif (isEntry) {\r\n\t\t\t\t\t\t\tselection.begin = i - offset;\r\n\t\t\t\t\t\t\tentries += frontPart.slice(i, selection.end);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (backPart !== backBufferPart) {\r\n\t\t\t\t\t\tif (backPart.length > backBufferPart.length) {\r\n\t\t\t\t\t\t\tentries += backPart.slice(0, 1);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (backPart.length < backBufferPart.length) {\r\n\t\t\t\t\t\t\t\tselection.end += backBufferPart.length - backPart.length;\r\n\t\t\t\t\t\t\t\t//hack around numeric alias & radixpoint\r\n\t\t\t\t\t\t\t\tif (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\r\n\t\t\t\t\t\t\t\t\tselection.begin--;\r\n\t\t\t\t\t\t\t\t\tentries = opts.radixPoint;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), {\r\n\t\t\t\t\t\t\"begin\": selection.begin + offset,\r\n\t\t\t\t\t\t\"end\": selection.end + offset\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif (entries.length > 0) {\r\n\t\t\t\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\t\t\t\t//set caret\r\n\t\t\t\t\t\t\tinput.focus();\r\n\t\t\t\t\t\t\tcaret(input, selection);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t$.each(entries.split(\"\"), function (ndx, entry) {\r\n\t\t\t\t\t\t\tvar keypress = new $.Event(\"keypress\");\r\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\tselection.begin = seekPrevious(selection.begin + 1);\r\n\t\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcaret(input, selection.begin, selection.end);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar keydown = new $.Event(\"keydown\");\r\n\t\t\t\t\t\tkeydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\r\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcompositionendEvent: function (e) {\r\n\t\t\t$el.trigger(\"input\");\r\n\t\t},\r\n\t\t// beforeInputEvent: function (e) {\r\n\t\t// \tif (e.cancelable) {\r\n\t\t// \t\tvar input = this, keydown, keypress;\r\n\t\t// \t\tswitch (e.inputType) {\r\n\t\t// \t\t\tcase \"insertText\":\r\n\t\t// \t\t\t\t$.each(e.data.split(\"\"), function (ndx, entry) {\r\n\t\t// \t\t\t\t\tkeypress = new $.Event(\"keypress\");\r\n\t\t// \t\t\t\t\tkeypress.which = entry.charCodeAt(0);\r\n\t\t// \t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\r\n\t\t// \t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\r\n\t\t// \t\t\t\t});\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t\tcase \"deleteContentBackward\":\r\n\t\t// \t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t// \t\t\t\tkeydown.keyCode = Inputmask.keyCode.BACKSPACE;\r\n\t\t// \t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t\tcase \"deleteContentForward\":\r\n\t\t// \t\t\t\tkeydown = new $.Event(\"keydown\");\r\n\t\t// \t\t\t\tkeydown.keyCode = Inputmask.keyCode.DELETE;\r\n\t\t// \t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\r\n\t\t// \t\t\t\treturn e.preventDefault();\r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// },\r\n\t\tsetValueEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tvalue = (e && e.detail) ? e.detail[0] : arguments[1];\r\n\r\n\t\t\tif (value === undefined) {\r\n\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t}\r\n\r\n\t\t\tapplyInputValue(input, value);\r\n\r\n\t\t\tif ((e.detail && e.detail[1] !== undefined) || arguments[2] !== undefined) {\r\n\t\t\t\tcaret(input, e.detail ? e.detail[1] : arguments[2]);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfocusEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tnptValue = input.inputmask._valueGet();\r\n\r\n\t\t\tif (opts.showMaskOnFocus) {\r\n\t\t\t\tif (nptValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\r\n\t\t\t\t} /*else if (mouseEnter === false) { //only executed on focus without mouseenter\r\n\t\t\t\t\tcaret(input, seekNext(getLastValidPosition()));\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\t\t\tif (opts.positionCaretOnTab === true && mouseEnter === false && (!isComplete(getBuffer()) || getLastValidPosition() === -1)) {\r\n\t\t\t\tEventHandlers.clickEvent.apply(input, [e, true]);\r\n\t\t\t}\r\n\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t},\r\n\t\tinvalidEvent: function (e) {\r\n\t\t\tvalidationEvent = true;\r\n\t\t},\r\n\t\tmouseleaveEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = false;\r\n\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== input) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t}\r\n\t\t},\r\n\t\tclickEvent: function (e, tabbed) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (document.activeElement === input) {\r\n\t\t\t\tvar newCaretPosition = determineNewCaretPosition(caret(input), tabbed);\r\n\t\t\t\tif (newCaretPosition !== undefined) {\r\n\t\t\t\t\tcaret(input, newCaretPosition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tcutEvent: function (e) {\r\n\t\t\tvar input = this,\r\n\t\t\t\tpos = caret(input),\r\n\t\t\t\tev = e.originalEvent || e;\r\n\r\n\t\t\t//correct clipboardData\r\n\t\t\tvar clipboardData = window.clipboardData || ev.clipboardData,\r\n\t\t\t\tclipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n\t\t\tclipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\r\n\t\t\tif (document.execCommand) document.execCommand(\"copy\"); // copy selected content to system clipbaord\r\n\r\n\t\t\thandleRemove(input, Inputmask.keyCode.DELETE, pos);\r\n\t\t\twriteBuffer(input, getBuffer(), maskset.p, e, undoValue !== getBuffer().join(\"\"));\r\n\t\t},\r\n\t\tblurEvent: function (e) {\r\n\t\t\tvar $input = $(this),\r\n\t\t\t\tinput = this;\r\n\t\t\tif (input.inputmask) {\r\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\r\n\t\t\t\tvar nptValue = input.inputmask._valueGet(),\r\n\t\t\t\t\tbuffer = getBuffer().slice();\r\n\r\n\t\t\t\tif (nptValue !== \"\") {\r\n\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\tif (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\r\n\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t} else { //clearout optional tail of the mask\r\n\t\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\t\t\t$input.trigger(\"incomplete\");\r\n\t\t\t\t\t\t}, 0);\r\n\t\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer = getBufferTemplate().slice();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twriteBuffer(input, buffer, undefined, e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\r\n\t\t\t\t\t$input.trigger(\"change\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tmouseenterEvent: function () {\r\n\t\t\tvar input = this;\r\n\t\t\tmouseEnter = true;\r\n\t\t\tif (document.activeElement !== input) {\r\n\t\t\t\tif (originalPlaceholder == undefined && input.placeholder !== originalPlaceholder) {\r\n\t\t\t\t\toriginalPlaceholder = input.placeholder;\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.showMaskOnHover) {\r\n\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tsubmitEvent: function () { //trigger change on submit if any\r\n\t\t\tif (undoValue !== getBuffer().join(\"\")) {\r\n\t\t\t\t$el.trigger(\"change\");\r\n\t\t\t}\r\n\t\t\tif (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\r\n\t\t\t\tel.inputmask._valueSet(\"\"); //clear masktemplete on submit and still has focus\r\n\t\t\t}\r\n\t\t\tif (opts.clearIncomplete && isComplete(getBuffer()) === false) {\r\n\t\t\t\tel.inputmask._valueSet(\"\");\r\n\t\t\t}\r\n\t\t\tif (opts.removeMaskOnSubmit) {\r\n\t\t\t\tel.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\r\n\t\t\t\tsetTimeout(function () {\r\n\t\t\t\t\twriteBuffer(el, getBuffer());\r\n\t\t\t\t}, 0);\r\n\t\t\t}\r\n\t\t},\r\n\t\tresetEvent: function () {\r\n\t\t\tel.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn\r\n\t\t\tsetTimeout(function () {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true));\r\n\t\t\t}, 0);\r\n\t\t},\r\n\t};\r\n\r\n\tfunction checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\r\n\t\tvar inputmask = this || input.inputmask,\r\n\t\t\tinputValue = nptvl.slice(),\r\n\t\t\tcharCodes = \"\",\r\n\t\t\tinitialNdx = -1,\r\n\t\t\tresult = undefined;\r\n\r\n\t\t// console.log(nptvl);\r\n\r\n\t\tfunction isTemplateMatch(ndx, charCodes) {\r\n\t\t\tif (opts.regex) return false;\r\n\t\t\tvar targetTemplate = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"),\r\n\t\t\t\tcharCodeNdx = targetTemplate.indexOf(charCodes);\r\n\t\t\t//strip spaces from targetTemplate\r\n\t\t\twhile (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === \" \") charCodeNdx--;\r\n\r\n\t\t\tvar match = charCodeNdx === 0 && !isMask(ndx)\r\n\t\t\t\t&& (getTest(ndx).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t|| (getTest(ndx).match.static === true && getTest(ndx).match.nativeDef === (\"'\" + charCodes.charAt(0)))\r\n\t\t\t\t\t|| (getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0)\r\n\t\t\t\t\t\t|| (getTest(ndx + 1).match.static === true && getTest(ndx + 1).match.nativeDef === (\"'\" + charCodes.charAt(0))))));\r\n\r\n\t\t\tif (!match && charCodeNdx > 0) inputmask.caretPos = {begin: seekNext(charCodeNdx)};\r\n\t\t\treturn match;\r\n\t\t}\r\n\r\n\t\tresetMaskSet();\r\n\t\tinitialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0;\r\n\t\tmaskset.p = initialNdx;\r\n\t\tinputmask.caretPos = {begin: initialNdx};\r\n\r\n\t\tvar staticMatches = [], prevCaretPos = inputmask.caretPos;\r\n\t\t$.each(inputValue, function (ndx, charCode) {\r\n\t\t\tif (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined\r\n\t\t\t\tif (maskset.validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&\r\n\t\t\t\t\tisValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\r\n\t\t\t\t\tmaskset.p++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\");\r\n\t\t\t\t\tkeypress.which = charCode.charCodeAt(0);\r\n\t\t\t\t\tcharCodes += charCode;\r\n\t\t\t\t\tvar lvp = getLastValidPosition(undefined, true);\r\n\t\t\t\t\tif (!isTemplateMatch(initialNdx, charCodes)) {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\r\n\r\n\t\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\t\tinitialNdx = inputmask.caretPos.begin + 1;\r\n\t\t\t\t\t\t\tcharCodes = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result) {\r\n\t\t\t\t\t\tif (result.pos !== undefined && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t\tif (!isRTL) {\r\n\t\t\t\t\t\t\t\tresult.forwardPosition = result.pos + 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twriteBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\r\n\t\t\t\t\t\tinputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};\r\n\t\t\t\t\t\tprevCaretPos = inputmask.caretPos;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tinputmask.caretPos = prevCaretPos;\r\n\t\t\t\t\t}  //restore the caret position from before the failed validation\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (staticMatches.length > 0) {\r\n\t\t\tvar sndx, validPos, nextValid;\r\n\t\t\tif (!isComplete(getBuffer()) || staticMatches.length < seekNext(0)) {\r\n\t\t\t\twhile ((sndx = staticMatches.pop()) !== undefined) {\r\n\t\t\t\t\tif (sndx !== staticMatches.length) {\r\n\t\t\t\t\t\tvar keypress = new $.Event(\"_checkval\"),\r\n\t\t\t\t\t\t\tnextSndx = sndx + 1;\r\n\r\n\t\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t\tkeypress.which = validPos.input.charCodeAt(0);\r\n\t\t\t\t\t\twhile ((nextValid = maskset.validPositions[nextSndx]) && nextValid.input === validPos.input) {\r\n\t\t\t\t\t\t\tnextSndx++;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, nextSndx);\r\n\t\t\t\t\t\tif (result && result.pos !== undefined && result.pos !== sndx && maskset.validPositions[result.pos] && maskset.validPositions[result.pos].match.static === true) {\r\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { //mark al statics as generated\r\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\r\n\t\t\t\t\tvalidPos = maskset.validPositions[sndx];\r\n\t\t\t\t\tif (validPos) {\r\n\t\t\t\t\t\tvalidPos.generatedInput = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (writeOut) {\r\n\t\t\twriteBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unmaskedvalue(input) {\r\n\t\tif (input) {\r\n\t\t\tif (input.inputmask === undefined) {\r\n\t\t\t\treturn input.value;\r\n\t\t\t}\r\n\t\t\tif (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset\r\n\t\t\t\tapplyInputValue(input, input.inputmask._valueGet(true));\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar umValue = [],\r\n\t\t\tvps = maskset.validPositions;\r\n\t\tfor (var pndx in vps) {\r\n\t\t\tif (vps[pndx] && vps[pndx].match && vps[pndx].match.static != true) {\r\n\t\t\t\tumValue.push(vps[pndx].input);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n\t\tif ($.isFunction(opts.onUnMask)) {\r\n\t\t\tvar bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n\t\t\tunmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\r\n\t\t}\r\n\t\treturn unmaskedValue;\r\n\t}\r\n\r\n\tfunction translatePosition(pos) {\r\n\t\tif (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\r\n\t\t\tpos = el.inputmask._valueGet().length - pos;\r\n\t\t}\r\n\t\treturn pos;\r\n\t}\r\n\r\n\tfunction caret(input, begin, end, notranslate) {\r\n\t\tvar range;\r\n\t\tif (begin !== undefined) {\r\n\t\t\tif ($.isArray(begin)) {\r\n\t\t\t\tend = isRTL ? begin[0] : begin[1];\r\n\t\t\t\tbegin = isRTL ? begin[1] : begin[0];\r\n\t\t\t}\r\n\t\t\tif (begin.begin !== undefined) {\r\n\t\t\t\tend = isRTL ? begin.begin : begin.end;\r\n\t\t\t\tbegin = isRTL ? begin.end : begin.begin;\r\n\t\t\t}\r\n\t\t\tif (typeof begin === \"number\") {\r\n\t\t\t\tbegin = notranslate ? begin : translatePosition(begin);\r\n\t\t\t\tend = notranslate ? end : translatePosition(end);\r\n\t\t\t\tend = (typeof end == \"number\") ? end : begin;\r\n\t\t\t\t// if (!$(input).is(\":visible\")) {\r\n\t\t\t\t// \treturn;\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tvar scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n\t\t\t\tinput.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\r\n\t\t\t\tinput.inputmask.caretPos = {begin: begin, end: end}; //track caret internally\r\n\t\t\t\tif (opts.insertMode === false && begin === end) end++; //set visualization for insert/overwrite mode\r\n\t\t\t\tif (input === document.activeElement) {\r\n\t\t\t\t\tif (\"setSelectionRange\" in input) {\r\n\t\t\t\t\t\tinput.setSelectionRange(begin, end);\r\n\t\t\t\t\t} else if (window.getSelection) {\r\n\t\t\t\t\t\trange = document.createRange();\r\n\t\t\t\t\t\tif (input.firstChild === undefined || input.firstChild === null) {\r\n\t\t\t\t\t\t\tvar textNode = document.createTextNode(\"\");\r\n\t\t\t\t\t\t\tinput.appendChild(textNode);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trange.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\tvar sel = window.getSelection();\r\n\t\t\t\t\t\tsel.removeAllRanges();\r\n\t\t\t\t\t\tsel.addRange(range);\r\n\t\t\t\t\t\t//input.focus();\r\n\t\t\t\t\t} else if (input.createTextRange) {\r\n\t\t\t\t\t\trange = input.createTextRange();\r\n\t\t\t\t\t\trange.collapse(true);\r\n\t\t\t\t\t\trange.moveEnd(\"character\", end);\r\n\t\t\t\t\t\trange.moveStart(\"character\", begin);\r\n\t\t\t\t\t\trange.select();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (\"selectionStart\" in input && \"selectionEnd\" in input) {\r\n\t\t\t\tbegin = input.selectionStart;\r\n\t\t\t\tend = input.selectionEnd;\r\n\t\t\t} else if (window.getSelection) {\r\n\t\t\t\trange = window.getSelection().getRangeAt(0);\r\n\t\t\t\tif (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\r\n\t\t\t\t\tbegin = range.startOffset;\r\n\t\t\t\t\tend = range.endOffset;\r\n\t\t\t\t}\r\n\t\t\t} else if (document.selection && document.selection.createRange) {\r\n\t\t\t\trange = document.selection.createRange();\r\n\t\t\t\tbegin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\r\n\t\t\t\tend = begin + range.text.length;\r\n\t\t\t}\r\n\r\n\t\t\tif (opts.insertMode === false && begin === (end - 1)) end--; //correct caret for insert/overwrite mode\r\n\r\n\t\t\t/*eslint-disable consistent-return */\r\n\t\t\treturn {\r\n\t\t\t\t\"begin\": notranslate ? begin : translatePosition(begin),\r\n\t\t\t\t\"end\": notranslate ? end : translatePosition(end)\r\n\t\t\t};\r\n\t\t\t/*eslint-enable consistent-return */\r\n\t\t}\r\n\t}\r\n\r\n\tfunction determineLastRequiredPosition(returnDefinition) {\r\n\t\tvar buffer = getMaskTemplate(true, getLastValidPosition(), true, true),\r\n\t\t\tbl = buffer.length,\r\n\t\t\tpos, lvp = getLastValidPosition(),\r\n\t\t\tpositions = {},\r\n\t\t\tlvTest = maskset.validPositions[lvp],\r\n\t\t\tndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,\r\n\t\t\ttestPos;\r\n\t\tfor (pos = lvp + 1; pos < buffer.length; pos++) {\r\n\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\r\n\t\t\tndxIntlzr = testPos.locator.slice();\r\n\t\t\tpositions[pos] = $.extend(true, {}, testPos);\r\n\t\t}\r\n\r\n\t\tvar lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\r\n\t\tfor (pos = bl - 1; pos > lvp; pos--) {\r\n\t\t\ttestPos = positions[pos];\r\n\t\t\tif ((testPos.match.optionality ||\r\n\t\t\t\t(testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\r\n\t\t\t\t(lvTestAlt &&\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||\r\n\t\t\t\t\t\t(testPos.match.static === true &&\r\n\t\t\t\t\t\t\ttestPos.locator[lvTest.alternation] &&\r\n\t\t\t\t\t\t\tcheckAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) &&\r\n\t\t\t\t\t\t\tgetTests(pos)[0].def !== \"\")\r\n\t\t\t\t\t)\r\n\t\t\t\t)) &&\r\n\t\t\t\tbuffer[pos] === getPlaceholder(pos, testPos.match)) {\r\n\t\t\t\tbl--;\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn returnDefinition ? {\r\n\t\t\t\"l\": bl,\r\n\t\t\t\"def\": positions[bl] ? positions[bl].match : undefined\r\n\t\t} : bl;\r\n\t}\r\n\r\n\tfunction clearOptionalTail(buffer) {\r\n\t\tbuffer.length = 0;\r\n\t\tvar template = getMaskTemplate(true, 0, true, undefined, true), lmnt;\r\n\t\twhile ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);\r\n\t\treturn buffer;\r\n\t}\r\n\r\n\tfunction isComplete(buffer) { //return true / false / undefined (repeat *)\r\n\t\tif ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n\t\tif (opts.repeat === \"*\") return undefined;\r\n\t\tvar complete = false,\r\n\t\t\tlrp = determineLastRequiredPosition(true),\r\n\t\t\taml = seekPrevious(lrp.l);\r\n\r\n\t\tif (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n\t\t\tcomplete = true;\r\n\t\t\tfor (var i = 0; i <= aml; i++) {\r\n\t\t\t\tvar test = getTestTemplate(i).match;\r\n\t\t\t\tif ((test.static !== true && maskset.validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== getPlaceholder(i, test))) {\r\n\t\t\t\t\tcomplete = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn complete;\r\n\t}\r\n\r\n\r\n\tfunction handleRemove(input, k, pos, strict, fromIsValid) {\r\n\t\tif (opts.numericInput || isRTL) {\r\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE) {\r\n\t\t\t\tk = Inputmask.keyCode.DELETE;\r\n\t\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\tk = Inputmask.keyCode.BACKSPACE;\r\n\t\t\t}\r\n\r\n\t\t\tif (isRTL) {\r\n\t\t\t\tvar pend = pos.end;\r\n\t\t\t\tpos.end = pos.begin;\r\n\t\t\t\tpos.begin = pend;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (k === Inputmask.keyCode.BACKSPACE || (k === Inputmask.keyCode.DELETE && opts.insertMode === false)) {\r\n\t\t\tif ((pos.end - pos.begin < 1)) {\r\n\t\t\t\tpos.begin = seekPrevious(pos.begin);\r\n\t\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\t\tpos.begin--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (k === Inputmask.keyCode.DELETE) {\r\n\t\t\tif (pos.begin === pos.end) {\r\n\t\t\t\tpos.end = isMask(pos.end, true, true) /*&& (maskset.validPositions[pos.end] && maskset.validPositions[pos.end].input !== opts.radixPoint)*/ ?\r\n\t\t\t\t\tpos.end + 1 :\r\n\t\t\t\t\tseekNext(pos.end) + 1;\r\n\t\t\t\tif (maskset.validPositions[pos.begin] !== undefined && maskset.validPositions[pos.begin].input === opts.groupSeparator) {\r\n\t\t\t\t\tpos.end++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar offset;\r\n\t\tif ((offset = revalidateMask(pos)) !== false) {\r\n\t\t\tif (strict !== true && opts.keepStatic !== false || (opts.regex !== null && getTest(pos.begin).match.def.indexOf(\"|\") !== -1)) { //TODO NEEDS BETTER CHECK WHEN TO ALTERNATE  ~ opts regex isn\"t good enough\r\n\t\t\t\tvar result = alternate(true);\r\n\t\t\t\tif (result) {\r\n\t\t\t\t\tvar newPos = result.caret !== undefined ? result.caret : (result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true));\r\n\t\t\t\t\tif (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\r\n\t\t\t\t\t\tpos.begin == newPos;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar lvp = getLastValidPosition(pos.end, true);\r\n\t\t\tif (lvp < pos.begin) {\r\n\t\t\t\tmaskset.p = opts.insertMode === false ? seekPrevious(lvp + 1) : seekNext(lvp);\r\n\t\t\t} else if (strict !== true) {\r\n\t\t\t\tmaskset.p = k === Inputmask.keyCode.DELETE ? pos.begin + offset : pos.begin;\r\n\t\t\t\tif (opts.insertMode === false && k === Inputmask.keyCode.DELETE) {\r\n\t\t\t\t\tmaskset.p = pos.end + 1;\r\n\t\t\t\t\tif (maskset.validPositions[maskset.p] === undefined && getLastValidPosition(maskset.maskLength, true) < maskset.p) {\r\n\t\t\t\t\t\tmaskset.p = seekPrevious(lvp + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction applyInputValue(input, value) {\r\n\t\tinput.inputmask.refreshValue = false;\r\n\t\tif ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\r\n\t\tvalue = value.toString().split(\"\");\r\n\t\tcheckVal(input, true, false, value);\r\n\t\tundoValue = getBuffer().join(\"\");\r\n\t\tif ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && getLastValidPosition() === -1) {\r\n\t\t\tinput.inputmask._valueSet(\"\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mask(elem) {\r\n\t\tfunction isElementTypeSupported(input, opts) {\r\n\t\t\tfunction patchValueProperty(npt) {\r\n\t\t\t\tvar valueGet;\r\n\t\t\t\tvar valueSet;\r\n\r\n\t\t\t\tfunction patchValhook(type) {\r\n\t\t\t\t\tif ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\r\n\t\t\t\t\t\tvar valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\r\n\t\t\t\t\t\t\treturn elem.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvar valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\r\n\t\t\t\t\t\t\telem.value = value;\r\n\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t$.valHooks[type] = {\r\n\t\t\t\t\t\t\tget: function (elem) {\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tif (elem.inputmask.opts.autoUnmask) {\r\n\t\t\t\t\t\t\t\t\t\treturn elem.inputmask.unmaskedvalue();\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tvar result = valhookGet(elem);\r\n\t\t\t\t\t\t\t\t\t\treturn getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\treturn valhookGet(elem);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tset: function (elem, value) {\r\n\t\t\t\t\t\t\t\tvar result = valhookSet(elem, value);\r\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\r\n\t\t\t\t\t\t\t\t\tapplyInputValue(elem, value);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tinputmaskpatch: true\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction getter() {\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\treturn this.inputmask.opts.autoUnmask ?\r\n\t\t\t\t\t\t\tthis.inputmask.unmaskedvalue() :\r\n\t\t\t\t\t\t\t(getLastValidPosition() !== -1 || opts.nullable !== true ?\r\n\t\t\t\t\t\t\t\t(document.activeElement === this && opts.clearMaskOnLostFocus ?\r\n\t\t\t\t\t\t\t\t\t(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") :\r\n\t\t\t\t\t\t\t\t\tvalueGet.call(this)) :\r\n\t\t\t\t\t\t\t\t\"\");\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn valueGet.call(this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction setter(value) {\r\n\t\t\t\t\tvalueSet.call(this, value);\r\n\t\t\t\t\tif (this.inputmask) {\r\n\t\t\t\t\t\tapplyInputValue(this, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfunction installNativeValueSetFallback(npt) {\r\n\t\t\t\t\tEventRuler.on(npt, \"mouseenter\", function () {\r\n\t\t\t\t\t\tvar input = this,\r\n\t\t\t\t\t\t\tvalue = input.inputmask._valueGet(true);\r\n\t\t\t\t\t\tif (value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\")) { //Is this correct? to apply RTL? TOCHECK\r\n\t\t\t\t\t\t\tapplyInputValue(input, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!npt.inputmask.__valueGet) {\r\n\t\t\t\t\tif (opts.noValuePatching !== true) {\r\n\t\t\t\t\t\tif (Object.getOwnPropertyDescriptor) {\r\n\t\t\t\t\t\t\tif (typeof Object.getPrototypeOf !== \"function\") {\r\n\t\t\t\t\t\t\t\tObject.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.__proto__;\r\n\t\t\t\t\t\t\t\t} : function (object) {\r\n\t\t\t\t\t\t\t\t\treturn object.constructor.prototype;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvar valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\r\n\t\t\t\t\t\t\tif (valueProperty && valueProperty.get && valueProperty.set) {\r\n\t\t\t\t\t\t\t\tvalueGet = valueProperty.get;\r\n\t\t\t\t\t\t\t\tvalueSet = valueProperty.set;\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else if (npt.tagName !== \"INPUT\") {\r\n\t\t\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\t\t\treturn this.textContent;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\t\t\tthis.textContent = value;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: getter,\r\n\t\t\t\t\t\t\t\t\tset: setter,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\t\tvalueGet = npt.__lookupGetter__(\"value\");\r\n\t\t\t\t\t\t\tvalueSet = npt.__lookupSetter__(\"value\");\r\n\r\n\t\t\t\t\t\t\tnpt.__defineGetter__(\"value\", getter);\r\n\t\t\t\t\t\t\tnpt.__defineSetter__(\"value\", setter);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnpt.inputmask.__valueGet = valueGet; //store native property getter\r\n\t\t\t\t\t\tnpt.inputmask.__valueSet = valueSet; //store native property setter\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnpt.inputmask._valueGet = function (overruleRTL) {\r\n\t\t\t\t\t\treturn isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n\t\t\t\t\t};\r\n\t\t\t\t\tnpt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to \"null\"\r\n\t\t\t\t\t\tvalueSet.call(this.el, (value === null || value === undefined) ? \"\" : ((overruleRTL !== true && isRTL) ? value.split(\"\").reverse().join(\"\") : value));\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (valueGet === undefined) { //jquery.val fallback\r\n\t\t\t\t\t\tvalueGet = function () {\r\n\t\t\t\t\t\t\treturn this.value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tvalueSet = function (value) {\r\n\t\t\t\t\t\t\tthis.value = value;\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\tpatchValhook(npt.type);\r\n\t\t\t\t\t\tinstallNativeValueSetFallback(npt);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar elementType = input.getAttribute(\"type\");\r\n\t\t\tvar isSupported = (input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === \"TEXTAREA\";\r\n\t\t\tif (!isSupported) {\r\n\t\t\t\tif (input.tagName === \"INPUT\") {\r\n\t\t\t\t\tvar el = document.createElement(\"input\");\r\n\t\t\t\t\tel.setAttribute(\"type\", elementType);\r\n\t\t\t\t\tisSupported = el.type === \"text\"; //apply mask only if the type is not natively supported\r\n\t\t\t\t\tel = null;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tisSupported = \"partial\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (isSupported !== false) {\r\n\t\t\t\tpatchValueProperty(input);\r\n\t\t\t} else {\r\n\t\t\t\tinput.inputmask = undefined;\r\n\t\t\t}\r\n\t\t\treturn isSupported;\r\n\t\t}\r\n\r\n\t\t//unbind all events - to make sure that no other mask will interfere when re-masking\r\n\t\tEventRuler.off(elem);\r\n\t\tvar isSupported = isElementTypeSupported(elem, opts);\r\n\t\tif (isSupported !== false) {\r\n\t\t\tel = elem;\r\n\t\t\t$el = $(el);\r\n\r\n\t\t\toriginalPlaceholder = el.placeholder;\r\n\r\n\t\t\t//read maxlength prop from el\r\n\t\t\tmaxLength = el !== undefined ? el.maxLength : undefined;\r\n\t\t\tif (maxLength === -1) maxLength = undefined;\r\n\t\t\tif (\"inputmode\" in el) {\r\n\t\t\t\tel.inputmode = opts.inputmode;\r\n\t\t\t\tel.setAttribute(\"inputmode\", opts.inputmode);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (isSupported === true) {\r\n\t\t\t\topts.showMaskOnFocus = opts.showMaskOnFocus && [\"cc-number\", \"cc-exp\"].indexOf(el.autocomplete) === -1;\r\n\r\n\t\t\t\t//bind events\r\n\t\t\t\tEventRuler.on(el, \"submit\", EventHandlers.submitEvent);\r\n\t\t\t\tEventRuler.on(el, \"reset\", EventHandlers.resetEvent);\r\n\t\t\t\tEventRuler.on(el, \"blur\", EventHandlers.blurEvent);\r\n\t\t\t\tEventRuler.on(el, \"focus\", EventHandlers.focusEvent);\r\n\t\t\t\tEventRuler.on(el, \"invalid\", EventHandlers.invalidEvent);\r\n\t\t\t\tEventRuler.on(el, \"click\", EventHandlers.clickEvent);\r\n\t\t\t\tEventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\r\n\t\t\t\tEventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\r\n\t\t\t\tEventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\r\n\t\t\t\tEventRuler.on(el, \"cut\", EventHandlers.cutEvent);\r\n\t\t\t\tEventRuler.on(el, \"complete\", opts.oncomplete);\r\n\t\t\t\tEventRuler.on(el, \"incomplete\", opts.onincomplete);\r\n\t\t\t\tEventRuler.on(el, \"cleared\", opts.oncleared);\r\n\t\t\t\tif (!mobile && opts.inputEventOnly !== true) {\r\n\t\t\t\t\tEventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\r\n\t\t\t\t\tEventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tel.removeAttribute(\"maxLength\");\r\n\t\t\t\t}\r\n\t\t\t\tEventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\r\n\t\t\t\tEventRuler.on(el, \"compositionend\", EventHandlers.compositionendEvent);\r\n\t\t\t\t// EventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement\r\n\t\t\t}\r\n\t\t\tEventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\r\n\r\n\t\t\t//apply mask\r\n\t\t\tundoValue = getBufferTemplate().join(\"\"); //initialize the buffer and getmasklength\r\n\t\t\tif (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\r\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true), opts);\r\n\t\t\t\tvar buffer = getBuffer().slice();\r\n\t\t\t\t// Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\r\n\t\t\t\tif (isComplete(buffer) === false) {\r\n\t\t\t\t\tif (opts.clearIncomplete) {\r\n\t\t\t\t\t\tresetMaskSet();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== el) {\r\n\t\t\t\t\tif (getLastValidPosition() === -1) {\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tclearOptionalTail(buffer);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && document.activeElement === el) || el.inputmask._valueGet(true) !== \"\") {\r\n\t\t\t\t\twriteBuffer(el, buffer);\r\n\t\t\t\t}\r\n\t\t\t\tif (document.activeElement === el) { //position the caret when in focus\r\n\t\t\t\t\tcaret(el, seekNext(getLastValidPosition()));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//action object\r\n\tvar valueBuffer;\r\n\tif (actionObj !== undefined) {\r\n\t\tswitch (actionObj.action) {\r\n\t\t\tcase \"isComplete\":\r\n\t\t\t\tel = actionObj.el;\r\n\t\t\t\treturn isComplete(getBuffer());\r\n\t\t\tcase \"unmaskedvalue\":\r\n\t\t\t\tif (el === undefined || actionObj.value !== undefined) {\r\n\t\t\t\t\tvalueBuffer = actionObj.value;\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, false, false, valueBuffer);\r\n\t\t\t\t\tif ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\r\n\t\t\t\t}\r\n\t\t\t\treturn unmaskedvalue(el);\r\n\t\t\tcase \"mask\":\r\n\t\t\t\tmask(el);\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"format\":\r\n\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\tif (actionObj.metadata) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tvalue: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n\t\t\t\t\t\tmetadata: maskScope.call(this, {\r\n\t\t\t\t\t\t\t\"action\": \"getmetadata\"\r\n\t\t\t\t\t\t}, maskset, opts)\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\tcase \"isValid\":\r\n\t\t\t\tif (actionObj.value) {\r\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\r\n\t\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\t\t\t\t}\r\n\t\t\t\tvar buffer = getBuffer();\r\n\t\t\t\tvar rl = determineLastRequiredPosition(),\r\n\t\t\t\t\tlmib = buffer.length - 1;\r\n\t\t\t\tfor (; lmib > rl; lmib--) {\r\n\t\t\t\t\tif (isMask(lmib)) break;\r\n\t\t\t\t}\r\n\t\t\t\tbuffer.splice(rl, lmib + 1 - rl);\r\n\r\n\t\t\t\treturn isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"));\r\n\t\t\tcase \"getemptymask\":\r\n\t\t\t\treturn getBufferTemplate().join(\"\");\r\n\t\t\tcase \"remove\":\r\n\t\t\t\tif (el && el.inputmask) {\r\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", null); //invalidate\r\n\t\t\t\t\t$el = $(el);\r\n\t\t\t\t\t//writeout the value\r\n\t\t\t\t\tvar cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);\r\n\t\t\t\t\tif (cv !== getBufferTemplate().join(\"\")) el.inputmask._valueSet(cv, opts.autoUnmask); else el.inputmask._valueSet(\"\");\r\n\t\t\t\t\t//unbind all events\r\n\t\t\t\t\tEventRuler.off(el);\r\n\r\n\t\t\t\t\t//restore the value property\r\n\t\t\t\t\tvar valueProperty;\r\n\t\t\t\t\tif (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\r\n\t\t\t\t\t\tvalueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\r\n\t\t\t\t\t\tif (valueProperty) {\r\n\t\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\t\tObject.defineProperty(el, \"value\", {\r\n\t\t\t\t\t\t\t\t\tget: el.inputmask.__valueGet,\r\n\t\t\t\t\t\t\t\t\tset: el.inputmask.__valueSet,\r\n\t\t\t\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\r\n\t\t\t\t\t\tif (el.inputmask.__valueGet) {\r\n\t\t\t\t\t\t\tel.__defineGetter__(\"value\", el.inputmask.__valueGet);\r\n\t\t\t\t\t\t\tel.__defineSetter__(\"value\", el.inputmask.__valueSet);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//clear data\r\n\t\t\t\t\tel.inputmask = undefined;\r\n\t\t\t\t}\r\n\t\t\t\treturn el;\r\n\t\t\tcase \"getmetadata\":\r\n\t\t\t\tif ($.isArray(maskset.metadata)) {\r\n\t\t\t\t\tvar maskTarget = getMaskTemplate(true, 0, false).join(\"\");\r\n\t\t\t\t\t$.each(maskset.metadata, function (ndx, mtdt) {\r\n\t\t\t\t\t\tif (mtdt.mask === maskTarget) {\r\n\t\t\t\t\t\t\tmaskTarget = mtdt;\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn maskTarget;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn maskset.metadata;\r\n\t\t}\r\n\t}\r\n}\r\n;\r\n\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib,\r\n\t//supported codes for formatting\r\n\t//http://blog.stevenlevithan.com/archives/date-time-format\r\n\t//https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings?view=netframework-4.7\r\n\tformatCode = { //regex, valueSetter, type, displayformatter\r\n\t\td: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], //Day of the month as digits; no leading zero for single-digit days.\r\n\t\tdd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\r\n\t\t\treturn pad(Date.prototype.getDate.call(this), 2);\r\n\t\t}], //Day of the month as digits; leading zero for single-digit days.\r\n\t\tddd: [\"\"], //Day of the week as a three-letter abbreviation.\r\n\t\tdddd: [\"\"], //Day of the week as its full name.\r\n\t\tm: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn Date.prototype.getMonth.call(this) + 1;\r\n\t\t}], //Month as digits; no leading zero for single-digit months.\r\n\t\tmm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\r\n\t\t\treturn pad(Date.prototype.getMonth.call(this) + 1, 2);\r\n\t\t}], //Month as digits; leading zero for single-digit months.\r\n\t\tmmm: [\"\"], //Month as a three-letter abbreviation.\r\n\t\tmmmm: [\"\"], //Month as its full name.\r\n\t\tyy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 2);\r\n\t\t}], //Year as last two digits; leading zero for years less than 10.\r\n\t\tyyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\r\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 4);\r\n\t\t}],\r\n\t\th: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (12-hour clock).\r\n\t\thh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (12-hour clock).\r\n\t\thhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tH: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (24-hour clock).\r\n\t\tHH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\r\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\r\n\t\t}], //Hours; leading zero for single-digit hours (24-hour clock).\r\n\t\tHHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\r\n\t\tM: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], //Minutes; no leading zero for single-digit minutes. Uppercase M unlike CF timeFormat's m to avoid conflict with months.\r\n\t\tMM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\r\n\t\t\treturn pad(Date.prototype.getMinutes.call(this), 2);\r\n\t\t}], //Minutes; leading zero for single-digit minutes. Uppercase MM unlike CF timeFormat's mm to avoid conflict with months.\r\n\t\ts: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], //Seconds; no leading zero for single-digit seconds.\r\n\t\tss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getSeconds.call(this), 2);\r\n\t\t}], //Seconds; leading zero for single-digit seconds.\r\n\t\tl: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 3);\r\n\t\t}], //Milliseconds. 3 digits.\r\n\t\tL: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\r\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 2);\r\n\t\t}], //Milliseconds. 2 digits.\r\n\t\tt: [\"[ap]\"], //Lowercase, single-character time marker string: a or p.\r\n\t\ttt: [\"[ap]m\"], //two-character time marker string: am or pm.\r\n\t\tT: [\"[AP]\"], //single-character time marker string: A or P.\r\n\t\tTT: [\"[AP]M\"], //two-character time marker string: AM or PM.\r\n\t\tZ: [\"\"], //US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500\r\n\t\to: [\"\"], //GMT/UTC timezone offset, e.g. -0500 or +0230.\r\n\t\tS: [\"\"] //The date's ordinal suffix (st, nd, rd, or th).\r\n\t},\r\n\tformatAlias = {\r\n\t\tisoDate: \"yyyy-mm-dd\", //2007-06-09\r\n\t\tisoTime: \"HH:MM:ss\", //17:46:21\r\n\t\tisoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", //2007-06-09T17:46:21\r\n\t\tisoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" //2007-06-09T22:46:21Z\r\n\t};\r\n\r\nfunction getTokenizer(opts) {\r\n\tif (!opts.tokenizer) {\r\n\t\tvar tokens = [];\r\n\t\tfor (var ndx in formatCode) {\r\n\t\t\tif (tokens.indexOf(ndx[0]) === -1) {\r\n\t\t\t\ttokens.push(ndx[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\topts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\r\n\t\topts.tokenizer = new RegExp(opts.tokenizer, \"g\");\r\n\t}\r\n\r\n\treturn opts.tokenizer;\r\n}\r\n\r\nfunction isValidDate(dateParts, currentResult) {\r\n\treturn !isFinite(dateParts.rawday)\r\n\t|| (dateParts.day == \"29\" && !isFinite(dateParts.rawyear))\r\n\t|| new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day\r\n\t\t? currentResult\r\n\t\t: false; //take corrective action if possible\r\n}\r\n\r\nfunction isDateInRange(dateParts, opts) {\r\n\tvar result = true;\r\n\tif (opts.min) {\r\n\t\tif (dateParts[\"rawyear\"]) {\r\n\t\t\tvar rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\r\n\t\t\t\tminYear = opts.min.year.substr(0, rawYear.length);\r\n\t\t\tresult = minYear <= rawYear;\r\n\t\t}\r\n\t\tif (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\r\n\t\t\tif (opts.min.date.getTime() === opts.min.date.getTime()) {\r\n\t\t\t\tresult = opts.min.date.getTime() <= dateParts.date.getTime();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\r\n\t\tresult = opts.max.date.getTime() >= dateParts.date.getTime();\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n//parse the given format and return a mask pattern\r\n//when a dateObjValue is passed a datestring in the requested format is returned\r\nfunction parse(format, dateObjValue, opts, raw) {\r\n\t//parse format to regex string\r\n\tvar mask = \"\", match;\r\n\tgetTokenizer(opts).lastIndex = 0;\r\n\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\tif (dateObjValue === undefined) {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tmask += \"(\" + formatCode[match[0]][0] + \")\";\r\n\t\t\t} else {\r\n\t\t\t\tswitch (match[0]) {\r\n\t\t\t\t\tcase \"[\":\r\n\t\t\t\t\t\tmask += \"(\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"]\":\r\n\t\t\t\t\t\tmask += \")?\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tmask += Inputmask.escapeRegex(match[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (formatCode[match[0]]) {\r\n\t\t\t\tif (raw !== true && formatCode[match[0]][3]) {\r\n\t\t\t\t\tvar getFn = formatCode[match[0]][3];\r\n\t\t\t\t\tmask += getFn.call(dateObjValue.date);\r\n\t\t\t\t} else if (formatCode[match[0]][2]) {\r\n\t\t\t\t\tmask += dateObjValue[\"raw\" + formatCode[match[0]][2]];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmask += match[0];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tmask += match[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn mask;\r\n}\r\n\r\n//padding function\r\nfunction pad(val, len) {\r\n\tval = String(val);\r\n\tlen = len || 2;\r\n\twhile (val.length < len) val = \"0\" + val;\r\n\treturn val;\r\n}\r\n\r\nfunction analyseMask(maskString, format, opts) {\r\n\tvar dateObj = {\"date\": new Date(1, 0, 1)}, targetProp, mask = maskString, match, dateOperation;\r\n\r\n\tfunction extendProperty(value) {\r\n\t\tvar correctedValue = value.replace(/[^0-9]/g, \"0\");\r\n\t\t// if (correctedValue != value) { //only do correction on incomplete values\r\n\t\t//     //determine best validation match\r\n\t\t//     var enteredPart = value.replace(/[^0-9]/g, \"\"),\r\n\t\t//         enteredPartIndex = value.indexOf(enteredPart),\r\n\t\t//         minPart = (opts.min && opts.min[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         maxPart = (opts.max && opts.max[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\r\n\t\t//         correctedPart = enteredPart < minPart ? minPart : (enteredPart > maxPart ? maxPart : correctedValue.slice(enteredPartIndex, enteredPartIndex + enteredPart.length));\r\n\t\t//     correctedValue = correctedValue.split(\"\");\r\n\t\t//     correctedValue.splice(enteredPartIndex, 1, correctedPart);\r\n\t\t//     correctedValue = correctedValue.join(\"\");\r\n\t\t// }\r\n\t\treturn correctedValue;\r\n\t}\r\n\r\n\tfunction setValue(dateObj, value, opts) {\r\n\t\tdateObj[targetProp] = extendProperty(value);\r\n\t\tdateObj[\"raw\" + targetProp] = value;\r\n\r\n\t\tif (dateOperation !== undefined) {\r\n\t\t\tdateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\r\n\t\t}\r\n\t}\r\n\r\n\tif (typeof mask === \"string\") {\r\n\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\twhile ((match = getTokenizer(opts).exec(format))) {\r\n\t\t\tvar value = mask.slice(0, match[0].length);\r\n\t\t\tif (formatCode.hasOwnProperty(match[0])) {\r\n\t\t\t\t// targetValidator = formatCode[match[0]][0];\r\n\t\t\t\ttargetProp = formatCode[match[0]][2];\r\n\t\t\t\tdateOperation = formatCode[match[0]][1];\r\n\t\t\t\tsetValue(dateObj, value, opts);\r\n\t\t\t}\r\n\t\t\tmask = mask.slice(value.length);\r\n\t\t}\r\n\r\n\t\treturn dateObj;\r\n\t} else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\r\n\t\treturn mask;\r\n\t}\r\n\treturn undefined;\r\n}\r\n\r\nInputmask.extendAliases({\r\n\t\"datetime\": {\r\n\t\tmask: function (opts) {\r\n\t\t\t//localize\r\n\t\t\tformatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\r\n\r\n\t\t\topts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat; //resolve possible formatAlias\r\n\t\t\topts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\");\r\n\t\t\topts.regex = parse(opts.inputFormat, undefined, opts);\r\n\t\t\t// console.log(opts.regex);\r\n\t\t\treturn null; //migrate to regex mask\r\n\t\t},\r\n\t\tplaceholder: \"\", //set default as none (~ auto); when a custom placeholder is passed it will be used\r\n\t\tinputFormat: \"isoDateTime\", //format used to input the date\r\n\t\tdisplayFormat: undefined, //visual format when the input looses focus\r\n\t\toutputFormat: undefined, //unmasking format\r\n\t\tmin: null, //needs to be in the same format as the inputfornat\r\n\t\tmax: null, //needs to be in the same format as the inputfornat,\r\n\t\tskipOptionalPartCharacter: \"\",\r\n\t\t// Internationalization strings\r\n\t\ti18n: {\r\n\t\t\tdayNames: [\r\n\t\t\t\t\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\",\r\n\t\t\t\t\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"\r\n\t\t\t],\r\n\t\t\tmonthNames: [\r\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\r\n\t\t\t\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\r\n\t\t\t],\r\n\t\t\tordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset, caretPos) {\r\n\t\t\tvar calcPos = 0, targetMatch, match;\r\n\t\t\tif (isNaN(c) && buffer[pos] !== c) {\r\n\t\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\t\tif (calcPos >= pos) {\r\n\t\t\t\t\t\ttargetMatch = match;\r\n\t\t\t\t\t\tmatch = getTokenizer(opts).exec(opts.inputFormat);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (match && match[0] === c && targetMatch[0].length > 1) {\r\n\t\t\t\t\tbuffer[pos] = buffer[pos - 1];\r\n\t\t\t\t\tbuffer[pos - 1] = \"0\";\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tfuzzy: true,\r\n\t\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\t\trefreshFromBuffer: {start: pos - 1, end: pos + 1},\r\n\t\t\t\t\t\tpos: pos + 1\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts, maskset) {\r\n\t\t\topts.min = analyseMask(opts.min, opts.inputFormat, opts);\r\n\t\t\topts.max = analyseMask(opts.max, opts.inputFormat, opts);\r\n\r\n\t\t\tif (currentResult.fuzzy) {\r\n\t\t\t\tbuffer = currentResult.buffer;\r\n\t\t\t\tpos = currentResult.pos;\r\n\t\t\t}\r\n\r\n\t\t\t//full validate target\r\n\t\t\tvar calcPos = 0, match;\r\n\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\tcalcPos += match[0].length;\r\n\t\t\t\tif (calcPos > pos) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (match && match[0] && formatCode[match[0]] !== undefined) {\r\n\t\t\t\tvar validator = formatCode[match[0]][0];\r\n\t\t\t\tvar part = buffer.slice(match.index, match.index + match[0].length);\r\n\t\t\t\tif (new RegExp(validator).test(part.join(\"\")) === false && match[0].length === 2 && maskset.validPositions[match.index] && maskset.validPositions[match.index + 1]) {\r\n\t\t\t\t\tmaskset.validPositions[match.index + 1].input = \"0\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\r\n\t\t\tif (result && dateParts.date.getTime() === dateParts.date.getTime()) { //check for a valid date ~ an invalid date returns NaN which isn't equal\r\n\t\t\t\tresult = isValidDate(dateParts, result);\r\n\t\t\t\tresult = result && isDateInRange(dateParts, opts);\r\n\t\t\t}\r\n\r\n\t\t\tif (pos && result && currentResult.pos !== pos) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tbuffer: parse(opts.inputFormat, dateParts, opts).split(\"\"),\r\n\t\t\t\t\trefreshFromBuffer: {start: pos, end: currentResult.pos}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar input = this;\r\n\t\t\tif (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n\t\t\t\tvar today = new Date(), match, date = \"\";\r\n\r\n\t\t\t\tgetTokenizer(opts).lastIndex = 0;\r\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\r\n\t\t\t\t\tif (match[0].charAt(0) === \"d\") {\r\n\t\t\t\t\t\tdate += pad(today.getDate(), match[0].length);\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"m\") {\r\n\t\t\t\t\t\tdate += pad((today.getMonth() + 1), match[0].length);\r\n\t\t\t\t\t} else if (match[0] === \"yyyy\") {\r\n\t\t\t\t\t\tdate += today.getFullYear().toString();\r\n\t\t\t\t\t} else if (match[0].charAt(0) === \"y\") {\r\n\t\t\t\t\t\tdate += pad(today.getYear(), match[0].length);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinput.inputmask._valueSet(date);\r\n\t\t\t\t$(input).trigger(\"setvalue\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\treturn unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true) : unmaskedValue;\r\n\t\t},\r\n\t\tcasing: function (elem, test, pos, validPositions) {\r\n\t\t\tif (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\r\n\t\t\tif (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\r\n\t\t\treturn elem;\r\n\t\t},\r\n\t\tinsertMode: false,\r\n\t\tshiftPositions: false,\r\n\t\tkeepStatic: false\r\n\t}\r\n});\r\n\r\nmodule.exports = Inputmask;\r\n","/*\r\n Input Mask plugin extensions\r\n http://github.com/RobinHerbots/jquery.inputmask\r\n Copyright (c) Robin Herbots\r\n Licensed under the MIT license\r\n */\r\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib;\r\n\r\nfunction autoEscape(txt, opts) {\r\n\tvar escapedTxt = \"\";\r\n\tfor (var i = 0; i < txt.length; i++) {\r\n\t\tif (Inputmask.prototype.definitions[txt.charAt(i)] ||\r\n\t\t\topts.definitions[txt.charAt(i)] ||\r\n\t\t\topts.optionalmarker.start === txt.charAt(i) ||\r\n\t\t\topts.optionalmarker.end === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.start === txt.charAt(i) ||\r\n\t\t\topts.quantifiermarker.end === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.start === txt.charAt(i) ||\r\n\t\t\topts.groupmarker.end === txt.charAt(i) ||\r\n\t\t\topts.alternatormarker === txt.charAt(i)) {\r\n\t\t\tescapedTxt += \"\\\\\" + txt.charAt(i);\r\n\t\t} else {\r\n\t\t\tescapedTxt += txt.charAt(i);\r\n\t\t}\r\n\t}\r\n\treturn escapedTxt;\r\n}\r\n\r\nfunction alignDigits(buffer, digits, opts) {\r\n\tif (digits > 0 && !opts.digitsOptional) {\r\n\t\tvar radixPosition = $.inArray(opts.radixPoint, buffer);\r\n\t\tif (radixPosition === -1) {\r\n\t\t\tbuffer.push(opts.radixPoint);\r\n\t\t\tradixPosition = buffer.length - 1;\r\n\t\t}\r\n\t\tfor (var i = 1; i <= digits; i++) {\r\n\t\t\tbuffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn buffer;\r\n}\r\n\r\nfunction findValidator(symbol, maskset) {\r\n\tvar posNdx = 0;\r\n\tif (symbol === \"+\") {\r\n\t\tfor (posNdx in maskset.validPositions) ;\r\n\t\tposNdx = parseInt(posNdx);\r\n\t}\r\n\tfor (var tstNdx in maskset.tests) {\r\n\t\ttstNdx = parseInt(tstNdx);\r\n\t\tif (tstNdx >= posNdx) {\r\n\t\t\tfor (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\r\n\t\t\t\tif ((maskset.validPositions[tstNdx] === undefined || symbol === \"-\") && maskset.tests[tstNdx][ndx].match.def === symbol) {\r\n\t\t\t\t\treturn tstNdx + ((maskset.validPositions[tstNdx] !== undefined && symbol !== \"-\") ? 1 : 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn posNdx;\r\n}\r\n\r\nfunction findValid(symbol, maskset) {\r\n\tvar ret = -1;\r\n\t$.each(maskset.validPositions, function (ndx, tst) {\r\n\t\tif (tst && tst.match.def === symbol) {\r\n\t\t\tret = parseInt(ndx);\r\n\t\t\treturn false;\r\n\t\t}\r\n\t});\r\n\treturn ret;\r\n}\r\n\r\nfunction parseMinMaxOptions(opts) {\r\n\tif (opts.parseMinMaxOptions === undefined) {\r\n\t\t// convert min and max options\r\n\t\tif (opts.min !== null) {\r\n\t\t\topts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\r\n\t\t\topts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\r\n\t\t\tif (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\r\n\t\t}\r\n\t\tif (opts.max !== null) {\r\n\t\t\topts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\r\n\t\t\topts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\r\n\t\t\tif (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\r\n\t\t}\r\n\t\topts.parseMinMaxOptions = \"done\";\r\n\t}\r\n}\r\n\r\nfunction genMask(opts) {\r\n\topts.repeat = 0;\r\n\t//treat equal separator and radixpoint\r\n\tif (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\r\n\t\tif (opts.radixPoint === \".\") {\r\n\t\t\topts.groupSeparator = \",\";\r\n\t\t} else if (opts.radixPoint === \",\") {\r\n\t\t\topts.groupSeparator = \".\";\r\n\t\t} else {\r\n\t\t\topts.groupSeparator = \"\";\r\n\t\t}\r\n\t}\r\n\t//prevent conflict with default skipOptionalPartCharacter\r\n\tif (opts.groupSeparator === \" \") {\r\n\t\topts.skipOptionalPartCharacter = undefined;\r\n\t}\r\n\r\n\t//enforce placeholder to single\r\n\tif (opts.placeholder.length > 1) {\r\n\t\topts.placeholder = opts.placeholder.charAt(0);\r\n\t}\r\n\t//only allow radixfocus when placeholder = 0\r\n\tif (opts.positionCaretOnClick === \"radixFocus\" && opts.placeholder === \"\") {\r\n\t\topts.positionCaretOnClick = \"lvp\";\r\n\t}\r\n\r\n\tvar decimalDef = \"0\";\r\n\tif (opts.numericInput === true && opts.__financeInput === undefined) { //finance people input style\r\n\t\tdecimalDef = \"1\";\r\n\t\topts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\r\n\t\t// opts.digitsOptional = false;\r\n\t\tif (isNaN(opts.digits)) opts.digits = 2;\r\n\t\topts._radixDance = false;\r\n\t} else {\r\n\t\topts.__financeInput = false; //needed to keep original selection when remasking\r\n\t\topts.numericInput = true;\r\n\t}\r\n\r\n\tvar mask = \"[+]\", altMask;\r\n\tmask += autoEscape(opts.prefix, opts);\r\n\tif (opts.groupSeparator !== \"\") {\r\n\t\tmask += opts._mask(opts);\r\n\t} else {\r\n\t\tmask += \"9{+}\";\r\n\t}\r\n\tif (opts.digits !== undefined && opts.digits !== 0) {\r\n\t\tvar dq = opts.digits.toString().split(\",\");\r\n\t\tif (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\r\n\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t} else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\r\n\t\t\tif (opts.digitsOptional) {\r\n\t\t\t\taltMask = mask + opts.radixPoint + decimalDef + \"{0,\" + opts.digits + \"}\";\r\n\t\t\t\t// mask += \"[\" + opts.radixPoint + \"]\";\r\n\t\t\t\topts.keepStatic = true;\r\n\t\t\t} else {\r\n\t\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tmask += autoEscape(opts.suffix, opts);\r\n\tmask += \"[-]\";\r\n\r\n\tif (altMask) {\r\n\t\tmask = [(altMask + autoEscape(opts.suffix, opts) + \"[-]\"), mask];\r\n\t}\r\n\r\n\r\n\topts.greedy = false; //enforce greedy false\r\n\r\n\tparseMinMaxOptions(opts);\r\n\r\n\t// console.log(mask);\r\n\treturn mask;\r\n}\r\n\r\nfunction hanndleRadixDance(pos, c, radixPos, opts) {\r\n\tif (opts._radixDance && opts.numericInput && c !== opts.negationSymbol.back) {\r\n\t\tif (pos <= radixPos && (radixPos > 0 || c == opts.radixPoint)) {\r\n\t\t\tpos -= 1;\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\n\r\nfunction decimalValidator(chrs, maskset, pos, strict, opts) {\r\n\tvar radixPos = maskset.buffer ? maskset.buffer.indexOf(opts.radixPoint) : -1,\r\n\t\tresult = radixPos !== -1 && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\r\n\tif (opts._radixDance && result && maskset.validPositions[radixPos] == undefined) {\r\n\t\treturn {\r\n\t\t\tinsert: {\r\n\t\t\t\tpos: radixPos === pos ? radixPos + 1 : radixPos,\r\n\t\t\t\tc: opts.radixPoint\r\n\t\t\t},\r\n\t\t\tpos: pos\r\n\t\t};\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction checkForLeadingZeroes(buffer, opts) {\r\n\t//check leading zeros\r\n\tvar numberMatches = new RegExp(\"(^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(buffer.slice().reverse().join(\"\")),\r\n\t\tnumber = numberMatches ? numberMatches[2] : \"\", leadingzeroes = false;\r\n\tif (number) {\r\n\t\tnumber = number.split(opts.radixPoint.charAt(0))[0];\r\n\t\tleadingzeroes = new RegExp(\"^[0\" + opts.groupSeparator + \"]*\").exec(number);\r\n\t}\r\n\treturn leadingzeroes && (leadingzeroes[0].length > 1 || leadingzeroes[0].length > 0 && leadingzeroes[0].length < number.length) ? leadingzeroes : false;\r\n}\r\n\r\n//number aliases\r\nInputmask.extendAliases({\r\n\t\"numeric\": {\r\n\t\tmask: genMask,\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"999){+|1}\";\r\n\t\t},\r\n\t\tplaceholder: \"0\",\r\n\t\tgreedy: false,\r\n\t\tdigits: \"*\", //number of fractionalDigits\r\n\t\tdigitsOptional: true,\r\n\t\tenforceDigitsOnBlur: false,\r\n\t\tradixPoint: \".\",\r\n\t\tpositionCaretOnClick: \"radixFocus\",\r\n\t\t_radixDance: true,\r\n\t\tgroupSeparator: \"\",\r\n\t\tallowMinus: true,\r\n\t\tnegationSymbol: {\r\n\t\t\tfront: \"-\", //\"(\"\r\n\t\t\tback: \"\" //\")\"\r\n\t\t},\r\n\t\tprefix: \"\",\r\n\t\tsuffix: \"\",\r\n\t\trightAlign: true,\r\n\t\tmin: null, //minimum value\r\n\t\tmax: null, //maximum value\r\n\t\tstep: 1,\r\n\t\tinsertMode: true,\r\n\t\tautoUnmask: false,\r\n\t\tunmaskAsNumber: false,\r\n\t\tinputmode: \"numeric\",\r\n\t\tskipOptionalPartCharacter: \"\",\r\n\t\tdefinitions: {\r\n\t\t\t\"0\": {\r\n\t\t\t\tvalidator: decimalValidator\r\n\t\t\t},\r\n\t\t\t\"1\": {\r\n\t\t\t\tvalidator: decimalValidator,\r\n\t\t\t\tdefinitionSymbol: \"*\"\r\n\t\t\t},\r\n\t\t\t\"+\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front));\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\"-\": {\r\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\r\n\t\t\t\t\treturn (opts.allowMinus && chrs === opts.negationSymbol.back);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset, caretPos) {\r\n\t\t\tif (opts.__financeInput !== false && c === opts.radixPoint) return false;\r\n\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\tpos = hanndleRadixDance(pos, c, radixPos, opts);\r\n\t\t\tif (c === \"-\" || c === opts.negationSymbol.front) {\r\n\t\t\t\tif (opts.allowMinus !== true) return false;\r\n\t\t\t\tvar isNegative = false,\r\n\t\t\t\t\tfront = findValid(\"+\", maskset), back = findValid(\"-\", maskset);\r\n\t\t\t\tif (front !== -1) {\r\n\t\t\t\t\tisNegative = [front, back];\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn isNegative !== false ? {\r\n\t\t\t\t\tremove: isNegative,\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t} : {\r\n\t\t\t\t\tinsert: [\r\n\t\t\t\t\t\t{pos: findValidator(\"+\", maskset), c: opts.negationSymbol.front, fromIsValid: true},\r\n\t\t\t\t\t\t{pos: findValidator(\"-\", maskset), c: opts.negationSymbol.back, fromIsValid: undefined}],\r\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif (radixPos !== -1 && (opts._radixDance === true && isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) && radixPos !== pos)) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\t\"caret\": opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn {rewritePosition: (isSelection && opts.digitsOptional) ? caretPos.end : pos};\r\n\t\t},\r\n\t\tpostValidation: function (buffer, pos, currentResult, opts, maskset) {\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t}));\r\n\t\t\t\tif (opts.min !== null && unmasked < opts.min && (unmasked.toString().length >= opts.min.toString().length || unmasked < 0)) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (opts.max !== null && unmasked > opts.max) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\tbuffer: alignDigits(opts.max.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn currentResult;\r\n\t\t},\r\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\r\n\t\t\tif (unmaskedValue === \"\" && opts.nullable === true) {\r\n\t\t\t\treturn unmaskedValue;\r\n\t\t\t}\r\n\t\t\tvar processValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tprocessValue = processValue.replace(opts.suffix, \"\");\r\n\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n\t\t\tif (opts.placeholder.charAt(0) !== \"\") {\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\r\n\t\t\t}\r\n\t\t\tif (opts.unmaskAsNumber) {\r\n\t\t\t\tif (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\t\treturn Number(processValue);\r\n\t\t\t}\r\n\t\t\treturn processValue;\r\n\t\t},\r\n\t\tisComplete: function (buffer, opts) {\r\n\t\t\tvar maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.prefix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(opts.suffix, \"\");\r\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\r\n\t\t\tif (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\r\n\t\t\treturn isFinite(maskedValue);\r\n\t\t},\r\n\t\tonBeforeMask: function (initialValue, opts) {\r\n\t\t\tvar radixPoint = opts.radixPoint || \",\";\r\n\r\n\t\t\tif ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\r\n\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t}\r\n\r\n\t\t\tvar valueParts = initialValue.split(radixPoint),\r\n\t\t\t\tintegerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\r\n\t\t\t\tdecimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\r\n\r\n\t\t\tinitialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\r\n\r\n\t\t\tvar digits = 0;\r\n\t\t\tif (radixPoint !== \"\") {\r\n\t\t\t\tdigits = decimalPart.length;\r\n\t\t\t\tif (decimalPart !== \"\") {\r\n\t\t\t\t\tvar digitsFactor = Math.pow(10, digits || 1);\r\n\t\t\t\t\tif (isFinite(opts.digits)) {\r\n\t\t\t\t\t\tdigits = parseInt(opts.digits);\r\n\t\t\t\t\t\tdigitsFactor = Math.pow(10, digits);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//make the initialValue a valid javascript number for the parsefloat\r\n\t\t\t\t\tinitialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\r\n\t\t\t\t\tif (isFinite(initialValue)) {\r\n\t\t\t\t\t\tinitialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//this needs to be in a separate part and not directly in decimalPart to allow rounding\r\n\t\t\tif (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\r\n\t\t\t\tinitialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\r\n\t\t\t}\r\n\r\n\t\t\tif (opts.min !== null || opts.max !== null) {\r\n\t\t\t\tvar numberValue = initialValue.toString().replace(radixPoint, \".\");\r\n\t\t\t\tif (opts.min !== null && numberValue < opts.min) {\r\n\t\t\t\t\tinitialValue = opts.min.toString().replace(\".\", radixPoint);\r\n\t\t\t\t} else if (opts.max !== null && numberValue > opts.max) {\r\n\t\t\t\t\tinitialValue = opts.max.toString().replace(\".\", radixPoint);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\r\n\t\t},\r\n\t\tonBeforeWrite: function (e, buffer, caretPos, opts) {\r\n\t\t\tfunction stripBuffer(buffer, stripRadix) {\r\n\t\t\t\tif (opts.__financeInput !== false || stripRadix) {\r\n\t\t\t\t\tvar position = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (position !== -1) {\r\n\t\t\t\t\t\tbuffer.splice(position, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (opts.groupSeparator !== \"\") {\r\n\t\t\t\t\twhile ((position = buffer.indexOf(opts.groupSeparator)) !== -1) {\r\n\t\t\t\t\t\tbuffer.splice(position, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn buffer;\r\n\t\t\t}\r\n\r\n\t\t\tvar result,\r\n\t\t\t\tleadingzeroes = checkForLeadingZeroes(buffer, opts);\r\n\r\n\t\t\tif (leadingzeroes) {\r\n\t\t\t\tvar buf = buffer.slice().reverse(), caretNdx = buf.join(\"\").indexOf(leadingzeroes[0]);\r\n\t\t\t\tbuf.splice(caretNdx, leadingzeroes[0].length);\r\n\t\t\t\tvar newCaretPos = buf.length - caretNdx;\r\n\t\t\t\tstripBuffer(buf);\r\n\t\t\t\tresult = {\r\n\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\tbuffer: buf.reverse(),\r\n\t\t\t\t\tcaret: caretPos < newCaretPos ? caretPos : newCaretPos\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (e) {\r\n\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase \"blur\":\r\n\t\t\t\t\tcase \"checkval\":\r\n\t\t\t\t\t\tif (opts.min !== null) {\r\n\t\t\t\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\r\n\t\t\t\t\t\t\t\tunmaskAsNumber: true\r\n\t\t\t\t\t\t\t}));\r\n\t\t\t\t\t\t\tif (opts.min !== null && unmasked < opts.min) {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\trefreshFromBuffer: true,\r\n\t\t\t\t\t\t\t\t\tbuffer: alignDigits(opts.min.toString().replace(\".\", opts.radixPoint).split(\"\"), opts.digits, opts).reverse()\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (opts.radixPoint !== \"\" && buffer[0] === opts.radixPoint) {\r\n\t\t\t\t\t\t\tif (result && result.buffer) {\r\n\t\t\t\t\t\t\t\tresult.buffer.shift();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tbuffer.shift();\r\n\t\t\t\t\t\t\t\tresult =\r\n\t\t\t\t\t\t\t\t\t{refreshFromBuffer: true, buffer: stripBuffer(buffer)};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (buffer[buffer.length - 1] === opts.negationSymbol.front) {\r\n\t\t\t\t\t\t\t\tvar nmbrMtchs = new RegExp(\"(^\" + (opts.negationSymbol.front != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.front) + \"?\" : \"\") + Inputmask.escapeRegex(opts.prefix) + \")(.*)(\" + Inputmask.escapeRegex(opts.suffix) + (opts.negationSymbol.back != \"\" ? Inputmask.escapeRegex(opts.negationSymbol.back) + \"?\" : \"\") + \"$)\").exec(stripBuffer(buffer.slice(), true).reverse().join(\"\")),\r\n\t\t\t\t\t\t\t\t\tnumber = nmbrMtchs ? nmbrMtchs[2] : \"\";\r\n\t\t\t\t\t\t\t\tif (number == 0) {\r\n\t\t\t\t\t\t\t\t\tresult = {refreshFromBuffer: true, buffer: [0]};\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\r\n\t\t\tvar $input = $(this), bffr;\r\n\t\t\tif (e.ctrlKey) {\r\n\t\t\t\tswitch (e.keyCode) {\r\n\t\t\t\t\tcase Inputmask.keyCode.UP:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\tcase Inputmask.keyCode.DOWN:\r\n\t\t\t\t\t\tthis.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!e.shiftKey && (e.keyCode === Inputmask.keyCode.DELETE || e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI)) {\r\n\t\t\t\tif (buffer[e.keyCode === Inputmask.keyCode.DELETE ? caretPos.begin - 1 : caretPos.end] === opts.negationSymbol.front) {\r\n\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\tif (opts.negationSymbol.front !== \"\") bffr.shift();\r\n\t\t\t\t\tif (opts.negationSymbol.back !== \"\") bffr.pop();\r\n\t\t\t\t\t$input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t} else if (opts._radixDance === true) {\r\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\r\n\t\t\t\t\tif (!opts.digitsOptional) {\r\n\t\t\t\t\t\tif (radixPos !== -1 && (caretPos.begin < radixPos || (e.keyCode === Inputmask.keyCode.DELETE && caretPos.begin === radixPos))) {\r\n\t\t\t\t\t\t\tif (e.keyCode === Inputmask.keyCode.BACKSPACE || e.keyCode === Inputmask.keyCode.BACKSPACE_SAFARI) {\r\n\t\t\t\t\t\t\t\tcaretPos.begin++;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\t\t\tbffr.splice(bffr.length - caretPos.begin, 1);\r\n\t\t\t\t\t\t\t$input.trigger(\"setvalue\", [alignDigits(bffr, opts.digits, opts).join(\"\"), caretPos.begin]);\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (radixPos === 0) {\r\n\t\t\t\t\t\tbffr = buffer.slice().reverse();\r\n\t\t\t\t\t\tbffr.pop();\r\n\t\t\t\t\t\t$input.trigger(\"setvalue\", [bffr.join(\"\"), caretPos.begin]);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\"currency\": {\r\n\t\tprefix: \"$ \",\r\n\t\tgroupSeparator: \",\",\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t},\r\n\t\"decimal\": {\r\n\t\talias: \"numeric\"\r\n\t},\r\n\t\"integer\": {\r\n\t\talias: \"numeric\",\r\n\t\tdigits: 0\r\n\t},\r\n\t\"percentage\": {\r\n\t\talias: \"numeric\",\r\n\t\tmin: 0,\r\n\t\tmax: 100,\r\n\t\tsuffix: \" %\",\r\n\t\tdigits: 0,\r\n\t\tallowMinus: false\r\n\t},\r\n\t\"indianns\": { //indian numbering system\r\n\t\talias: \"numeric\",\r\n\t\t_mask: function (opts) {\r\n\t\t\treturn \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\r\n\t\t},\r\n\t\tgroupSeparator: \",\",\r\n\t\tradixPoint: \".\",\r\n\t\tplaceholder: \"0\",\r\n\t\tdigits: 2,\r\n\t\tdigitsOptional: false\r\n\t}\r\n});\r\nmodule.exports = Inputmask;\r\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}